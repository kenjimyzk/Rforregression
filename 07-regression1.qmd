---
output: 
  html_document:default
  html_notebook:default
---

# 古典的仮定のもとでの最小二乗法
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, collapse=TRUE)
```

```{r message=FALSE, warning=FALSE}
library(AER)
```



## 単回帰モデル
次の単回帰モデルを考える.

$$
y = \alpha + \beta x + u
$$
ここで $x$ は説明変数で,  $y$ は被説明変数である. $u$ は誤差項である.
パラメータとして $\alpha$ は切片パラメータ, $\beta$ は傾きパラメータである.


次の仮定を置いている.

+ $(x_i,y_i)$ は独立同一分布にしたがう.
+ $E[u_i]=0$ である.
+ $u_i$ と $x_i$ は独立である.
+ $u_i$ は正規分布にしたがう.

このとき最小二乗推定量は一致で, 不偏であり, 正規分布にしたがう.
一致とは推定量が観測値を増やすことによって真のパラメータに (確率) 収束することある.
不偏とは推定量の期待値が真のパラメータになることである.
また他の線形不偏推定量のなかで最も分散が小さいことも知られている.


仮想的に以下のモデルを考える.
ここでは標本サイズを100とし, 説明変数 $x$ は0から1の一様分布から生成する.
被説明変数 $y$ は真の切片パラメータを10, 真の傾きパラメータを2として, 正規分布の誤差項を加えて生成する.
最後にこれらのデータを `data.frame` 関数でデータフレームにまとめる.
```{r}
N <- 100
x <- runif(N)
y <- 10 + 2*x + rnorm(N)
df <- data.frame(x,y)
```
散布図を作図すると以下である.
`plot` 関数で `y~x` という形式で指定すると, x軸に説明変数, y軸に被説明変数をとった散布図が描かれる.
```{r}
plot(y~x)
```

R で回帰分析を実施するには `lm` 関数を使用する.
第一引数には回帰式を `y ~ x` という形式で指定し, `data` 引数にはデータフレームを指定する.
推定結果は `fm` というオブジェクトに保存する.
```{r}
fm <- lm(y ~ x, data=df)
```

`fm` 自体はリストであり, 以下の要素がある.
`typeof` 関数でオブジェクトの型を確認でき, `names` 関数でリストの要素名を確認できる.
```{r}
typeof(fm)
names(fm)
```

推定された係数 (切片と傾き) を取り出すには `coef` 関数を使用する.
`coefficients` 関数でも同じ結果が得られる (コメントアウトしている).
```{r}
coef(fm)
# coefficients(fm)
```

傾きの推定値は共分散を分散で割った値として計算できる.
`with` 関数を使ってデータフレーム内の変数を直接参照し, `cov` 関数で共分散, `var` 関数で分散を計算する.
```{r}
with(df, cov(x,y)/var(x))
```


散布図に推定された回帰直線を重ねて描くには, `plot` 関数で散布図を描いた後, `abline` 関数で回帰直線を追加する.
`abline` 関数に `lm` オブジェクトを渡すと自動的に回帰直線が描画される.
```{r}
plot(y~x,data=df)
abline(fm)
```

残差 (実際の値と予測値の差) を取り出すには `resid` 関数を使用する.
ここでは `head` 関数で最初の6つの値のみを表示している.
`residuals` 関数でも同じ結果が得られる (コメントアウトしている).
```{r}
head(resid(fm))
# residuals(fm)
# with(fm, residuals)
```

予測値 (回帰式から計算された $\hat{y}$ の値) を取り出すには `fitted` 関数を使用する.
ここでは `head` 関数で最初の6つの値のみを表示している.
`fitted.values` でも同じ結果が得られる (コメントアウトしている).
```{r}
head(fitted(fm))
# fitted.values(fm)
# with(fm, fitted.values)
```
最小二乗法の性質として, 予測値の平均は被説明変数の平均と等しいことが知られている.
以下のコマンドで両者が一致することを確認できる.
```{r}
mean(fitted(fm))
mean(df$y)
```


残差自乗和 (residual sum of squares) を計算するには `deviance` 関数を使用する.
これは残差を二乗して合計した値であり, `sum(resid(fm)^2)` で直接計算することもできる.
```{r}
deviance(fm)
sum(resid(fm)^2)
```

残差自乗和は残差変動とも呼ばれる．
予測値の偏差の自乗和を回帰変動といい, 被説明変数の偏差の自乗和を全変動という.
全変動は回帰変動と残差変動に分解できる (変動の分解).
以下のコマンドで, 左辺の全変動が右辺の回帰変動と残差変動の和に等しいことを確認できる.
```{r}
sum((df$y-mean(df$y))^2)
sum((fitted(fm)-mean(df$y))^2)+deviance(fm)
```


### ティー検定
回帰分析の詳細な結果を見るには `summary` 関数を使用する.
これにより係数の推定値, 標準誤差, t値, p値などが表示される.
```{r}
summary(fm)
```

この出力には以下の情報が含まれている:

+ Coefficients: 各変数の係数の推定値, 標準誤差, t値, p値 (係数がゼロであるというティー検定の結果)
+ Residual standard error: 残差標準誤差
+ Multiple R-squared: 決定係数 (モデルの当てはまりの良さ)
+ Adjusted R-squared: 修正済み決定係数 (説明変数の数を考慮した決定係数)
+ F-statistic: 全ての係数がゼロであるというエフ検定の結果

`summary(fm)` もリストであり, `typeof` 関数と `names` 関数でその構造を確認できる.
```{r}
typeof(summary(fm))
names(summary(fm))
```

単なる `fm` と同じ名前の要素もあるが, 中身が違っている場合がある.
例えば `residuals` は同じであるが, 係数には標準誤差やt値などの情報が加わっている.
`coef` 関数を `summary(fm)` に適用すると, これらの情報を含む行列が得られる.
```{r}
coef(summary(fm))
# coefficients(summary(fm))
```

残差の標準誤差 (residual standard error) は `summary(fm)` の `sigma` 要素から得られる.
これは残差自乗和を残差の自由度で割った値の平方根である.
```{r}
with(summary(fm),sigma)
sqrt(deviance(fm)/df.residual(fm))
```

決定係数 (R-squared) は `summary(fm)` の `r.squared` 要素から得られる.
これは 1 から (残差変動/全変動) を引いた値として計算される.
```{r}
with(summary(fm),r.squared)
1-deviance(fm)/with(df, sum((y-mean(y))^2))
```

調整済み決定係数 (adjusted R-squared) は `summary(fm)` の `adj.r.squared` 要素から得られる.
これは決定係数を自由度で調整した値であり, 説明変数の数が増えても必ずしも増加しない性質を持つ.
```{r}
with(summary(fm),adj.r.squared)
1-(deviance(fm)/df.residual(fm))/with(df, sum((y-mean(y))^2/(nrow(df)-1)))
```



### 対数変換
次のモデルを考える.
$$
y = \alpha + \beta \log(x) + u
$$

説明変数を対数変換する場合, `lm` 関数の式の中で直接 `log` 関数を使用できる.
この場合, 係数 $\beta$ は $x$ が1%変化したときの $y$ の変化量 (の近似値) を表す.
```{r}
fm <- lm(y~log(x),data=df)
summary(fm)
```

散布図と回帰直線を描くと以下のようになる.
横軸が対数変換された $x$ になっている点に注意.
```{r}
plot(y~log(x),data=df)
abline(fm)
```

被説明変数を対数変換する場合も同様に, `lm` 関数の式の中で `log` 関数を使用する.
この場合, 係数 $\beta$ は $x$ が1単位変化したときの $y$ の変化率 (%) の近似値を表す.
```{r}
fm <- lm(log(y)~x,data=df)
summary(fm)
```

散布図と回帰直線を描くと以下のようになる.
縦軸が対数変換された $y$ になっている点に注意.
```{r}
plot(log(y)~x,data=df)
abline(fm)
```


被説明変数と説明変数の両方を対数変換する場合 (対数線形モデル) は以下のようにする.
この場合, 係数 $\beta$ は弾力性を表し, $x$ が1%変化したときの $y$ の変化率 (%) を表す.
```{r}
fm <- lm(log(y)~log(x),data=df)
summary(fm)
```

散布図と回帰直線を描くと以下のようになる.
両軸とも対数変換されている点に注意.
```{r}
plot(log(y)~log(x),data=df)
abline(fm)
```



### 切片なし回帰モデル
次のモデルを考える.
$$
y = \beta x + u
$$

切片を含まないモデルを推定したい場合は, 式の中に `-1` を加える.
これにより切片項が除外され, 原点を通る回帰直線が推定される.
```{r}
fm <- lm(y~x-1,data=df)
summary(fm)
```

もしくは `+0` を加えることでも同じ結果が得られる.
```{r}
fm <- lm(y~x+0,data=df)
summary(fm)
```


## 重回帰モデル

説明変数として $w$ を加えたモデルを考える.
$$
y = \alpha + \beta x +\gamma w+ u
$$

暗黙に次の仮定を置いている.

+ $(w_i, x_i,y_i)$ は独立同一分布にしたがう.
+ 誤差項の期待値はゼロである. $E[u_i]=0$ である.
+ 誤差項 $u_i$ は説明変数 $(x_i, w_i)$ に対して独立である.
+ 誤差項 $u_i$ は正規分布にしたがう.
+ 説明変数間に多重共線性は存在しない. つまり $x_i$ は $w_i$ の一次変換で表せない.


仮想的に以下のモデルを考える.
標本サイズを100とし, 説明変数 $x$ は0から1の一様分布から, $w$ は「H」と「T」からランダムに生成する.
被説明変数 $y$ は, 真の切片を10, $x$ の係数を2, $w$ が「H」のときに1を加算し, 正規分布の誤差項を加えて生成する.
```{r}
N <- 100
x<-runif(N)
w<-sample(c("H","T"),N,replace=TRUE)
y <- 10 + 2*x + ifelse(w=="H",1,0) + rnorm(N)
df <- data.frame(w,x,y)
```

複数の説明変数を含むモデルを推定するには, `+` 記号で変数を連結する.
式 `y~x+w` は被説明変数 $y$ を説明変数 $x$ と $w$ で回帰することを意味する.
```{r}
fm <- lm(y~x+w,data=df)
summary(fm)
```

R の特徴として, 因子型 (factor) やカテゴリカル変数 (文字列) を特に変換することなく自動的にダミー変数として扱える.
ここでは $w$ が「H」と「T」の2値をとるが, 自動的に一方 (「H」) のダミー変数が作成され, 「T」が基準カテゴリとなる.

### 自乗項
説明変数として自乗項を加えたモデルを考える.
$$
y = \alpha + \beta x + \gamma x^2 + u
$$

R で自乗項を式に含める場合, `I()` 関数で囲んで `I(x^2)` と記述する必要がある.
これは `^` が R の式の中で特別な意味を持つため, 通常の算術演算として解釈させるための処理である.
```{r}
fm <- lm(y~x+I(x^2),data=df)
summary(fm)
```

### 交差項
説明変数として交差項 (interaction term) を加えたモデルを考える.
$$
y = \alpha + \beta x + \gamma w + \delta xw + u
$$

説明変数 `x` と `w` の交差項は `:` 記号を使って `x:w` と表す.
このモデルでは主効果 `x` と `w` に加えて, 交差項 `x:w` を明示的に指定している.
```{r}
fm<-lm(y~x+w+x:w,data=df)
summary(fm)
```

もしくは以下のように `*` 記号を使って簡便に表すこともできる.
`x*w` は自動的に `x + w + x:w` に展開される.
```{r}
fm <- lm(y~x*w,data=df)
summary(fm)
```

### エフ検定
今, 帰無仮説が
$$
y = \alpha + \beta x + u
$$
で, 対立仮説が
$$
y = \alpha + \beta x + \gamma w + \delta xw + u
$$
となる検定を実施したい.

これは複数の係数 ($\gamma$ と $\delta$) が同時にゼロであるかを検定するエフ検定である.
このような制約付き検定は, 制約なしモデル (対立仮説) と制約付きモデル (帰無仮説) の残差自乗和を比較することで実施できる.
対立仮説 (制約なしモデル) の残差自乗和を $SSR$ とし, その自由度を $df$ とする.
自由度は観測数から推定されるパラメータの数 (説明変数の数と切片) を減じた数である.
帰無仮説 (制約付きモデル) の残差自乗和を $SSR_0$ とし, 制約の数を $q$ とする.
制約の数は帰無仮説の自由度から対立仮説の自由度を差し引いた数である.
このとき, 以下のF値は帰無仮説が正しいもとで自由度 $(q, df)$ のF分布にしたがう.
$$
F = \frac{(SSR_0-SSR)/q}{SSR/df}
$$

R でF値を手動で計算するには以下のようにする.
まず両方のモデルを推定し, それぞれの自由度 (`$df`) と残差自乗和 (`deviance`) を取り出す.
制約の数 $q$ は両モデルの自由度の差である.
F値は上記の式に従って計算する.
```{r}
fm0 <- lm(y~x,data=df)
fm1 <- lm(y~x*w,data=df)
dof <- fm1$df
q <- fm0$df-dof
SSR0 <- deviance(fm0)
SSR <- deviance(fm1)
(F <- ((SSR0-SSR)/q)/(SSR/dof))
```

このF値に対応するp値は `pf` 関数を使って計算できる.
`pf` 関数はF分布の累積分布関数であり, `1-pf(F, df1, df2)` で上側確率 (p値) が得られる.
第一自由度 (`df1`) は制約の数 $q$, 第二自由度 (`df2`) は対立仮説の自由度である.
```{r}
1-pf(F,df1=q,df2=dof)
```

これらの手順は `anova` 関数を用いれば簡単に実行できる.
`anova` 関数に2つのモデルを渡すと, 自動的にエフ検定を実施し, F値とp値を表示してくれる.
```{r}
anova(fm0,fm1)
```

モデルの順番を入れ替えても, 検定統計量とp値は同じである.
ただし残差自乗和の差の符号が変わるため, 出力の見た目は異なる.
```{r}
anova(fm1,fm0)
```

