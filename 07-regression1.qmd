---
output: 
  html_document:default
  html_notebook:default
---

# 古典的仮定のもとでの最小二乗法
```{r}
#| label: setup
#| include: false
knitr::opts_chunk$set(echo = TRUE, collapse=TRUE)
```

```{r}
#| message: false
#| warning: false
library(AER)
```



## 単回帰モデル
まず次の単回帰モデルを考える。

$$
y = \alpha + \beta x + u
$$
ここで $x$ は説明変数、$y$ は被説明変数、$u$ は誤差項である。
パラメータとして $\alpha$ は切片パラメータ, $\beta$ は傾きパラメータである.


以下の仮定を置く。

+ $(x_i, y_i)$ は独立同一分布に従う。
+ $E[u_i] = 0$ である。
+ $u_i$ と $x_i$ は独立である。
+ $u_i$ は正規分布に従う。

これらの仮定の下では、最小二乗推定量は一致性と不偏性を持ち、さらに正規分布に従う。
一致（consistency）とは、観測数が多くなるにつれて推定量が真のパラメータに確率収束する性質である。
不偏性とは、推定量の期待値が真のパラメータに等しくなることである。
さらに、他の線形不偏推定量の中で最小の分散を持つ（BLUE: best linear unbiased estimator）。


以降ではシミュレーションデータを用いて具体的に確認する。
ここでは標本サイズを100とし, 説明変数 $x$ は0から1の一様分布から生成する.
被説明変数 $y$ は真の切片パラメータを10, 真の傾きパラメータを2として, 正規分布の誤差項を加えて生成する.
最後にこれらのデータを `data.frame` 関数でデータフレームにまとめる.
```{r}
N <- 100
x <- runif(N)
y <- 10 + 2*x + rnorm(N)
df <- data.frame(x,y)
```
散布図を描くと次のようになる。
`plot` に `y ~ x` と指定すると、横軸に説明変数、縦軸に被説明変数を取った散布図が描かれる。
```{r}
plot(y~x)
```

R で回帰分析を実施するには `lm` 関数を使用する.
第一引数には回帰式を `y ~ x` という形式で指定し, `data` 引数にはデータフレームを指定する.
推定結果は `fm` というオブジェクトに保存する.
```{r}
fm <- lm(y ~ x, data=df)
```

`fm` はリストとして保存されており、以下のような要素を持つ。
`typeof()` でオブジェクトの型を、`names()` で各要素名を確認できる。
```{r}
typeof(fm)
names(fm)
```

推定された係数 (切片と傾き) を取り出すには `coef` 関数を使用する.
`coefficients` 関数でも同じ結果が得られる (コメントアウトしている).
```{r}
coef(fm)
# coefficients(fm)
```

傾きの推定値は、説明変数と被説明変数の共分散を説明変数の分散で割ることで求められる。
`with` 関数を使ってデータフレーム内の変数を直接参照し, `cov` 関数で共分散, `var` 関数で分散を計算する.
```{r}
with(df, cov(x,y)/var(x))
```


散布図に推定直線を重ねるには、まず `plot()` で散布図を描き、続いて `abline()` に `lm` オブジェクトを渡す。
`abline` 関数に `lm` オブジェクトを渡すと自動的に回帰直線が描画される.
```{r}
plot(y~x,data=df)
abline(fm)
```

残差（実際の値と予測値の差）は `resid()` で取得できる。
ここでは `head` 関数で最初の6つの値のみを表示している.
`residuals` 関数でも同じ結果が得られる (コメントアウトしている).
```{r}
head(resid(fm))
# residuals(fm)
# with(fm, residuals)
```

予測値（$38$hat{y}$）は `fitted()` によって得られる。
ここでは `head` 関数で最初の6つの値のみを表示している.
`fitted.values` でも同じ結果が得られる (コメントアウトしている).
```{r}
head(fitted(fm))
# fitted.values(fm)
# with(fm, fitted.values)
```
最小二乗法の性質として, 予測値の平均は被説明変数の平均と等しいことが知られている.
以下のコマンドで両者が一致することを確認できる.
```{r}
mean(fitted(fm))
mean(df$y)
```


残差自乗和 (residual sum of squares) を計算するには `deviance` 関数を使用する.
これは残差を二乗して合計した値であり, `sum(resid(fm)^2)` で直接計算することもできる.
```{r}
deviance(fm)
sum(resid(fm)^2)
```

残差自乗和は残差変動とも呼ばれる。
予測値の偏差の自乗和を回帰変動、被説明変数の偏差の自乗和を全変動という。
全変動は回帰変動と残差変動に分解できる（変動の分解）。
以下のコマンドで, 左辺の全変動が右辺の回帰変動と残差変動の和に等しいことを確認できる.
```{r}
sum((df$y-mean(df$y))^2)
sum((fitted(fm)-mean(df$y))^2)+deviance(fm)
```


### ティー検定
推定結果を詳しく確認するには `summary()` を利用する。
これにより係数の推定値, 標準誤差, t値, p値などが表示される.
```{r}
summary(fm)
```

出力には主に次の指標が含まれる。

+ Coefficients: 係数の推定値、標準誤差、t値、p値（係数がゼロであるとの仮説に対する t 検定）
+ Residual standard error: 残差標準誤差
+ Multiple R-squared: 決定係数（当てはまりの良さ）
+ Adjusted R-squared: 修正済み決定係数（説明変数の数を考慮した指標）
+ F-statistic: 全係数がゼロであるとの仮説に対する F 検定

`summary(fm)` もリストであり, `typeof` 関数と `names` 関数でその構造を確認できる.
```{r}
typeof(summary(fm))
names(summary(fm))
```

単なる `fm` と同じ名前の要素もあるが, 中身が違っている場合がある.
たとえば `residuals` は同じだが、係数には標準誤差や t 値などの情報が付与される。
`coef` 関数を `summary(fm)` に適用すると, これらの情報を含む行列が得られる.
```{r}
coef(summary(fm))
# coefficients(summary(fm))
```

残差標準誤差（residual standard error）は `summary(fm)$sigma` から取得できる。
これは残差自乗和を残差の自由度で割った値の平方根である。
```{r}
with(summary(fm),sigma)
sqrt(deviance(fm)/df.residual(fm))
```

決定係数（R-squared）は `summary(fm)$r.squared` に格納されている。
これは 1 から (残差変動/全変動) を引いた値として計算される.
```{r}
with(summary(fm),r.squared)
1-deviance(fm)/with(df, sum((y-mean(y))^2))
```

調整済み決定係数（adjusted R-squared）は `summary(fm)$adj.r.squared` から得られる。
これは決定係数を自由度で調整した値であり, 説明変数の数が増えても必ずしも増加しない性質を持つ.
```{r}
with(summary(fm),adj.r.squared)
1-(deviance(fm)/df.residual(fm))/with(df, sum((y-mean(y))^2/(nrow(df)-1)))
```



### 対数変換
次のモデルを考える.
$$
y = \alpha + \beta \log(x) + u
$$

説明変数を対数変換する場合, `lm` 関数の式の中で直接 `log` 関数を使用できる.
この場合, 係数 $\beta$ は $x$ が1%変化したときの $y$ の変化量 (の近似値) を表す.
```{r}
fm <- lm(y~log(x),data=df)
summary(fm)
```

散布図と回帰直線を描くと以下のようになる.
横軸が対数変換された $x$ になっている点に注意.
```{r}
plot(y~log(x),data=df)
abline(fm)
```

被説明変数を対数変換する場合も同様に, `lm` 関数の式の中で `log` 関数を使用する.
この場合, 係数 $\beta$ は $x$ が1単位変化したときの $y$ の変化率 (%) の近似値を表す.
```{r}
fm <- lm(log(y)~x,data=df)
summary(fm)
```

散布図と回帰直線を描くと以下のようになる.
縦軸が対数変換された $y$ になっている点に注意.
```{r}
plot(log(y)~x,data=df)
abline(fm)
```


被説明変数と説明変数の両方を対数変換する場合 (対数線形モデル) は以下のようにする.
この場合, 係数 $\beta$ は弾力性を表し, $x$ が1%変化したときの $y$ の変化率 (%) を表す.
```{r}
fm <- lm(log(y)~log(x),data=df)
summary(fm)
```

散布図と回帰直線を描くと以下のようになる.
両軸とも対数変換されている点に注意.
```{r}
plot(log(y)~log(x),data=df)
abline(fm)
```



### 切片なし回帰モデル
次のモデルを考える.
$$
y = \beta x + u
$$

切片を含まないモデルを推定したい場合は, 式の中に `-1` を加える.
これにより切片項が除外され, 原点を通る回帰直線が推定される.
```{r}
fm <- lm(y~x-1,data=df)
summary(fm)
```

`+0` を加えても同じ効果が得られる。
```{r}
fm <- lm(y~x+0,data=df)
summary(fm)
```


## 重回帰モデル

説明変数として $w$ を加えたモデルを考える.
$$
y = \alpha + \beta x +\gamma w+ u
$$

暗黙に以下の仮定を置く。

+ $(w_i, x_i,y_i)$ は独立同一分布にしたがう.
+ 誤差項の期待値はゼロである. $E[u_i]=0$ である.
+ 誤差項 $u_i$ は説明変数 $(x_i, w_i)$ に対して独立である.
+ 誤差項 $u_i$ は正規分布にしたがう.
+ 説明変数間に多重共線性は存在しない. つまり $x_i$ は $w_i$ の一次変換で表せない.


以降ではシミュレーションデータを用いて具体的に確認する。
標本サイズを100とし, 説明変数 $x$ は0から1の一様分布から, $w$ は「H」と「T」からランダムに生成する.
被説明変数 $y$ は, 真の切片を10, $x$ の係数を2, $w$ が「H」のときに1を加算し, 正規分布の誤差項を加えて生成する.
```{r}
N <- 100
x<-runif(N)
w<-sample(c("H","T"),N,replace=TRUE)
y <- 10 + 2*x + ifelse(w=="H",1,0) + rnorm(N)
df <- data.frame(w,x,y)
```

複数の説明変数を含むモデルを推定するには, `+` 記号で変数を連結する.
式 `y~x+w` は被説明変数 $y$ を説明変数 $x$ と $w$ で回帰することを意味する.
```{r}
fm <- lm(y~x+w,data=df)
summary(fm)
```

R の特徴として, 因子型 (factor) やカテゴリカル変数 (文字列) を特に変換することなく自動的にダミー変数として扱える.
ここでは $w$ が「H」と「T」の2値をとるが, 自動的に一方 (「H」) のダミー変数が作成され, 「T」が基準カテゴリとなる.

### 自乗項
説明変数として自乗項を加えたモデルを考える.
$$
y = \alpha + \beta x + \gamma x^2 + u
$$

自乗項を含めるときは `I(x^2)` のように `I()` で囲む。
これは `^` が式中で特別扱いされるため、通常の演算として解釈させる工夫である。
```{r}
fm <- lm(y~x+I(x^2),data=df)
summary(fm)
```

### 交差項
説明変数として交差項 (interaction term) を加えたモデルを考える.
$$
y = \alpha + \beta x + \gamma w + \delta xw + u
$$

交差項（interaction）は `:` を使って `x:w` と表記する。
このモデルでは主効果 `x` と `w` に加えて, 交差項 `x:w` を明示的に指定している.
```{r}
fm<-lm(y~x+w+x:w,data=df)
summary(fm)
```

`*` を使えば主要効果と交差項をまとめて指定できる。
`x*w` は自動的に `x + w + x:w` に展開される.
```{r}
fm <- lm(y~x*w,data=df)
summary(fm)
```

### エフ検定
今, 帰無仮説が
$$
y = \alpha + \beta x + u
$$
で, 対立仮説が
$$
y = \alpha + \beta x + \gamma w + \delta xw + u
$$
となる検定を実施したい.

これは複数の係数（ここでは $\gamma$ と $\delta$）が同時にゼロかどうかを調べる F 検定である。
制約付き検定は、制約のあるモデル（帰無仮説）とないモデル（対立仮説）の残差自乗和を比較することで実施できる。
対立仮説（制約なしモデル）の残差自乗和を $SSR$、自由度を $df$ とする。
自由度は観測数から推定されるパラメータの数 (説明変数の数と切片) を減じた数である.
帰無仮説（制約付きモデル）の残差自乗和を $SSR_0$、制約の数を $q$ とする。
制約の数は帰無仮説の自由度から対立仮説の自由度を差し引いた数である.
このとき, 以下のF値は帰無仮説が正しいもとで自由度 $(q, df)$ のF分布にしたがう.
$$
F = \frac{(SSR_0-SSR)/q}{SSR/df}
$$

R でF値を手動で計算するには以下のようにする.
まず両方のモデルを推定し, それぞれの自由度 (`$df`) と残差自乗和 (`deviance`) を取り出す.
制約の数 $q$ は両モデルの自由度の差である.
F値は上記の式に従って計算する.
```{r}
fm0 <- lm(y~x,data=df)
fm1 <- lm(y~x*w,data=df)
dof <- fm1$df
q <- fm0$df-dof
SSR0 <- deviance(fm0)
SSR <- deviance(fm1)
(F <- ((SSR0-SSR)/q)/(SSR/dof))
```

F 値に対する p 値は `pf()` で計算できる。
`pf()` は F 分布の累積分布関数で、`1 - pf(F, df1, df2)` が上側確率（p 値）となる。
第一自由度 (`df1`) は制約の数 $q$, 第二自由度 (`df2`) は対立仮説の自由度である.
```{r}
1-pf(F,df1=q,df2=dof)
```

これらの手順は `anova()` を使えば自動で計算できる。
`anova` 関数に2つのモデルを渡すと, 自動的にエフ検定を実施し, F値とp値を表示してくれる.
```{r}
anova(fm0,fm1)
```

モデルの順序を入れ替えても検定統計量や p 値に変わりはない。
ただし残差自乗和の差の符号が変わるため、出力の一部が入れ替わって見える。
```{r}
anova(fm1,fm0)
```

