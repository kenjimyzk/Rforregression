---
output: html_document
---

# 整然データ
```{r}
#| label: setup
#| include: false
knitr::opts_chunk$set(echo = TRUE)
```

http://r4ds.had.co.nz/tidy-data.html

データが整然 (tidy) であるとは次の条件を満たすデータのことである.

1. 個々の変数 (variable) が1つの列 (column) である
2. 個々の観測 (observation) が1つの行 (row) である
3. 個々の値 (value) が1つのセル (cell) である

![tidy data](http://r4ds.had.co.nz/images/tidy-1.png)

この章では、データを整然な形に整形する方法と、もともとのデータを整然データへ変換する手順を紹介する。

ここでは tidyverse を中心に作業を進める。
```{r}
#| message: false
#| warning: false
library(tidyverse)
```
特に `dplyr` と `tidyr` の機能を活用する。

## データ整形
まずデータセット `mtcars` を例に取り、整形の基本操作を確認する。`as_tibble()` を介して行名を列に移すと、後続の操作が行いやすくなる。
```{r}
mtcars_tbl <- mtcars |> 
  as_tibble(rownames = "model")

mtcars_tbl |> slice_head(n = 6)
```

ここでは R 4.1 から導入されたパイプ演算子 `|>` を利用している。従来の `%>%` と同様に、左辺の結果を右辺の関数に渡す構文である。

`dplyr` を使うとデータフレームの処理が大幅に簡潔になる。
変数の抽出には `select()` を使う。
```{r}
mtcars_tbl |> 
  select(model, mpg, disp) |> 
  slice_head(n = 6)
```

条件に合致した行だけを抽出したい場合は `filter()` が便利である。
```{r}
mtcars_tbl |> 
  select(model, mpg, disp) |> 
  filter(disp > 300)
```

`rename()` を使えば変数名を変更できる。日本語の列名にも対応している。
```{r}
mtcars_tbl |> 
  select(model, mpg, disp) |> 
  rename(速度 = mpg, 距離 = disp) |> 
  slice_head(n = 6)
```

並べ替えは `arrange()` で行う。
```{r}
mtcars_tbl |> 
  select(model, mpg, disp) |> 
  arrange(mpg) |> 
  slice_head(n = 6)
```

降順に並べる場合は `desc()` と組み合わせる。
```{r}
mtcars_tbl |> 
  select(model, mpg, disp) |> 
  arrange(desc(mpg)) |> 
  slice_head(n = 6)
```

`mutate()` を使うと新しい列を追加できる。
```{r}
mtcars_tbl |> 
  mutate(gpm = 1 / mpg) |> 
  select(model, mpg, gpm) |> 
  slice_head(n = 6)
```
`mutate()` は既存列の上書きや複数列の同時作成も可能で、計算や条件分岐をまとめて記述できる点が強みである。

次の例では、`mpg` が 20 を超える場合に `TRUE` を返すブール列を追加している。
```{r}
mtcars_tbl |> 
  mutate(is_high_mileage = mpg > 20) |> 
  select(model, mpg, is_high_mileage) |> 
  slice_head(n = 6)
```

`summarise()` で基本統計量を算出できる。
```{r}
mtcars_tbl |> 
  summarise(avg = mean(mpg), 
            sd  = sd(mpg), 
            .groups = "drop")
```
列名を任意に付けておけば、後続の処理で指標を参照しやすくなる。


`summarise()` に `.by` を指定すれば、グループごとの集計も容易である。

```{r}
mtcars_tbl |> 
  summarise(
    n   = n(),
    avg = mean(mpg),
    sd  = sd(mpg),
    .by = cyl
  )
```

## データ結合
`dplyr` にはデータフレームを縦横方向に結合したり、キーを用いて結合したりするための関数が揃っている。

縦方向に結合するには `bind_rows()` を使う。
```{r}
df1 <- tibble(X = 1:2, Y = 1:2)
df2 <- tibble(X = 4,   Y = 4)

bind_rows(df1, df2)
```
列名と型が一致していれば、欠けている列には自動で `NA` が補われる。

横方向に結合する場合は `bind_cols()` を利用する。
```{r}
df3 <- tibble(Z = 5:6)
bind_cols(df1, df3)
```
行数が一致していないとリサイクルされるか警告が出るので注意する。

キーを用いた結合には四種類の join 関数が利用できる。
```{r}
dfx <- tibble(id = c("A", "B", "C"), X = 1:3)
dfy <- tibble(id = c("A", "B", "D"), Y = c(TRUE, FALSE, TRUE))
```

左側データ（`dfx`）の行をすべて保持して結合するには `left_join()` を用いる。
```{r}
left_join(dfx, dfy, by = "id")
```

右側データ（`dfy`）の行をすべて保持するなら `right_join()`。
```{r}
right_join(dfx, dfy, by = "id")
```

両方の行をすべて保持するなら `full_join()`。
```{r}
full_join(dfx, dfy, by = "id")
```

`inner_join()` は共通部分のみを抽出する。
```{r}
inner_join(dfx, dfy, by = "id")
```
より複雑な条件で結合したい場合は `join_by()` を使うと柔軟に定義できる。
複雑な条件で結合したい場合は `join_by()` を使うと柔軟に定義できる。

## tidyr

ここからは `tidyr` による整形の例を紹介する。まず次のデータセットを用意する。
```{r}
df <- tibble(
  time = 2010:2014,
  X = rnorm(5, 0, 1),
  Y = rnorm(5, 0, 2),
  Z = rnorm(5, 0, 4)
)
# `tibble()` なら列の型を意識しつつ手早くサンプル値を用意できる
df |> slice_head(n = 6)
```

列名をキーにして縦長へ変換するときは `pivot_longer()` を用いる。
```{r}
df_long <- df |> 
  pivot_longer(-time, names_to = "key", values_to = "value")
# names_to / values_to を指定しておくと後続処理が読みやすい
df_long
```

`pivot_wider()` を使えば再び元の構造に戻すことができる。
```{r}
df_long |> 
  pivot_wider(names_from = "key", values_from = "value")
```
列数を増やして見せたいときや、プレゼン資料で横持ちの表が必要なときに役立つ。

`time` を列方向に展開すれば、年次を横持ちした表へ変換できる。
```{r}
df_wide <- df_long |> 
  pivot_wider(names_from = "time", values_from = "value")
df_wide
```

再び縦長に戻す場合は次のとおりである。
```{r}
df_wide |> 
  pivot_longer(-key, names_to = "time", values_to = "value")
```

`pivot_longer()` と `summarise()` を組み合わせると、変数別の記述統計を簡潔にまとめられる。
```{r}
cars |> 
  as_tibble() |> 
  pivot_longer(everything(), names_to = "variable", values_to = "value") |> 
  summarise(
    nobs = n(),
    avg  = mean(value),
    sd   = sd(value),
    .by  = variable
  )
# 欠損を除外したいときは mean(value, na.rm = TRUE) のように na.rm を付ける
```

日本語の列名でも同じ操作が可能である。
```{r}
tab <- cars |> 
  as_tibble() |> 
  rename(距離 = dist, 速度 = speed) |> 
  pivot_longer(everything(), names_to = "変数", values_to = "value") |> 
  summarise(
    観測数   = n(),
    平均     = mean(value),
    標準偏差 = sd(value),
    .by      = 変数
  )
tab |> slice_head(n = 6)
```

## 実践例
tidyr を用いた別の例を見てみよう。横軸を年としたデータセット `df` がある。
```{r}
df <- tibble(
  name  = letters,
  `2010` = rnorm(26),
  `2011` = rnorm(26),
  `2012` = rnorm(26)
) 
df |> slice_head(n = 6)
```

さらに、年ごとのデータセット `df_2010`、`df_2011`、`df_2012` の 3 つも用意する。
```{r}
df_2010 <- tibble(name = letters, runif = runif(26))
df_2011 <- tibble(name = letters, runif = runif(26))
df_2012 <- tibble(name = letters, runif = runif(26))
```
これら 4 つのデータセットを統合して整然データにする。

まず `df` を `pivot_longer()` で縦長に変換する。
```{r}
df_rnorm <- df |> 
  pivot_longer(-name, names_to = "time", values_to = "rnorm") |> 
  mutate(time = as.numeric(time))
df_rnorm |> slice_head(n = 6)
```
ここでは `time` 列を数値に変換している。

次に、3 つの年別データセットを `bind_rows()` で縦に結合する。
```{r}
df_runif <- bind_rows(
  "2010" = df_2010,
  "2011" = df_2011,
  "2012" = df_2012,
  .id    = "time"
) |> 
  mutate(time = as.numeric(time))
df_runif |> slice_head(n = 6)
```
`.id` で追加された列を数値に変換して年情報として利用している。

最後に `full_join()` を使って 2 つのデータを結合する。
```{r}
df_full <- full_join(df_rnorm, df_runif, by = c("name", "time"))
df_full |> slice_head(n = 6)
```
整然データにまとめておけば、`ggplot2` やモデリング関数へそのまま渡せるため、後続処理がスムーズになり再現性も高まる。
