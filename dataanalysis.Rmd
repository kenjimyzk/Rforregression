---
title: "Untitled"
output:
  html_document: default
  html_notebook: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(mosaic)
```


## データ分析
### 単回帰分析
回帰分析は以下のコマンドで実施する.
```{r}
fm <- lm(dist ~ speed, data= cars)
```

```{r}
cars %>% gf_point(dist ~ speed) %>% gf_lm()
```


リストが作られる.
```{r}
typeof(fm)
names(fm)
```

主な
```{r}
fm[["coefficients"]] # fm$coefficients
fm[["residuals"]]  # fm$residuals
fm[["fitted.values"]] # fm$fitted.values
```

これらは以下の関数でも計算できる.
```{r}
coef(fm)
resid(fm)
fitted(fm) #predict(fm)
```


計算結果は `summary()` で表記される.
```{r}
summary(fm)
```

これもリスト型であり, 以下の要素をもつ.
```{r}
typeof(summary(fm))
names(summary(fm))
```

おもな要素は以下である.
```{r}
summary(fm)[["coefficients"]]
summary(fm)[["sigma"]]
summary(fm)[["r.squared"]]
summary(fm)[["adj.r.squared"]]
summary(fm)[["cov.unscaled"]]
```

次のように計算してもよい. 
```{r}
coef(summary(fm))
sigma(fm)
vcov(fm)
```

### 重回帰分析
複数の変数は `+` 付け足すことができる.
```{r}
fm<-lm(mpg ~ disp + wt, data =mtcars)
summary(fm)
```

```{r}
data("CPS1985", package="AER")
summary(CPS1985)
fm1 <- lm(wage ~ experience + education, data=CPS1985)
summary(fm1)
```


### 非線形モデル
被説明変数が対数をとるときの回帰分析は以下を実行する.
```{r}
fm_1 <-lm(log(dist) ~ speed, data=cars)
summary(fm_1)
```

```{r}
cars %>% gf_point(log(dist) ~ speed) %>% gf_lm()
```

```{r}
fn1 <- makeFun(fm_1)
cars %>% gf_point(log(dist) ~ speed) %>% gf_fun(log(fn1(speed))~speed)
```

```{r}
cars %>% gf_point(dist ~ speed) %>% gf_fun(fn1(speed)~speed)
```

説明変数が対数をとるときの回帰分析は以下を実行する.
```{r}
fm_2 <- lm(dist ~ log(speed), data=cars)
summary(fm_2)
```

```{r}
cars %>% gf_point(dist ~ log(speed)) %>% gf_lm()
```

```{r}
fn2 <- makeFun(fm_2)
cars %>% gf_point(dist ~ log(speed)) %>% gf_fun(fn2(exp(x)) ~ x)
```

```{r}
cars %>% gf_point(dist ~ speed) %>% gf_fun(fn2(speed)~speed)
```

両方が対数をとるときの回帰分析は以下を実行する.
```{r}
fm_3 <- lm(log(dist) ~ log(speed), data=cars)
summary(fm_3)
```

```{r}
log(cars) %>% gf_point(dist ~ speed) %>% gf_lm()
```

```{r}
fn3 <- makeFun(fm_3)
cars %>% gf_point(log(dist) ~ log(speed)) %>% gf_fun(log(fn3(exp(x))) ~ x)
```

```{r}
cars %>% gf_point(dist ~ speed) %>% gf_fun(fn3(x) ~ x)
```

または以下のように実行してもよい.
```{r}
fm_4 <-lm(dist ~ speed, data=log(cars))
summary(fm_4)
```

```{r}
log(cars) %>% gf_point(dist ~ speed) %>% gf_lm()
```

```{r}
fn4 <- makeFun(fm_4)
log(cars) %>% gf_point(dist ~ speed) %>% gf_fun(fn4(x) ~ x)
```


## 多項式
```{r}
summary(lm(dist ~ speed + I(speed^2), data=cars))
```

```{r}
fm_5 <- lm(dist ~ poly(speed,2,raw=TRUE), data=cars)
summary(fm_5)
```

```{r}
fn5 <- makeFun(fm_5)
cars %>% gf_point(dist ~ speed) %>% gf_fun(fn5(x) ~ x)
```

## ダミー変数
```{r}
summary(mtcars)
fm1<-lm(mpg ~ disp + am, data =mtcars)
summary(fm1)
```

```{r}
fn1 <- makeFun(fm1)
mtcars %>% gf_point(mpg ~ disp) %>% 
  gf_fun(fn1(x, am=0) ~ x, color="red") %>% 
  gf_fun(fn1(x, am=1) ~ x, color="blue")
```

```{r}
fm<-lm(mpg ~ disp + factor(cyl), data =mtcars)
summary(fm)
```

```{r}
fn <- makeFun(fm)
mtcars %>% gf_point(mpg ~ disp) %>% 
  gf_fun(fn(x, cyl = "4") ~ x, color="blue") %>% 
  gf_fun(fn(x, cyl = "6") ~ x, color="red") %>% 
  gf_fun(fn(x, cyl = "8") ~ x, color="pink")
```


```{r}
data("CPS1985", package="AER")
summary(CPS1985)
fm1 <- lm(log(wage) ~ education + gender, data=CPS1985)
summary(fm1)
```

```{r}
library(mosaic)
fn <- makeFun(fm1)
CPS1985 %>% gf_point(log(wage)~education) %>% 
  gf_fun(log(fn(education,gender="male"))~education,color="red") %>%
  gf_fun(log(fn(education,gender="female"))~education,color="blue")
```

## 交差項
```{r}
fm<-lm(mpg ~ disp + factor(cyl) + disp:factor(cyl), data =mtcars)
summary(fm)
```

```{r}
fm<-lm(mpg ~ disp * factor(cyl), data =mtcars)
summary(fm)
```

```{r}
fn <- makeFun(fm)
mtcars %>% gf_point(mpg ~ disp, color = ~factor(cyl)) %>% 
  gf_fun(fn(x, cyl = "4") ~ x, color="red") %>% 
  gf_fun(fn(x, cyl = "6") ~ x, color="green") %>% 
  gf_fun(fn(x, cyl = "8") ~ x, color="blue")
```

```{r}
mtcars %>% gf_point(mpg ~ disp,color = ~factor(cyl)) %>%
  gf_lm(color = ~factor(cyl))
```


```{r}
fm2 <- lm(log(wage) ~ education + gender + education:gender, data=CPS1985)
summary(fm2)
```

```{r}
fm2 <- lm(log(wage) ~ education * gender, data=CPS1985)
```

```{r}
library(mosaic)
fn <- makeFun(fm2)
CPS1985 %>% gf_point(log(wage)~education) %>% 
  gf_fun(log(fn(education,gender="male"))~education,color="red") %>%
  gf_fun(log(fn(education,gender="female"))~education,color="blue")
```

以下のようにして, 簡単に作図できる.
```{r}
CPS1985 %>% gf_point(log(wage)~education) %>% gf_lm(color = ~gender)
```


## F検定
個々の説明変数の有意性はティー検定を実施すればよい.
複数の場合はエフ検定を実施する.
```{r}
fm1<- lm(log(wage)~experience, data=CPS1985)
fm2<- update(fm1,.~.+I(experience^2))
fm3 <- update(fm2,.~.+education+gender)
fm4 <- update(fm2,.~.+education*gender)
anova(fm1,fm2,fm3,fm4)

```


## ロバスト分散
説明変数と誤差項が互いに独立とは言い切れず,
せいぜい無相関の場合, 最小二乗推定量は不偏でなく一致である.
漸近的に正規分布にしたがうが,
係数の分散の計算方法を変える必要がある.

```{r}
library(AER)
coeftest(fm4,vcov=vcovHC(fm4,type="HC1"),df = Inf)
```

```{r}
waldtest(fm3,fm4,vcov=vcovHC(fm4,type="HC1"),test="Chisq")
```

## workflow
+ データフレイム作成
+ 回帰モデルを推計
+ 検定を実行


