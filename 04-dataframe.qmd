---
output:
  html_document: default
  html_notebook: default
---
# データ構造
```{r}
#| label: setup
#| include: false
knitr::opts_chunk$set(echo = TRUE,collapse=TRUE)
```

## ベクトル
R では同じ型の値をまとめたものをベクトルと呼ぶ。
ベクトルは `c()`（concatenate の略）を用いて作成し、既存のベクトルを渡すと結合することもできる。
```{r}
(num<-c(2,3,7,9))
(chr <- c("cat","dog","cow"))
```

ベクトルには長さという属性 (attribute) が付く。`length()` で要素数を確認でき、`str()` を使えば型や属性をまとめて把握できる。
```{r}
length(num)
length(chr)
```
ベクトルは R のオブジェクトの基本単位であり、単一の値も「長さ 1 のベクトル」とみなせる。

型が混在している場合は、自動的により表現力の高い型へ強制変換される。おおむね論理値 → 数値 → 文字列の順に変換され、文字列が含まれると全要素が文字列になる。数値と論理値が混ざっている場合は `TRUE` が 1、`FALSE` が 0 に変換される。

```{r}
(x<- c(1,4))
typeof(x)
(y <- c(2,FALSE,"4"))
typeof(y)
(z <- c(2,FALSE))
typeof(z)
```

### ベクトルのアクセス
ベクトルの要素は角括弧 `[]` にインデックスを指定して取り出す。たとえば 3 番目の要素を取得するには次のようにする。
```{r}
num <- c(2,3,7,9)
num[3]
```

ベクトルには名前属性を付与することもできる。
```{r}
vec <- c(x= 3, y =3, z = 4)
vec
names(vec)
```

既存のベクトルに後から名前を設定する場合は次のようにする。
```{r}
names(num) <- letters[1:4]
num
```

名前付きベクトルでは、文字列で要素を参照できる。
```{r}
vec["x"]
num["d"]
```



## リスト
複数のオブジェクト（ベクトルや別のリストなど）をまとめたものがリストである。
型の異なるベクトルでも `list()` に渡すことで 1 つのリストにまとめられる。

リストにも長さという属性があり、`length()` で要素数を確認できる。
```{r}
(lst <- list("a",c(3,3,2)))
typeof(lst)
length(lst)
```

`class()` でオブジェクトのクラスを、`str()` で内部構造を確認できる。
```{r}
class(lst)
str(lst)
```

リストは入れ子にすることもできる。これは単一の型しか持てないベクトルとの大きな違いである。
```{r}
typeof(list("b",lst))
```

リストをベクトルに変換するには `unlist()` を使う。構成要素の型が異なる場合は、ベクトルに変換できるように強制変換が行われる。
```{r}
lst<-list(1:3,2:6)
lst
unlist(lst)
unlist(list("a",1:4))
```
個々の要素の長さを調べたいときは `lengths(lst)` が便利で、各要素に同じ処理を施す場合は `lapply()` や `sapply()` を組み合わせるとよい。

### リストのアクセス
リストの要素も角括弧を用いて参照する。単一の角括弧 `[]` を使うと、要素を取り出してもリストのまま返る。以下は最初の要素（＝ 1 番目のリスト）を取得する例である。

```{r}
lst[1]
```

名前属性を付けたリストであれば、文字列でアクセスできる。
```{r}
(lst <- list(name="a",num=c(3,3,2)))
names(lst)
```

この状態で次のように書けば 2 番目の要素を取り出せる。
```{r}
lst["num"]
```

いずれの場合も `[]` で取り出した結果はリストである点に注意する。
```{r}
typeof(lst[1])
typeof(lst["num"])
```

ベクトルとして取り出したい場合は二重角括弧 `[[ ]]` を使う。これによりリスト要素の中身がそのまま返る。
```{r}
lst[[2]]
typeof(lst[[2]])
```

名前付きの場合は次のように書くこともできる。
```{r}
lst[["num"]]
lst$num
```

リスト内のベクトルに対して関数を適用したいときは、二重括弧か `$` 記法でベクトルを取り出してから利用する。次の例では `$` 記法を使っているが、コメント行で示したように二重括弧を使っても結果は同じである。
```{r}
## mean(lst[[2]])
## mean(lst[["num"]])
mean(lst$num)
```
`with()` を使えば、リスト内の要素を名前だけで参照できる。
```{r}
with(lst, mean(num))
```

リストの要素を削除したいときは、該当要素に `NULL` を代入する。
```{r}
lst$num <- NULL
lst
```




## 因子ベクトル
### factor
文字列ベクトルを `factor()` に渡すと、カテゴリ情報を持つ因子 (factor) ベクトルを作成できる。
```{r}
(x <- c("L","S","M","M","L"))
(x.fac <- factor(x))
```

因子ベクトルの実体は、`levels` という属性を持つ整数ベクトルである。値そのものではなく水準の位置を保持している点に注意する。
```{r}
typeof(x.fac)
length(x.fac)
levels(x.fac)
```

`class()` で因子であることを確認し、`str()` で水準情報などの属性を詳しく確認できる。
```{r}
class(x.fac)
str(x.fac)
```

水準の表示順は既定ではアルファベット順に並ぶが、`levels` 引数を指定すれば任意の順に設定できる。
```{r}
(x.factor <- factor(x,levels=c("S","M","L")))
```

さらに `ordered()` を使うと、水準に大小関係（順序）を持たせた因子を作れる。
```{r}
(x.order <- ordered(x,levels=c("S","M","L")))
```
分析の途中で未使用の水準を落としたいときは `droplevels(x.factor)` を利用する。

### cut
連続値を区間ごとに区分して因子化したい場合は `cut()` を用いる。まず 0 から 10 までの値を乱数で生成する。
```{r}
x <- runif(10,0,10)
x
```

`breaks` に分割数を指定すると、最小値から最大値までを等間隔に区切る。
```{r}
cut(x, breaks=5)
```
これは観測値の最小値から最大値までの区間を 5 等分した結果を返している。

区間境界を自分で指定したい場合は、`breaks` に数値ベクトルを渡す。
```{r}
cut(x,breaks=c(0,2,4,6,8,10))
```
0 より大きく 2 以下、2 より大きく 4 以下、… のように区切られている。

最初の区間に最小値を含めたいときは `include.lowest = TRUE` を指定する。
```{r}
cut(x, breaks=seq(0,10,2),include.lowest=TRUE)
```

区間の右端を含めたくない場合（例: 0 以上 2 未満、2 以上 4 未満、…）は `right = FALSE` を指定する。
```{r}
cut(x, breaks=seq(0,10,2),right=FALSE,include.lowest=TRUE)
```
このときの `include.lowest = TRUE` は最大値を最後の区間に含める指定となる。

水準名をわかりやすいラベルに変えたいときは `labels` 引数で指定する。
```{r}
cut(
  x,
  breaks = seq(0, 10, 2),
  right = FALSE,
  include.lowest = TRUE,
  labels = c("A", "B", "C", "D", "E")
)
```

## 行列
ベクトルに縦横の次元情報を与えることで行列 (matrix) を作成できる。
```{r}
mat <- matrix(1:10, nrow=2,ncol=5)
mat
```
`matrix()` は既定では列方向にデータを埋めていくため、1 列目が 1, 2、2 列目が 3, 4… のように配置される。

`byrow = TRUE` を指定すると、行方向にデータを埋めていく。
```{r}
matrix(1:10, nrow=2,ncol=5,byrow = TRUE)
```

行列は `dim` 属性を持つ数値ベクトルとして表現されている。
```{r}
typeof(mat)
length(mat)
dim(mat)
```

行数・列数は `nrow()`、`ncol()` で取得できる。
```{r}
nrow(mat)
ncol(mat)
```

`class()` や `str()` を使えば、クラス名や内部構造を確認できる。
```{r}
class(mat)
str(mat)
```


### 行列の演算

行方向に結合するには `rbind()` を用いる。
```{r}
mata<-matrix(1:5,nrow=1,ncol=5)
rbind(mat,mata)
```

列方向に結合するには `cbind()` を用いる。
```{r}
matb<-matrix(1:4,nrow=2,ncol=2)
cbind(mat,matb)
```

転置行列は `t()` で得られる。
```{r}
t(mat)
```

`*` 演算子は要素ごとの積を計算する。線形代数で使う行列積を計算したい場合は `%*%` を使う。
```{r}
matb %*% mat
```
このとき、行列の次元（内積をとる側の列数と行数）が一致している必要がある。


列ごとの合計は `colSums()`、行ごとの合計は `rowSums()` が利用できる。
```{r}
colSums(mat)
rowSums(mat)
```
返り値はいずれもベクトルである。行列全体の総和を求める場合は `sum()` を使えばよい。
```{r}
sum(mat)
```

平均値についても同様に `colMeans()`、`rowMeans()` を使える。
```{r}
colMeans(mat)
rowMeans(mat)
```

### 行列のアクセス

行列から行や列を取り出すときも角括弧 `[]` を用いる。次の例では 2 行目を抽出している。
```{r}
mat[2,]
```

このままだとベクトルとして返されるが、`drop = FALSE` を指定すれば行列の形を保ったまま取り出せる。
```{r}
mat[, 3, drop=FALSE]
```

連続した列を取り出す場合は、特に `drop` を指定しなくても行列として返される。
```{r}
mat[,2:3]
```

特定の要素を取り出すには行番号と列番号を指定する。
```{r}
mat[2,3]
```

行・列に名前を付けることもできる。
```{r}
rownames(mat) <- letters[1:2]
colnames(mat) <- 1:5
mat
```

名前を付けると、名前でアクセスできるようになる。
```{r}
mat["a","3"]
```

`dimnames()` を使えば、行名と列名をまとめて設定・上書きできる。
```{r}
dimnames(mat) <- list(LETTERS[1:2],2:6)
mat
```



## データフレイム
同じ長さのベクトルを組み合わせたリストがデータフレイム (data frame) である。
次のように `data.frame()` を使って作成できる。
```{r}
df <- data.frame(x = rnorm(10), y = letters[1:10])
```
ここでは `letters[1:10]` を使って 10 個の小文字アルファベットを列として追加している。
R 4.0 以降は既定で文字列が因子化されないが、古いコードを扱う際は `stringsAsFactors = FALSE` を明示すると安全な場合がある。

データフレイムは大規模になることが多いため、先頭数行だけを確認するには `head()` を使う。
```{r}
head(df)
```

要約統計量を手早く確認したい場合は `summary()` が便利である。
```{r}
summary(df)
```

内部構造や型を調べたいときは `str()` を使う。
```{r}
str(df)
```

データフレイムの実体はリストである。
```{r}
typeof(df)
class(df)
```

そのため、リスト同様に長さや名前の属性を持つ。
```{r}
length(df)
names(df)
```

一方で、行列と同じように次元情報も持っている。
```{r}
dim(df)
ncol(df)
nrow(df)
```
ここで `ncol(df)` は `length(df)` と同じ値を返す。

行列と同じく、行名・列名も持つ。
```{r}
dimnames(df)
colnames(df)
rownames(df)
```
`colnames(df)` と `names(df)` は同一結果になる。

### データフレイムの演算
データフレイムは内部的にはリストだが、数値・論理値のみで構成されている場合には多くの行列演算をそのまま適用できる。

```{r}
rbind(df, c(3, "a"))
```
この例では文字列を含めているため、列全体が文字列に変換される点に注意する。
また `rbind()` では列名が一致している必要があり、行名は自動で連番が振られる（既存の行名と重複すると `make.unique()` により調整される）。

```{r}
cbind(df, z = runif(10))
```
列方向に結合すると列数が増えるため、追加するベクトルの長さが行数と一致しているか確認しておくと安心である。長さが一致しない場合はリサイクル規則が働くか、条件によっては警告・エラーになる。

転置をとると行列として出力される。データフレイムに文字列や因子が含まれている場合、すべて文字列に変換される点に注意する。
```{r}
t(df)
```

構成要素が数値または論理値のみであれば、同じ次元のデータフレイム同士で要素ごとの四則演算が可能となる。ただし、線形代数で使う行列演算を行いたい場合は `as.matrix()` で行列に変換してから計算する必要がある。

同様に、列・行ごとの合計や平均も数値・論理値で構成されていれば利用できる。
```{r}
dff <- data.frame(a = 1:5, b = c(TRUE, TRUE, TRUE, FALSE, FALSE))
colSums(dff)
rowSums(dff)
```
返り値はベクトルである。全要素の合計を求める場合は `sum()` を使えばよい。
```{r}
sum(dff)
```

平均値も同様に計算できる。
```{r}
colMeans(dff)
rowMeans(dff)
```


### データフレイムのアクセス
データフレイムに対して 1 つの角括弧でインデックスを指定すると、常にデータフレイムとして戻ってくる。
```{r}
df["x"]
```
`df[1]` としても同じである。

ベクトルとして取り出したい場合は `$` や二重角括弧を使う。
```{r}
df$x
```
`df[["x"]]`、`df[[1]]`、`df[, "x"]`、`df[, 1]` など、さまざまな書き方が選べる。

変数 `x` の 5 番目の要素を取り出して別の値 `100` を代入するには次のようにする。
```{r}
df$x[5] <- 100
```
同様に `df[["x"]][5]`、`df[[1]][5]`、`df[5, "x"]`、`df[5, 1]` でも操作できる。

データフレイム内の変数に関数を適用する例として、平均値を求める場合を示す。
```{r}
mean(df$x)
```
`with()` を使えば、データフレイムを指定したうえで列名だけで参照することもできる。
```{r}
with(df, mean(x))
```
なお `attach()` によってデータフレイムを検索パスに追加する方法もあるが、意図しない変数の上書きにつながるため現在では推奨されない。

列を削除したい場合は `NULL` を代入する。
```{r}
df$x <- NULL
```
複雑な条件で行や列を抽出したいときは、`subset()` や `dplyr::filter()`／`select()` といった関数を併用すると記述が読みやすくなる。
