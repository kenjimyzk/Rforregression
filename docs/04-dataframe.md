---
output:
  html_document: default
  html_notebook: default
---
# データ構造


## ベクトル
Rでは同じ型の値を集めたものをベクトルという.
ベクトルは `c()` を用いて構成する. 

```r
(num<-c(2,3,7,9))
## [1] 2 3 7 9
(chr <- c("cat","dog","cow"))
## [1] "cat" "dog" "cow"
```

ベクトルには長さという属性 (attribute) が付く.

```r
length(num)
## [1] 4
length(chr)
## [1] 3
```
ベクトルはオブジェクトの基本であり, 一つの値は長さが1のベクトルと考える.

型が同じでない場合, 強制的に同じ型に変換される.
文字列が含まれればすべて文字列になる.
数値と論理値の場合は論理値の `TRUE` が1に `FALSE` が0に変換される.


```r
(x<- c(1,4))
## [1] 1 4
typeof(x)
## [1] "double"
(y <- c(2,FALSE,"4"))
## [1] "2"     "FALSE" "4"
typeof(y)
## [1] "character"
(z <- c(2,FALSE))
## [1] 2 0
typeof(z)
## [1] "double"
```

### ベクトルのアクセス
ベクトルの要素はカギカッコに整数値を代入することで
取り出すせることができる. たとえば3番目のベクトルの要素を取り出すには以下とする.

```r
num <- c(2,3,7,9)
num[3]
## [1] 7
```

また名前の属性をつけてベクトルを構成することがでる.

```r
vec <- c(x= 3, y =3, z = 4)
vec
## x y z 
## 3 3 4
names(vec)
## [1] "x" "y" "z"
```

すでにあるリストの場合, 次のようにしてもよい.

```r
names(num) <- letters[1:4]
num
## a b c d 
## 2 3 7 9
```

いずれに名前の属性をつけると次のようにしてアクセスが可能である.

```r
vec["x"]
## x 
## 3
num["d"]
## d 
## 9
```



## リスト
ベクトルなどを集めたものをリストという.
ベクトル型の違うベクトルを関数 `list` で集める.

リストの属性には長さがある.

```r
(lst <- list("a",c(3,3,2)))
## [[1]]
## [1] "a"
## 
## [[2]]
## [1] 3 3 2
typeof(lst)
## [1] "list"
length(lst)
## [1] 2
```

関数 `class` によってリストがであることが確認でき, `str` で属性を詳しく調べることができる.

```r
class(lst)
## [1] "list"
str(lst)
## List of 2
##  $ : chr "a"
##  $ : num [1:3] 3 3 2
```

リストとベクトルの違いとして, リスト自体もリストとして含められることがある.

```r
typeof(list("b",lst))
## [1] "list"
```

リストベクトルに変換するには `unlist` を用いる.
それぞれの型が違う場合, 同じ型に強制変換される.

```r
lst<-list(1:3,2:6)
lst
## [[1]]
## [1] 1 2 3
## 
## [[2]]
## [1] 2 3 4 5 6
unlist(lst)
## [1] 1 2 3 2 3 4 5 6
unlist(list("a",1:4))
## [1] "a" "1" "2" "3" "4"
```

### リストのアクセス
リストの取りだすには, ベクトルのようにかぎかっこで数値を入力する.
以下は一番目のリストを表示している.


```r
lst[1]
## [[1]]
## [1] 1 2 3
```

また名前の属性をもてば, その名前を入力することで取り出すことができる.
たと次のようにして名前の属性をつけたリストを作る.

```r
(lst <- list(name="a",num=c(3,3,2)))
## $name
## [1] "a"
## 
## $num
## [1] 3 3 2
names(lst)
## [1] "name" "num"
```

その上で以下のようにすれば2番目の要素が取り出せる.

```r
lst["num"]
## $num
## [1] 3 3 2
```

いずれにせよ取り出したののもリストになることに注意されたい.

```r
typeof(lst[1])
## [1] "list"
typeof(lst["num"])
## [1] "list"
```

ベクトルとして取り出すには次のようにする.

```r
lst[[2]]
## [1] 3 3 2
typeof(lst[[2]])
## [1] "double"
```

名前の属性がついていれば以下のようにもできる.

```r
lst[["num"]]
## [1] 3 3 2
lst$num
## [1] 3 3 2
```

リストのなかのあるベクトルの平均値を求めるには次のようにする.

```r
## mean(lst[[2]])
## mean(lst[["num"]])
mean(lst$num)
## [1] 2.666667
```
もしくは以下とする.

```r
with(lst, mean(num))
## [1] 2.666667
```

なおリストの要素を消すには以下のようにする.

```r
lst$num <- NULL
lst
## $name
## [1] "a"
```




## 因子ベクトル
### factor
文字列ベクトルを引数にした関数 `factor`によって 因子 (factor) ベクトルを作成できる.

```r
(x <- c("L","S","M","M","L"))
## [1] "L" "S" "M" "M" "L"
(x.fac <- factor(x))
## [1] L S M M L
## Levels: L M S
```

因子ベクトルの実体は `level` という属性をもつ整数ベクトルである.

```r
typeof(x.fac)
## [1] "integer"
length(x.fac)
## [1] 5
levels(x.fac)
## [1] "L" "M" "S"
```

関数 `class` によって因数ベクトルがであることが確認でき, `str` で属性を詳しく調べることができる.

```r
class(x.fac)
## [1] "factor"
str(x.fac)
##  Factor w/ 3 levels "L","M","S": 1 3 2 2 1
```

また水準の表示順は自動的にアルファベット順になるが, それを変更するには次のようにする.

```r
(x.factor <- factor(x,levels=c("S","M","L")))
## [1] L S M M L
## Levels: S M L
```

この水準に順序構造を付与するには次のようにする.

```r
(x.order <- ordered(x,levels=c("S","M","L")))
## [1] L S M M L
## Levels: S < M < L
```

### cut
また数値を区間ごとに区分した因子ベクトルも作成可能である.
0から10までの値を発生させる.

```r
x <- runif(10,0,10)
x
##  [1] 2.479554 3.951526 7.621578 5.899566 4.972304 1.909368 5.931999 1.612386
##  [9] 2.534325 4.122542
```

5等分するには以下のようにする.

```r
cut(x, breaks=5)
##  [1] (1.61,2.81] (2.81,4.02] (6.42,7.63] (5.22,6.42] (4.02,5.22] (1.61,2.81]
##  [7] (5.22,6.42] (1.61,2.81] (1.61,2.81] (4.02,5.22]
## Levels: (1.61,2.81] (2.81,4.02] (4.02,5.22] (5.22,6.42] (6.42,7.63]
```
これは登場したデータの最大値と最小値の幅を5等分している.

区間を指定するには以下のようにベクトルで指定する.

```r
cut(x,breaks=c(0,2,4,6,8,10))
##  [1] (2,4] (2,4] (6,8] (4,6] (4,6] (0,2] (4,6] (0,2] (2,4] (4,6]
## Levels: (0,2] (2,4] (4,6] (6,8] (8,10]
```
0より大きく2以下, 2より大きく4以下,... となっている.

0も含めるのなら `include.lowest=TRUE` というオプションをつける.

```r
cut(x, breaks=seq(0,10,2),include.lowest=TRUE)
##  [1] (2,4] (2,4] (6,8] (4,6] (4,6] [0,2] (4,6] [0,2] (2,4] (4,6]
## Levels: [0,2] (2,4] (4,6] (6,8] (8,10]
```

またこれを0以上2未満, 2以上4未満, ... とするにはオプション `right=FALSE` をつける.

```r
cut(x, breaks=seq(0,10,2),right=FALSE,include.lowest=TRUE)
##  [1] [2,4) [2,4) [6,8) [4,6) [4,6) [0,2) [4,6) [0,2) [2,4) [4,6)
## Levels: [0,2) [2,4) [4,6) [6,8) [8,10]
```
このとき, `include.lowest=TRUE` は最大値を含めることを意味する.

また因子の名称はオプション `labels` で変更可能である.

```r
cut(x, breaks=seq(0,10,2),right=FALSE,include.lowest=TRUE,
    labels =c("A","B","C","D","E"))
##  [1] B B D C C A C A B C
## Levels: A B C D E
```

## 行列
ベクトルに縦と横の次元を付与することによって行列 (matrix) を作ることができる.

```r
mat <- matrix(1:10, nrow=2,ncol=5)
mat
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    3    5    7    9
## [2,]    2    4    6    8   10
```

またオプション `byrow=TRUE` で横から行列を作成できる.

```r
matrix(1:10, nrow=2,ncol=5,byrow = TRUE)
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    2    3    4    5
## [2,]    6    7    8    9   10
```

この行列の実体は `dim` という属性を持つ数値ベクトルである.

```r
typeof(mat)
## [1] "integer"
length(mat)
## [1] 10
dim(mat)
## [1] 2 5
```

他にもそれぞれの要素の次元は以下で得ることができる.

```r
nrow(mat)
## [1] 2
ncol(mat)
## [1] 5
```

関数 `class` によって因数ベクトルがであることが確認でき, `str` で属性を詳しく調べることができる.

```r
class(mat)
## [1] "matrix" "array"
str(mat)
##  int [1:2, 1:5] 1 2 3 4 5 6 7 8 9 10
```


### 行列の演算

縦での結合は `rbind` を用いる

```r
mata<-matrix(1:5,nrow=1,ncol=5)
rbind(mat,mata)
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    3    5    7    9
## [2,]    2    4    6    8   10
## [3,]    1    2    3    4    5
```

横での結合は `cbind` を用いる

```r
matb<-matrix(1:4,nrow=2,ncol=2)
cbind(mat,matb)
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7]
## [1,]    1    3    5    7    9    1    3
## [2,]    2    4    6    8   10    2    4
```

転置行列は以下のようにすればよい.

```r
t(mat)
##      [,1] [,2]
## [1,]    1    2
## [2,]    3    4
## [3,]    5    6
## [4,]    7    8
## [5,]    9   10
```

通常の `*` は要素ごとの掛け算になる. 
数学で用いられる行列同士の掛け算は `%*%` を実施する.

```r
matb %*% mat
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    7   15   23   31   39
## [2,]   10   22   34   46   58
```
行列のことが一致させる必要がある.


また列ごとの合計, 行ごとの合計は以下を実施する.

```r
colSums(mat)
## [1]  3  7 11 15 19
rowSums(mat)
## [1] 25 30
```
返り値はベクトルになる. 行列のすべての要素を足すには `sum` でよい.

```r
sum(mat)
## [1] 55
```

また列ごとの平均, 行ごとの平均は以下を実施する.

```r
colMeans(mat)
## [1] 1.5 3.5 5.5 7.5 9.5
rowMeans(mat)
## [1] 5 6
```

### 行列のアクセス

行列からベクトルの取り出し以下のようにｓる.

```r
mat[2,]
## [1]  2  4  6  8 10
```

ベクトルのまま取り出されてしまう.
オプション `drop=FALSE` をつけると行列のまま取り出すことができる.

```r
mat[, 3, drop=FALSE]
##      [,1]
## [1,]    5
## [2,]    6
```

2つ同時に取り出すにときは特にオプションをしていしなくても行列として取り出せる.

```r
mat[,2:3]
##      [,1] [,2]
## [1,]    3    5
## [2,]    4    6
```

要素の取り出し

```r
mat[2,3]
## [1] 6
```

行列に名前を付けることができる.

```r
rownames(mat) <- letters[1:2]
colnames(mat) <- 1:5
mat
##   1 2 3 4  5
## a 1 3 5 7  9
## b 2 4 6 8 10
```

これによって以下のようにしてもアクセス可能である.

```r
mat["a","3"]
## [1] 5
```

なお名前は次のようにしてあとから作成することができる.

```r
dimnames(mat) <- list(LETTERS[1:2],2:6)
mat
##   2 3 4 5  6
## A 1 3 5 7  9
## B 2 4 6 8 10
```



## データフレイム
同じ長さのベクトルを組み合わせたリストをデータフレイム (dataframe) という.
データフレイムは次のようにして作られる.

```r
df <- data.frame(x = rnorm(10), y = letters[1:10])
```

データフレイムは大規模なことが多いので最初の数行だけをみるためには `head` をもちいる.

```r
head(df)
##            x y
## 1  1.7880562 a
## 2  0.8082351 b
## 3 -0.6269212 c
## 4  0.3742890 d
## 5 -1.0268179 e
## 6  1.8196534 f
```

データの簡単な統計表は `summary` を使うとよい.

```r
summary(df)
##        x                 y            
##  Min.   :-1.02682   Length:10         
##  1st Qu.:-0.47225   Class :character  
##  Median : 0.05827   Mode  :character  
##  Mean   : 0.26276                     
##  3rd Qu.: 0.75319                     
##  Max.   : 1.81965
```

よりプログラム言語としてのデータ構造を調べるには `str` を使えばよい.

```r
str(df)
## 'data.frame':	10 obs. of  2 variables:
##  $ x: num  1.788 0.808 -0.627 0.374 -1.027 ...
##  $ y: chr  "a" "b" "c" "d" ...
```

データフレイムはリストである.

```r
typeof(df)
## [1] "list"
class(df)
## [1] "data.frame"
```

リストのように長さと名前をもつ.

```r
length(df)
## [1] 2
names(df)
## [1] "x" "y"
```

行列と同じ次元をもつ.

```r
dim(df)
## [1] 10  2
ncol(df)
## [1] 2
nrow(df)
## [1] 10
```
`ncol(df)` は `length(df)` と同じである.

行列と同じ名前をもつ.

```r
dimnames(df)
## [[1]]
##  [1] "1"  "2"  "3"  "4"  "5"  "6"  "7"  "8"  "9"  "10"
## 
## [[2]]
## [1] "x" "y"
colnames(df)
## [1] "x" "y"
rownames(df)
##  [1] "1"  "2"  "3"  "4"  "5"  "6"  "7"  "8"  "9"  "10"
```
`colnames(df)` は `names(df)` と同じである.

### データフレイムの演算
データフレイムは行列でもあるので, 注意があるが
行列での演算がほとんどそのまま利用できる.



```r
rbind(df, c(3,"a"))
##                     x y
## 1    1.78805623434643 a
## 2   0.808235131849285 b
## 3  -0.626921217586097 c
## 4   0.374288973419229 d
## 5   -1.02681786245938 e
## 6    1.81965337030874 f
## 7  -0.314217189626251 g
## 8  -0.257758353693905 h
## 9   0.588045839192727 i
## 10 -0.524931213253026 j
## 11                  3 a
```



```r
cbind(df,z=runif(10))
##             x y          z
## 1   1.7880562 a 0.40040532
## 2   0.8082351 b 0.43983532
## 3  -0.6269212 c 0.88935137
## 4   0.3742890 d 0.27785382
## 5  -1.0268179 e 0.28883361
## 6   1.8196534 f 0.45022890
## 7  -0.3142172 g 0.09274652
## 8  -0.2577584 h 0.65143050
## 9   0.5880458 i 0.00931719
## 10 -0.5249312 j 0.22590903
```

転置行列は行列として出力可能である.
以下のようにデータフレイムに因子ベクトルが含まれていたら全て文字列になる.

```r
t(df)
##   [,1]         [,2]         [,3]         [,4]         [,5]         [,6]        
## x " 1.7880562" " 0.8082351" "-0.6269212" " 0.3742890" "-1.0268179" " 1.8196534"
## y "a"          "b"          "c"          "d"          "e"          "f"         
##   [,7]         [,8]         [,9]         [,10]       
## x "-0.3142172" "-0.2577584" " 0.5880458" "-0.5249312"
## y "g"          "h"          "i"          "j"
```

データフレイムの構成ベクトルがすべて論理値もしくは数値のとき,
同じ行数と列数のデータフレイムの要素ごとの四則演算は可能である.
ただし, 通常の行列演算を実施するには, 行列に変換しなければならない.

また  データフレイムの構成ベクトルがすべて論理値もしくは数値のとき,
列ごとの合計, 行ごとの合計が可能である.

```r
dff<-data.frame(a=1:5,b=c(TRUE, TRUE, TRUE, FALSE,FALSE))
colSums(dff)
##  a  b 
## 15  3
rowSums(dff)
## [1] 2 3 4 4 5
```
返り値はベクトルになる. 行列のすべての要素を足すには `sum` でよい.

```r
sum(dff)
## [1] 18
```

また列ごとの平均, 行ごとの平均は以下を実施する.

```r
colMeans(dff)
##   a   b 
## 3.0 0.6
rowMeans(dff)
## [1] 1.0 1.5 2.0 2.0 2.5
```


### データフレイムのアクセス
データのアクセスとして, ベクトルのように一つのカギカッコで取り出すと以下のようになる.

```r
df["x"]
##             x
## 1   1.7880562
## 2   0.8082351
## 3  -0.6269212
## 4   0.3742890
## 5  -1.0268179
## 6   1.8196534
## 7  -0.3142172
## 8  -0.2577584
## 9   0.5880458
## 10 -0.5249312
```
他にも `df[1]` でもよいが, いずれにせよデータフレイムとして取り出されてしまう.

ベクトルとして取り出すには以下を実施する.

```r
df$x
##  [1]  1.7880562  0.8082351 -0.6269212  0.3742890 -1.0268179  1.8196534
##  [7] -0.3142172 -0.2577584  0.5880458 -0.5249312
```
他にも `df[["x"]], df[[1]], df[,"x"], df[,1]` でもよい.
`
ある変数 $x$ の5番目の要素を取り出して別の値`100`を代入するには以下のようにする.

```r
df$x[5] <- 100
```
他にも `df[["x"]][5], df[[1]][5], df[5,"x"], df[5,1]` でもよい.

データフレイムのある変数の平均値を求めるには次のようにする.

```r
mean(df$x)
## [1] 10.36545
```
もしくは以下とする.

```r
with(df, mean(x))
## [1] 10.36545
```
他にも `attach(df)` を使うやり方もあるが, 現在では推奨されない.

なおリストの要素を消すには以下のようにする.

```r
df$x <- NULL
```

