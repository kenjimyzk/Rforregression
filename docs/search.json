[
  {
    "objectID": "06-datawrangling.html",
    "href": "06-datawrangling.html",
    "title": "7  整然データ",
    "section": "",
    "text": "7.1 データ整形\nまずデータセット mtcars を例に取り、整形の基本操作を確認する。as_tibble() を介して行名を列に移すと、後続の操作が行いやすくなる。\nmtcars_tbl &lt;- mtcars |&gt; \n  as_tibble(rownames = \"model\")\n\nmtcars_tbl |&gt; slice_head(n = 6)\n## # A tibble: 6 × 12\n##   model          mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n##   &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n## 1 Mazda RX4     21       6   160   110  3.9   2.62  16.5     0     1     4     4\n## 2 Mazda RX4 W…  21       6   160   110  3.9   2.88  17.0     0     1     4     4\n## 3 Datsun 710    22.8     4   108    93  3.85  2.32  18.6     1     1     4     1\n## 4 Hornet 4 Dr…  21.4     6   258   110  3.08  3.22  19.4     1     0     3     1\n## 5 Hornet Spor…  18.7     8   360   175  3.15  3.44  17.0     0     0     3     2\n## 6 Valiant       18.1     6   225   105  2.76  3.46  20.2     1     0     3     1\nここでは R 4.1 から導入されたパイプ演算子 |&gt; を利用している。従来の %&gt;% と同様に、左辺の結果を右辺の関数に渡す構文である。\ndplyr を使うとデータフレームの処理が大幅に簡潔になる。 変数の抽出には select() を使う。\nmtcars_tbl |&gt; \n  select(model, mpg, disp) |&gt; \n  slice_head(n = 6)\n## # A tibble: 6 × 3\n##   model               mpg  disp\n##   &lt;chr&gt;             &lt;dbl&gt; &lt;dbl&gt;\n## 1 Mazda RX4          21     160\n## 2 Mazda RX4 Wag      21     160\n## 3 Datsun 710         22.8   108\n## 4 Hornet 4 Drive     21.4   258\n## 5 Hornet Sportabout  18.7   360\n## 6 Valiant            18.1   225\n条件に合致した行だけを抽出したい場合は filter() が便利である。\nmtcars_tbl |&gt; \n  select(model, mpg, disp) |&gt; \n  filter(disp &gt; 300)\n## # A tibble: 11 × 3\n##    model                 mpg  disp\n##    &lt;chr&gt;               &lt;dbl&gt; &lt;dbl&gt;\n##  1 Hornet Sportabout    18.7   360\n##  2 Duster 360           14.3   360\n##  3 Cadillac Fleetwood   10.4   472\n##  4 Lincoln Continental  10.4   460\n##  5 Chrysler Imperial    14.7   440\n##  6 Dodge Challenger     15.5   318\n##  7 AMC Javelin          15.2   304\n##  8 Camaro Z28           13.3   350\n##  9 Pontiac Firebird     19.2   400\n## 10 Ford Pantera L       15.8   351\n## 11 Maserati Bora        15     301\nrename() を使えば変数名を変更できる。日本語の列名にも対応している。\nmtcars_tbl |&gt; \n  select(model, mpg, disp) |&gt; \n  rename(`速度` = mpg, `距離` = disp) |&gt; \n  slice_head(n = 6)\n## # A tibble: 6 × 3\n##   model              速度  距離\n##   &lt;chr&gt;             &lt;dbl&gt; &lt;dbl&gt;\n## 1 Mazda RX4          21     160\n## 2 Mazda RX4 Wag      21     160\n## 3 Datsun 710         22.8   108\n## 4 Hornet 4 Drive     21.4   258\n## 5 Hornet Sportabout  18.7   360\n## 6 Valiant            18.1   225\n並べ替えは arrange() で行う。\nmtcars_tbl |&gt; \n  select(model, mpg, disp) |&gt; \n  arrange(mpg) |&gt; \n  slice_head(n = 6)\n## # A tibble: 6 × 3\n##   model                 mpg  disp\n##   &lt;chr&gt;               &lt;dbl&gt; &lt;dbl&gt;\n## 1 Cadillac Fleetwood   10.4   472\n## 2 Lincoln Continental  10.4   460\n## 3 Camaro Z28           13.3   350\n## 4 Duster 360           14.3   360\n## 5 Chrysler Imperial    14.7   440\n## 6 Maserati Bora        15     301\n降順に並べる場合は desc() と組み合わせる。\nmtcars_tbl |&gt; \n  select(model, mpg, disp) |&gt; \n  arrange(desc(mpg)) |&gt; \n  slice_head(n = 6)\n## # A tibble: 6 × 3\n##   model            mpg  disp\n##   &lt;chr&gt;          &lt;dbl&gt; &lt;dbl&gt;\n## 1 Toyota Corolla  33.9  71.1\n## 2 Fiat 128        32.4  78.7\n## 3 Honda Civic     30.4  75.7\n## 4 Lotus Europa    30.4  95.1\n## 5 Fiat X1-9       27.3  79  \n## 6 Porsche 914-2   26   120.\nmutate() を使うと新しい列を追加できる。\nmtcars_tbl |&gt; \n  mutate(gpm = 1 / mpg) |&gt; \n  select(model, mpg, gpm) |&gt; \n  slice_head(n = 6)\n## # A tibble: 6 × 3\n##   model               mpg    gpm\n##   &lt;chr&gt;             &lt;dbl&gt;  &lt;dbl&gt;\n## 1 Mazda RX4          21   0.0476\n## 2 Mazda RX4 Wag      21   0.0476\n## 3 Datsun 710         22.8 0.0439\n## 4 Hornet 4 Drive     21.4 0.0467\n## 5 Hornet Sportabout  18.7 0.0535\n## 6 Valiant            18.1 0.0552\nmutate() は既存列の上書きや複数列の同時作成も可能で、計算や条件分岐をまとめて記述できる点が強みである。\n次の例では、mpg が 20 を超える場合に TRUE を返すブール列を追加している。\nmtcars_tbl |&gt; \n  mutate(is_high_mileage = mpg &gt; 20) |&gt; \n  select(model, mpg, is_high_mileage) |&gt; \n  slice_head(n = 6)\n## # A tibble: 6 × 3\n##   model               mpg is_high_mileage\n##   &lt;chr&gt;             &lt;dbl&gt; &lt;lgl&gt;          \n## 1 Mazda RX4          21   TRUE           \n## 2 Mazda RX4 Wag      21   TRUE           \n## 3 Datsun 710         22.8 TRUE           \n## 4 Hornet 4 Drive     21.4 TRUE           \n## 5 Hornet Sportabout  18.7 FALSE          \n## 6 Valiant            18.1 FALSE\nsummarise() で基本統計量を算出できる。\nmtcars_tbl |&gt; \n  summarise(avg = mean(mpg), \n            sd  = sd(mpg), \n            .groups = \"drop\")\n## # A tibble: 1 × 2\n##     avg    sd\n##   &lt;dbl&gt; &lt;dbl&gt;\n## 1  20.1  6.03\n列名を任意に付けておけば、後続の処理で指標を参照しやすくなる。\nsummarise() に .by を指定すれば、グループごとの集計も容易である。\nmtcars_tbl |&gt; \n  summarise(\n    n   = n(),\n    avg = mean(mpg),\n    sd  = sd(mpg),\n    .by = cyl\n  )\n## # A tibble: 3 × 4\n##     cyl     n   avg    sd\n##   &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;\n## 1     6     7  19.7  1.45\n## 2     4    11  26.7  4.51\n## 3     8    14  15.1  2.56",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>整然データ</span>"
    ]
  },
  {
    "objectID": "06-datawrangling.html#データ結合",
    "href": "06-datawrangling.html#データ結合",
    "title": "7  整然データ",
    "section": "7.2 データ結合",
    "text": "7.2 データ結合\ndplyr にはデータフレームを縦横方向に結合したり、キーを用いて結合したりするための関数が揃っている。\n縦方向に結合するには bind_rows() を使う。\n\ndf1 &lt;- tibble(X = 1:2, Y = 1:2)\ndf2 &lt;- tibble(X = 4,   Y = 4)\n\nbind_rows(df1, df2)\n## # A tibble: 3 × 2\n##       X     Y\n##   &lt;dbl&gt; &lt;dbl&gt;\n## 1     1     1\n## 2     2     2\n## 3     4     4\n\n列名と型が一致していれば、欠けている列には自動で NA が補われる。\n横方向に結合する場合は bind_cols() を利用する。\n\ndf3 &lt;- tibble(Z = 5:6)\nbind_cols(df1, df3)\n## # A tibble: 2 × 3\n##       X     Y     Z\n##   &lt;int&gt; &lt;int&gt; &lt;int&gt;\n## 1     1     1     5\n## 2     2     2     6\n\n行数が一致していないとリサイクルされるか警告が出るので注意する。\nキーを用いた結合には四種類の join 関数が利用できる。\n\ndfx &lt;- tibble(id = c(\"A\", \"B\", \"C\"), X = 1:3)\ndfy &lt;- tibble(id = c(\"A\", \"B\", \"D\"), Y = c(TRUE, FALSE, TRUE))\n\n左側データ（dfx）の行をすべて保持して結合するには left_join() を用いる。\n\nleft_join(dfx, dfy, by = \"id\")\n## # A tibble: 3 × 3\n##   id        X Y    \n##   &lt;chr&gt; &lt;int&gt; &lt;lgl&gt;\n## 1 A         1 TRUE \n## 2 B         2 FALSE\n## 3 C         3 NA\n\n右側データ（dfy）の行をすべて保持するなら right_join()。\n\nright_join(dfx, dfy, by = \"id\")\n## # A tibble: 3 × 3\n##   id        X Y    \n##   &lt;chr&gt; &lt;int&gt; &lt;lgl&gt;\n## 1 A         1 TRUE \n## 2 B         2 FALSE\n## 3 D        NA TRUE\n\n両方の行をすべて保持するなら full_join()。\n\nfull_join(dfx, dfy, by = \"id\")\n## # A tibble: 4 × 3\n##   id        X Y    \n##   &lt;chr&gt; &lt;int&gt; &lt;lgl&gt;\n## 1 A         1 TRUE \n## 2 B         2 FALSE\n## 3 C         3 NA   \n## 4 D        NA TRUE\n\ninner_join() は共通部分のみを抽出する。\n\ninner_join(dfx, dfy, by = \"id\")\n## # A tibble: 2 × 3\n##   id        X Y    \n##   &lt;chr&gt; &lt;int&gt; &lt;lgl&gt;\n## 1 A         1 TRUE \n## 2 B         2 FALSE\n\n複雑な条件で結合する場合は join_by() を使うと柔軟に定義できる。",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>整然データ</span>"
    ]
  },
  {
    "objectID": "06-datawrangling.html#tidyr",
    "href": "06-datawrangling.html#tidyr",
    "title": "7  整然データ",
    "section": "7.3 tidyr",
    "text": "7.3 tidyr\nここからは tidyr による整形の例を紹介する。まず次のデータセットを用意する。\n\ndf &lt;- tibble(\n  time = 2010:2014,\n  X = rnorm(5, 0, 1),\n  Y = rnorm(5, 0, 2),\n  Z = rnorm(5, 0, 4)\n)\n# `tibble()` なら列の型を意識しつつ手早くサンプル値を用意できる\ndf |&gt; slice_head(n = 6)\n## # A tibble: 5 × 4\n##    time      X      Y      Z\n##   &lt;int&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n## 1  2010 -1.79   0.650 -1.51 \n## 2  2011 -1.07   3.07   1.04 \n## 3  2012  0.214 -1.98  -4.14 \n## 4  2013 -1.30   2.21  -2.19 \n## 5  2014 -0.458  0.318  0.542\n\n列名をキーにして縦長へ変換するときは pivot_longer() を用いる。\n\ndf_long &lt;- df |&gt; \n  pivot_longer(-time, names_to = \"key\", values_to = \"value\")\n# names_to / values_to を指定しておくと後続処理が読みやすい\ndf_long\n## # A tibble: 15 × 3\n##     time key    value\n##    &lt;int&gt; &lt;chr&gt;  &lt;dbl&gt;\n##  1  2010 X     -1.79 \n##  2  2010 Y      0.650\n##  3  2010 Z     -1.51 \n##  4  2011 X     -1.07 \n##  5  2011 Y      3.07 \n##  6  2011 Z      1.04 \n##  7  2012 X      0.214\n##  8  2012 Y     -1.98 \n##  9  2012 Z     -4.14 \n## 10  2013 X     -1.30 \n## 11  2013 Y      2.21 \n## 12  2013 Z     -2.19 \n## 13  2014 X     -0.458\n## 14  2014 Y      0.318\n## 15  2014 Z      0.542\n\npivot_wider() を使えば再び元の構造に戻すことができる。\n\ndf_long |&gt; \n  pivot_wider(names_from = \"key\", values_from = \"value\")\n## # A tibble: 5 × 4\n##    time      X      Y      Z\n##   &lt;int&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n## 1  2010 -1.79   0.650 -1.51 \n## 2  2011 -1.07   3.07   1.04 \n## 3  2012  0.214 -1.98  -4.14 \n## 4  2013 -1.30   2.21  -2.19 \n## 5  2014 -0.458  0.318  0.542\n\n列数を増やして見せたいときや、プレゼン資料で横持ちの表が必要なときに役立つ。\ntime を列方向に展開すれば、年次を横持ちした表へ変換できる。\n\ndf_wide &lt;- df_long |&gt; \n  pivot_wider(names_from = \"time\", values_from = \"value\")\ndf_wide\n## # A tibble: 3 × 6\n##   key   `2010` `2011` `2012` `2013` `2014`\n##   &lt;chr&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n## 1 X     -1.79   -1.07  0.214  -1.30 -0.458\n## 2 Y      0.650   3.07 -1.98    2.21  0.318\n## 3 Z     -1.51    1.04 -4.14   -2.19  0.542\n\n再び縦長に戻す場合は次のとおりである。\n\ndf_wide |&gt; \n  pivot_longer(-key, names_to = \"time\", values_to = \"value\")\n## # A tibble: 15 × 3\n##    key   time   value\n##    &lt;chr&gt; &lt;chr&gt;  &lt;dbl&gt;\n##  1 X     2010  -1.79 \n##  2 X     2011  -1.07 \n##  3 X     2012   0.214\n##  4 X     2013  -1.30 \n##  5 X     2014  -0.458\n##  6 Y     2010   0.650\n##  7 Y     2011   3.07 \n##  8 Y     2012  -1.98 \n##  9 Y     2013   2.21 \n## 10 Y     2014   0.318\n## 11 Z     2010  -1.51 \n## 12 Z     2011   1.04 \n## 13 Z     2012  -4.14 \n## 14 Z     2013  -2.19 \n## 15 Z     2014   0.542\n\npivot_longer() と summarise() を組み合わせると、変数別の記述統計を簡潔にまとめられる。\n\ncars |&gt; \n  as_tibble() |&gt; \n  pivot_longer(everything(), names_to = \"variable\", values_to = \"value\") |&gt; \n  group_by(variable) |&gt;\n  summarise(\n    nobs = n(),\n    avg  = mean(value),\n    sd   = sd(value)\n  ) |&gt;\n  ungroup()\n## # A tibble: 2 × 4\n##   variable  nobs   avg    sd\n##   &lt;chr&gt;    &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;\n## 1 dist        50  43.0 25.8 \n## 2 speed       50  15.4  5.29\n# 欠損を除外したいときは mean(value, na.rm = TRUE) のように na.rm を付ける\n\n日本語の列名でも同じ操作が可能である。\n\ntab &lt;- cars |&gt; \n  as_tibble() |&gt; \n  pivot_longer(c(dist, speed), names_to = \"variable\", values_to = \"value\") |&gt; \n  group_by(variable) |&gt;\n  summarise(\n    nobs = n(),\n    avg  = mean(value),\n    sd   = sd(value)\n  ) |&gt;\n  ungroup() |&gt;\n  mutate(\n    `変数` = dplyr::recode(variable, dist = \"距離\", speed = \"速度\")\n  ) |&gt;\n  select(\n    `変数`,\n    `観測数`   = nobs,\n    `平均`     = avg,\n    `標準偏差` = sd\n  )\ntab |&gt; slice_head(n = 6)\n## # A tibble: 2 × 4\n##   変数  観測数  平均 標準偏差\n##   &lt;chr&gt;  &lt;int&gt; &lt;dbl&gt;    &lt;dbl&gt;\n## 1 距離      50  43.0    25.8 \n## 2 速度      50  15.4     5.29",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>整然データ</span>"
    ]
  },
  {
    "objectID": "06-datawrangling.html#実践例",
    "href": "06-datawrangling.html#実践例",
    "title": "7  整然データ",
    "section": "7.4 実践例",
    "text": "7.4 実践例\ntidyr を用いた別の例を見てみよう。横軸を年としたデータセット df がある。\n\ndf &lt;- tibble(\n  name  = letters,\n  `2010` = rnorm(26),\n  `2011` = rnorm(26),\n  `2012` = rnorm(26)\n) \ndf |&gt; slice_head(n = 6)\n## # A tibble: 6 × 4\n##   name  `2010`  `2011` `2012`\n##   &lt;chr&gt;  &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n## 1 a     -0.676  0.819   0.210\n## 2 b      0.343  0.561  -0.657\n## 3 c     -0.639  1.29    0.105\n## 4 d      0.768  0.0704  1.95 \n## 5 e     -0.606 -1.23    0.233\n## 6 f      3.15  -1.11   -1.22\n\nさらに、年ごとのデータセット df_2010、df_2011、df_2012 の 3 つも用意する。\n\ndf_2010 &lt;- tibble(name = letters, runif = runif(26))\ndf_2011 &lt;- tibble(name = letters, runif = runif(26))\ndf_2012 &lt;- tibble(name = letters, runif = runif(26))\n\nこれら 4 つのデータセットを統合して整然データにする。\nまず df を pivot_longer() で縦長に変換する。\n\ndf_rnorm &lt;- df |&gt; \n  pivot_longer(-name, names_to = \"time\", values_to = \"rnorm\") |&gt; \n  mutate(time = as.numeric(time))\ndf_rnorm |&gt; slice_head(n = 6)\n## # A tibble: 6 × 3\n##   name   time  rnorm\n##   &lt;chr&gt; &lt;dbl&gt;  &lt;dbl&gt;\n## 1 a      2010 -0.676\n## 2 a      2011  0.819\n## 3 a      2012  0.210\n## 4 b      2010  0.343\n## 5 b      2011  0.561\n## 6 b      2012 -0.657\n\nここでは time 列を数値に変換している。\n次に、3 つの年別データセットを bind_rows() で縦に結合する。\n\ndf_runif &lt;- bind_rows(\n  \"2010\" = df_2010,\n  \"2011\" = df_2011,\n  \"2012\" = df_2012,\n  .id    = \"time\"\n) |&gt; \n  mutate(time = as.numeric(time))\ndf_runif |&gt; slice_head(n = 6)\n## # A tibble: 6 × 3\n##    time name  runif\n##   &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n## 1  2010 a     0.751\n## 2  2010 b     0.315\n## 3  2010 c     0.779\n## 4  2010 d     0.132\n## 5  2010 e     0.782\n## 6  2010 f     0.364\n\n.id で追加された列を数値に変換して年情報として利用している。\n最後に full_join() を使って 2 つのデータを結合する。\n\ndf_full &lt;- full_join(df_rnorm, df_runif, by = c(\"name\", \"time\"))\ndf_full |&gt; slice_head(n = 6)\n## # A tibble: 6 × 4\n##   name   time  rnorm runif\n##   &lt;chr&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n## 1 a      2010 -0.676 0.751\n## 2 a      2011  0.819 0.459\n## 3 a      2012  0.210 0.545\n## 4 b      2010  0.343 0.315\n## 5 b      2011  0.561 0.409\n## 6 b      2012 -0.657 0.480\n\n整然データにまとめておけば、ggplot2 やモデリング関数へそのまま渡せるため、後続処理がスムーズになり再現性も高まる。",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>整然データ</span>"
    ]
  },
  {
    "objectID": "10-panel.html",
    "href": "10-panel.html",
    "title": "11  パネル分析",
    "section": "",
    "text": "11.1 データ\nパネル分析に必要なパッケージを読み込み, データセットを準備する. library(AER) コマンドで AER パッケージを, library(plm) コマンドで plm パッケージを読み込む. 次に data(\"Grunfeld\", package = \"plm\") コマンドで Grunfeld データセットを読み込む. Grunfeld データは企業の投資, 企業価値, 資本ストックに関するパネルデータである. head(Grunfeld) コマンドでデータの最初の数行を表示する.\nlibrary(AER)\nlibrary(plm)\ndata(\"Grunfeld\", package = \"plm\")\nhead(Grunfeld)\n##   firm year   inv  value capital\n## 1    1 1935 317.6 3078.5     2.8\n## 2    1 1936 391.8 4661.7    52.6\n## 3    1 1937 410.6 5387.1   156.9\n## 4    1 1938 257.7 2792.2   209.2\n## 5    1 1939 330.8 4313.2   203.4\n## 6    1 1940 461.2 4643.9   207.2\n次にパネルデータとして扱うために, pdata.frame() 関数を使用する. pdata.frame(Grunfeld, index = c(\"firm\", \"year\")) コマンドで, firm (企業) と year (年) をインデックスとしてパネルデータフレームを作成し, pdata に格納する. pdim(pdata) コマンドでパネルデータの次元 (企業数, 時間数, 総観測数) を確認する.\npdata &lt;- pdata.frame(Grunfeld, index = c(\"firm\", \"year\"))\npdim(pdata)\n## Balanced Panel: n = 10, T = 20, N = 200",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>パネル分析</span>"
    ]
  },
  {
    "objectID": "10-panel.html#プーリングols",
    "href": "10-panel.html#プーリングols",
    "title": "11  パネル分析",
    "section": "11.2 プーリングOLS",
    "text": "11.2 プーリングOLS\n次の重回帰モデルを考える.\n\\[\ninv_{it} = \\beta_0 + \\beta_1 value_{it} + \\beta_2 capital_{it} + u_{it}\n\\]\n誤差項 \\(u_{it}\\) は \\(i\\) についても \\(t\\) についても独立同一分布と仮定する. さらに誤差項は説明変数と独立である. この時、パネルデータにおいてもOLS推定法でパラメータは不偏である. ここでの重回帰モデルをプーリングOLSモデルと呼ぶことにする.\nプーリングOLS推定を実行するには, plm() 関数で model = \"pooling\" を指定する. plm(inv ~ value + capital, data = pdata, model = \"pooling\") コマンドで, inv を被説明変数, value と capital を説明変数としてプーリングOLS推定を行い, 結果を gp に格納する. summary(gp) コマンドで推定結果の詳細を表示する.\n\ngp &lt;- plm(inv ~ value + capital, data = pdata, model = \"pooling\")\nsummary(gp)\n## Pooling Model\n## \n## Call:\n## plm(formula = inv ~ value + capital, data = pdata, model = \"pooling\")\n## \n## Balanced Panel: n = 10, T = 20, N = 200\n## \n## Residuals:\n##      Min.   1st Qu.    Median   3rd Qu.      Max. \n## -291.6757  -30.0137    5.3033   34.8293  369.4464 \n## \n## Coefficients:\n##                Estimate  Std. Error t-value  Pr(&gt;|t|)    \n## (Intercept) -42.7143694   9.5116760 -4.4907 1.207e-05 ***\n## value         0.1155622   0.0058357 19.8026 &lt; 2.2e-16 ***\n## capital       0.2306785   0.0254758  9.0548 &lt; 2.2e-16 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Total Sum of Squares:    9359900\n## Residual Sum of Squares: 1755900\n## R-Squared:      0.81241\n## Adj. R-Squared: 0.8105\n## F-statistic: 426.576 on 2 and 197 DF, p-value: &lt; 2.22e-16\n\nこのプーリングOLS推定は, 通常の lm() 関数を使った回帰分析と同じ結果を得る. lm(inv ~ value + capital, data = pdata) コマンドで通常のOLS推定を行い, summary() コマンドで結果を表示すると, 上記の plm() による結果と同一であることが確認できる.\n\nsummary(lm(inv ~ value + capital, data = pdata))\n## \n## Call:\n## lm(formula = inv ~ value + capital, data = pdata)\n## \n## Residuals:\n##     Min      1Q  Median      3Q     Max \n## -291.68  -30.01    5.30   34.83  369.45 \n## \n## Coefficients:\n##               Estimate Std. Error t value Pr(&gt;|t|)    \n## (Intercept) -42.714369   9.511676  -4.491 1.21e-05 ***\n## value         0.115562   0.005836  19.803  &lt; 2e-16 ***\n## capital       0.230678   0.025476   9.055  &lt; 2e-16 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Residual standard error: 94.41 on 197 degrees of freedom\n## Multiple R-squared:  0.8124, Adjusted R-squared:  0.8105 \n## F-statistic: 426.6 on 2 and 197 DF,  p-value: &lt; 2.2e-16",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>パネル分析</span>"
    ]
  },
  {
    "objectID": "10-panel.html#固定効果-平均差分法",
    "href": "10-panel.html#固定効果-平均差分法",
    "title": "11  パネル分析",
    "section": "11.3 固定効果 (平均差分法)",
    "text": "11.3 固定効果 (平均差分法)\n次の重回帰モデルを考える. \\[\ninv_{it} = \\beta_1 value_{it} + \\beta_2 capital_{it} +\\alpha_i + u_{it}\n\\] この \\(\\alpha_i\\) は個別固定効果と呼ばれている. \\(\\alpha_i\\) は時間 \\(t\\) に対して一定である. \\(\\alpha_i\\) は誤差項と相関があるもしれない. この個別固定効果を持つ重回帰モデルを固定効果モデルと呼ぶことにする.\nそれぞれの時間平均をとれば以下になる. \\[\n\\bar{inv}_{i} = \\beta_1 \\bar{value}_{i} + \\beta_2 \\bar{capital}_{i} +\\alpha_i  + \\bar{u}_{i}\n\\]\nそして，それぞれの観測値を時間平均で差し引けば以下のように \\(\\alpha_i\\) は消去される. \\[\ninv_{it}-\\overline{inv}_{i} = \\beta_1 (value_{it}-\\overline{value}_{i}) + \\beta_2 (capital_{it}-\\overline{capital}_{i})  + \\bar{u}_{i} -\\bar{u}_{i}\n\\] このように変換して回帰分析すれば \\(\\alpha_i\\) は誤差項と相関があっても一致推定量である. このような推定方法を平均差分法という.\n固定効果モデルを平均差分法で推定するには, plm() 関数で model = \"within\" を指定する. plm(inv ~ value + capital, data = pdata, model = \"within\") コマンドで固定効果推定を行い, 結果を gi に格納する. summary(gi) コマンドで推定結果の詳細を表示する.\n\ngi &lt;- plm(inv ~ value + capital, data = pdata, model = \"within\")\nsummary(gi)\n## Oneway (individual) effect Within Model\n## \n## Call:\n## plm(formula = inv ~ value + capital, data = pdata, model = \"within\")\n## \n## Balanced Panel: n = 10, T = 20, N = 200\n## \n## Residuals:\n##       Min.    1st Qu.     Median    3rd Qu.       Max. \n## -184.00857  -17.64316    0.56337   19.19222  250.70974 \n## \n## Coefficients:\n##         Estimate Std. Error t-value  Pr(&gt;|t|)    \n## value   0.110124   0.011857  9.2879 &lt; 2.2e-16 ***\n## capital 0.310065   0.017355 17.8666 &lt; 2.2e-16 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Total Sum of Squares:    2244400\n## Residual Sum of Squares: 523480\n## R-Squared:      0.76676\n## Adj. R-Squared: 0.75311\n## F-statistic: 309.014 on 2 and 188 DF, p-value: &lt; 2.22e-16\n\n推定された個別固定効果 \\(\\alpha_i\\) の値を確認するには, fixef() 関数を使用する. fixef(gi) コマンドで各企業の固定効果の推定値を表示する.\n\nfixef(gi)\n##         1         2         3         4         5         6         7         8 \n##  -70.2967  101.9058 -235.5718  -27.8093 -114.6168  -23.1613  -66.5535  -57.5457 \n##         9        10 \n##  -87.2223   -6.5678\n\nこの固定効果推定は, lm() 関数で企業ダミーを含めた回帰分析と同等である. lm(inv ~ value + capital+0+factor(firm), data = pdata) コマンドで, 定数項を除外 (+0) し企業ダミー (factor(firm)) を含めた推定を行い, summary() コマンドで結果を表示する. 係数の推定値は同じであるが, 決定係数が大きく異なっていることに注意されたい.\n\nsummary(lm(inv ~ value + capital+0+factor(firm), data = pdata))\n## \n## Call:\n## lm(formula = inv ~ value + capital + 0 + factor(firm), data = pdata)\n## \n## Residuals:\n##      Min       1Q   Median       3Q      Max \n## -184.009  -17.643    0.563   19.192  250.710 \n## \n## Coefficients:\n##                  Estimate Std. Error t value Pr(&gt;|t|)    \n## value             0.11012    0.01186   9.288  &lt; 2e-16 ***\n## capital           0.31007    0.01735  17.867  &lt; 2e-16 ***\n## factor(firm)1   -70.29672   49.70796  -1.414   0.1590    \n## factor(firm)2   101.90581   24.93832   4.086 6.49e-05 ***\n## factor(firm)3  -235.57184   24.43162  -9.642  &lt; 2e-16 ***\n## factor(firm)4   -27.80929   14.07775  -1.975   0.0497 *  \n## factor(firm)5  -114.61681   14.16543  -8.091 7.14e-14 ***\n## factor(firm)6   -23.16130   12.66874  -1.828   0.0691 .  \n## factor(firm)7   -66.55347   12.84297  -5.182 5.63e-07 ***\n## factor(firm)8   -57.54566   13.99315  -4.112 5.85e-05 ***\n## factor(firm)9   -87.22227   12.89189  -6.766 1.63e-10 ***\n## factor(firm)10   -6.56784   11.82689  -0.555   0.5793    \n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Residual standard error: 52.77 on 188 degrees of freedom\n## Multiple R-squared:  0.9616, Adjusted R-squared:  0.9591 \n## F-statistic:   392 on 12 and 188 DF,  p-value: &lt; 2.2e-16\n\n個別固定効果が統計的に有効かどうか (すなわち, 固定効果モデルとプーリングOLSモデルのどちらが適切か) を検定するには, F検定を実施する. pFtest(gi,gp) コマンドで, 固定効果モデル (gi) とプーリングOLSモデル (gp) を比較するF検定を実行する.\n\npFtest(gi,gp)\n## \n##  F test for individual effects\n## \n## data:  inv ~ value + capital\n## F = 49.177, df1 = 9, df2 = 188, p-value &lt; 2.2e-16\n## alternative hypothesis: significant effects\n\n\n11.3.1 時間効果モデル\n次のモデルを考える. \\[\ninv_{it} = \\beta_1 value_{it} + \\beta_2 capital_{it}+ \\gamma_t +\\alpha_i + u_{it}\n\\] この \\(\\gamma_t\\) は時間固定効果と呼ばれている. ここでは個別固定効果と時間固定効果の2つの固定効果を持つ重回帰モデルを時間効果モデルと呼ぶことにする.\n時間効果モデルを推定するには, plm() 関数で effect=\"twoways\" と model = \"within\" を指定する. plm(inv ~ value + capital, data = pdata, effect=\"twoways\", model = \"within\") コマンドで, 個別固定効果と時間固定効果の両方を含むモデルを推定し, 結果を gi2 に格納する. summary(gi2) コマンドで推定結果の詳細を表示する.\n\ngi2 &lt;- plm(inv ~ value + capital, data = pdata, effect=\"twoways\",model = \"within\")\nsummary(gi2)\n## Twoways effects Within Model\n## \n## Call:\n## plm(formula = inv ~ value + capital, data = pdata, effect = \"twoways\", \n##     model = \"within\")\n## \n## Balanced Panel: n = 10, T = 20, N = 200\n## \n## Residuals:\n##      Min.   1st Qu.    Median   3rd Qu.      Max. \n## -162.6094  -19.4710   -1.2669   19.1277  211.8420 \n## \n## Coefficients:\n##         Estimate Std. Error t-value  Pr(&gt;|t|)    \n## value   0.117716   0.013751  8.5604 6.653e-15 ***\n## capital 0.357916   0.022719 15.7540 &lt; 2.2e-16 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Total Sum of Squares:    1615600\n## Residual Sum of Squares: 452150\n## R-Squared:      0.72015\n## Adj. R-Squared: 0.67047\n## F-statistic: 217.442 on 2 and 169 DF, p-value: &lt; 2.22e-16\n\n推定された個別固定効果と時間固定効果をそれぞれ確認するには, fixef() 関数で effect 引数を指定する. fixef(gi2, effect = \"individual\") コマンドで各企業の固定効果を, fixef(gi2, effect = \"time\") コマンドで各年の固定効果を表示する.\n\nfixef(gi2, effect = \"individual\")\n##         1         2         3         4         5         6         7         8 \n##  -86.9002  120.1540 -222.1310    8.4536  -92.3388   15.9884  -35.4336  -19.4097 \n##         9        10 \n##  -56.6827   39.9369\nfixef(gi2, effect = \"time\")\n##    1935    1936    1937    1938    1939    1940    1941    1942    1943    1944 \n##  -86.90 -106.10 -127.59 -126.13 -156.37 -131.14 -105.70 -108.04 -129.88 -130.00 \n##    1945    1946    1947    1948    1949    1950    1951    1952    1953    1954 \n## -142.58 -118.07 -126.29 -130.62 -160.40 -162.80 -149.38 -151.53 -154.62 -180.43\n\nこの時間効果モデルの推定は, lm() 関数で企業ダミーと年ダミーの両方を含めた回帰分析と同等である. lm(inv ~ value + capital+0+factor(firm)+factor(year), data = pdata) コマンドで, 定数項を除外し企業ダミーと年ダミーを含めた推定を行い, summary() コマンドで結果を表示する. 係数の推定値は同じであるが, 決定係数が大きく異なっていることに注意されたい.\n\nsummary(lm(inv ~ value + capital+0+factor(firm)+factor(year), data = pdata))\n## \n## Call:\n## lm(formula = inv ~ value + capital + 0 + factor(firm) + factor(year), \n##     data = pdata)\n## \n## Residuals:\n##      Min       1Q   Median       3Q      Max \n## -162.609  -19.471   -1.267   19.128  211.842 \n## \n## Coefficients:\n##                    Estimate Std. Error t value Pr(&gt;|t|)    \n## value               0.11772    0.01375   8.560 6.65e-15 ***\n## capital             0.35792    0.02272  15.754  &lt; 2e-16 ***\n## factor(firm)1     -86.90023   56.04663  -1.550 0.122893    \n## factor(firm)2     120.15401   29.16688   4.120 5.93e-05 ***\n## factor(firm)3    -222.13103   28.59744  -7.768 7.37e-13 ***\n## factor(firm)4       8.45361   20.41784   0.414 0.679377    \n## factor(firm)5     -92.33883   20.91106  -4.416 1.79e-05 ***\n## factor(firm)6      15.98841   19.88487   0.804 0.422498    \n## factor(firm)7     -35.43362   20.17003  -1.757 0.080772 .  \n## factor(firm)8     -19.40972   20.49076  -0.947 0.344868    \n## factor(firm)9     -56.68267   19.81211  -2.861 0.004756 ** \n## factor(firm)10     39.93689   20.40337   1.957 0.051951 .  \n## factor(year)1936  -19.19741   23.67586  -0.811 0.418596    \n## factor(year)1937  -40.69001   24.69541  -1.648 0.101277    \n## factor(year)1938  -39.22640   23.23594  -1.688 0.093221 .  \n## factor(year)1939  -69.47029   23.65607  -2.937 0.003780 ** \n## factor(year)1940  -44.23508   23.80979  -1.858 0.064930 .  \n## factor(year)1941  -18.80446   23.69400  -0.794 0.428519    \n## factor(year)1942  -21.13979   23.38163  -0.904 0.367219    \n## factor(year)1943  -42.97762   23.55287  -1.825 0.069808 .  \n## factor(year)1944  -43.09877   23.61020  -1.825 0.069701 .  \n## factor(year)1945  -55.68304   23.89562  -2.330 0.020974 *  \n## factor(year)1946  -31.16928   24.11598  -1.292 0.197957    \n## factor(year)1947  -39.39224   23.78368  -1.656 0.099522 .  \n## factor(year)1948  -43.71651   23.96965  -1.824 0.069945 .  \n## factor(year)1949  -73.49510   24.18292  -3.039 0.002750 ** \n## factor(year)1950  -75.89611   24.34553  -3.117 0.002144 ** \n## factor(year)1951  -62.48091   24.86425  -2.513 0.012911 *  \n## factor(year)1952  -64.63234   25.34950  -2.550 0.011672 *  \n## factor(year)1953  -67.71797   26.61108  -2.545 0.011832 *  \n## factor(year)1954  -93.52622   27.10786  -3.450 0.000708 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Residual standard error: 51.72 on 169 degrees of freedom\n## Multiple R-squared:  0.9668, Adjusted R-squared:  0.9607 \n## F-statistic: 158.8 on 31 and 169 DF,  p-value: &lt; 2.2e-16\n\n時間固定効果が統計的に有効かどうか (すなわち, 時間効果モデルと個別固定効果のみのモデルのどちらが適切か) を検定するには, F検定を実施する. pFtest(gi2, gi) コマンドで, 時間効果モデル (gi2) と個別固定効果のみのモデル (gi) を比較するF検定を実行する.\n\npFtest(gi2, gi)\n## \n##  F test for twoways effects\n## \n## data:  inv ~ value + capital\n## F = 1.4032, df1 = 19, df2 = 169, p-value = 0.1309\n## alternative hypothesis: significant effects",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>パネル分析</span>"
    ]
  },
  {
    "objectID": "10-panel.html#固定効果-一階差分法",
    "href": "10-panel.html#固定効果-一階差分法",
    "title": "11  パネル分析",
    "section": "11.4 固定効果 (一階差分法)",
    "text": "11.4 固定効果 (一階差分法)\n次のモデルを考える. \\[\ninv_{it} = \\beta_1 value_{it} + \\beta_2 capital_{it} +\\alpha_i + u_{it}\n\\] この \\(\\alpha_i\\) は固定効果と呼ばれている. \\(\\alpha_i\\) は時間 \\(t\\) に対して一定である. \\(\\alpha_i\\) は誤差項と相関があるもしれない.\nそれぞれの階差をとれば \\(\\alpha_i\\) は消去できる. \\[\n\\Delta inv_{it} = \\beta_1 \\Delta value_{it} + \\beta_2 \\Delta capital_{it} + \\Delta u_{it}\n\\]\nこのように変換して回帰分析すれば \\(\\alpha_i\\) は誤差項と相関があっても一致推定量である.\n一階差分法による固定効果推定を実行するには, plm() 関数で model = \"fd\" を指定する. plm(inv ~ value + capital+0, data = pdata, model = \"fd\") コマンドで, 定数項を除外 (+0) して一階差分推定を行い, 結果を gf に格納する. summary(gf) コマンドで推定結果の詳細を表示する.\n\ngf &lt;- plm(inv ~ value + capital+0, data = pdata, model = \"fd\")\nsummary(gf)\n## Oneway (individual) effect First-Difference Model\n## \n## Call:\n## plm(formula = inv ~ value + capital + 0, data = pdata, model = \"fd\")\n## \n## Balanced Panel: n = 10, T = 20, N = 200\n## Observations used in estimation: 190\n## \n## Residuals:\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n## -202.05  -15.23   -1.76   -1.39    7.95  199.27 \n## \n## Coefficients:\n##          Estimate Std. Error t-value  Pr(&gt;|t|)    \n## value   0.0890628  0.0082341  10.816 &lt; 2.2e-16 ***\n## capital 0.2786940  0.0471564   5.910  1.58e-08 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Total Sum of Squares:    584410\n## Residual Sum of Squares: 345940\n## R-Squared:      0.40876\n## Adj. R-Squared: 0.40561\n## F-statistic: 70.5784 on 2 and 188 DF, p-value: &lt; 2.22e-16\n\n時間固定効果を含む一階差分モデルを推定する場合は, 年ダミーを追加する. plm(inv ~ value + capital+0+factor(year), data = pdata, model = \"fd\") コマンドで, 年ダミー (factor(year)) を含む一階差分推定を行い, 結果を gf2 に格納する. summary(gf2) コマンドで推定結果の詳細を表示する.\n\ngf2 &lt;-plm(inv ~ value + capital+0+factor(year), data = pdata, model = \"fd\")\nsummary(gf2)\n## Oneway (individual) effect First-Difference Model\n## \n## Call:\n## plm(formula = inv ~ value + capital + 0 + factor(year), data = pdata, \n##     model = \"fd\")\n## \n## Balanced Panel: n = 10, T = 20, N = 200\n## Observations used in estimation: 190\n## \n## Residuals:\n##       Min.    1st Qu.     Median    3rd Qu.       Max. \n## -179.69353  -18.68501    0.49555   14.27860  179.03692 \n## \n## Coefficients: (1 dropped because of singularities)\n##                    Estimate Std. Error t-value  Pr(&gt;|t|)    \n## value             0.0875445  0.0095107  9.2048 &lt; 2.2e-16 ***\n## capital           0.3246777  0.0571472  5.6814 5.727e-08 ***\n## factor(year)1935 52.1173697 67.1610018  0.7760   0.43883    \n## factor(year)1936 44.5420725 65.0001486  0.6853   0.49412    \n## factor(year)1937 32.2308400 62.5656219  0.5152   0.60712    \n## factor(year)1938 19.6675926 60.6802571  0.3241   0.74625    \n## factor(year)1939 -3.0067716 58.4729853 -0.0514   0.95905    \n## factor(year)1940 23.9596588 56.8175845  0.4217   0.67378    \n## factor(year)1941 48.5989734 54.8059164  0.8867   0.37648    \n## factor(year)1942 40.9122279 52.7118790  0.7761   0.43875    \n## factor(year)1943 22.8491024 50.5894648  0.4517   0.65209    \n## factor(year)1944 23.6577035 48.8480758  0.4843   0.62879    \n## factor(year)1945 14.7036587 46.6708001  0.3151   0.75311    \n## factor(year)1946 41.6241613 44.2490709  0.9407   0.34821    \n## factor(year)1947 27.5209677 40.4024259  0.6812   0.49670    \n## factor(year)1948 23.6476936 37.0841079  0.6377   0.52455    \n## factor(year)1949 -4.3351290 33.6481639 -0.1288   0.89764    \n## factor(year)1950 -4.2709916 30.2836724 -0.1410   0.88801    \n## factor(year)1951 16.8493484 26.2244634  0.6425   0.52142    \n## factor(year)1952 18.0590591 20.8995024  0.8641   0.38876    \n## factor(year)1953 24.3453549 13.9307034  1.7476   0.08235 .  \n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Total Sum of Squares:    584410\n## Residual Sum of Squares: 293000\n## R-Squared:      0.49864\n## Adj. R-Squared: 0.4393\n## F-statistic: 8.5881 on 21 and 169 DF, p-value: &lt; 2.22e-16\n\n時間固定効果が統計的に有効かどうかを検定するには, F検定を実施する. pFtest(gf2,gf) コマンドで, 時間効果を含むモデル (gf2) と含まないモデル (gf) を比較するF検定を実行する.\n\npFtest(gf2,gf)\n## \n##  F test for individual effects\n## \n## data:  inv ~ value + capital + 0 + factor(year)\n## F = 1.607, df1 = 19, df2 = 169, p-value = 0.05928\n## alternative hypothesis: significant effects\n\n\n11.4.1 平均差分法と一階差分法\n平均差分法と一階差分法は誤差項の仮定をどのようにおくかによって変わってくる. 誤差項の階差をとることによって時間を通じて無相関になるなら一階差分法が望ましいであろう. しかしながら, 固定効果, 時間効果の値がきちんと計算して, それが経済学的解釈が可能なら, 平均差分法が望ましい. さらに他のプーリングOLSの仮定と変量効果モデルとの比較の意味でも平均差分法がよく使われる.\nなお時間が2期間のパネルデータのとき, 平均差分法も一階差分法も計算値は同じである. たとえば \\(t=2\\)のときの変数 \\(x_{it}\\) の平均差分値は \\[\nx_{2t}-\\bar{x}_i=x_{2t}-\\frac{x_{i1}+x_{i2}}{2}=\\frac{x_{i2}-x_{i1}}{2}\n\\] となる.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>パネル分析</span>"
    ]
  },
  {
    "objectID": "10-panel.html#変量効果",
    "href": "10-panel.html#変量効果",
    "title": "11  パネル分析",
    "section": "11.5 変量効果",
    "text": "11.5 変量効果\n次のモデルを考える. \\[\ninv_{it} = \\beta_1 value_{it} + \\beta_2 capital_{it} +\\alpha_i + u_{it}\n\\] この \\(\\alpha_i\\) は時間 \\(t\\) について一定であるが, \\(i\\) について独立同一分布の確率変数にしたがう. さらに \\(\\alpha_i\\) は説明変数と無相関である時, この \\(\\alpha_i\\) は個別変量効果と呼ばれている. 個別固定効果は説明変数と無相関を仮定していない. この個別変量効果を持つ重回帰モデルを変量効果モデルと呼ぶことにする.\n変量効果モデルを推定するには, plm() 関数で model = \"random\" を指定する. plm(inv ~ value + capital, data = pdata, model = \"random\") コマンドで変量効果推定を行い, 結果を gr に格納する. summary(gr) コマンドで推定結果の詳細を表示する.\n\ngr &lt;- plm(inv ~ value + capital, data = pdata, model = \"random\")\nsummary(gr)\n## Oneway (individual) effect Random Effect Model \n##    (Swamy-Arora's transformation)\n## \n## Call:\n## plm(formula = inv ~ value + capital, data = pdata, model = \"random\")\n## \n## Balanced Panel: n = 10, T = 20, N = 200\n## \n## Effects:\n##                   var std.dev share\n## idiosyncratic 2784.46   52.77 0.282\n## individual    7089.80   84.20 0.718\n## theta: 0.8612\n## \n## Residuals:\n##      Min.   1st Qu.    Median   3rd Qu.      Max. \n## -177.6063  -19.7350    4.6851   19.5105  252.8743 \n## \n## Coefficients:\n##               Estimate Std. Error z-value Pr(&gt;|z|)    \n## (Intercept) -57.834415  28.898935 -2.0013  0.04536 *  \n## value         0.109781   0.010493 10.4627  &lt; 2e-16 ***\n## capital       0.308113   0.017180 17.9339  &lt; 2e-16 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Total Sum of Squares:    2381400\n## Residual Sum of Squares: 548900\n## R-Squared:      0.7695\n## Adj. R-Squared: 0.76716\n## Chisq: 657.674 on 2 DF, p-value: &lt; 2.22e-16\n\n推定された変量効果の値を確認するには, ranef() 関数を使用する. ranef(gr) コマンドで各企業の変量効果の推定値を表示する.\n\nranef(gr)\n##            1            2            3            4            5            6 \n##   -9.5242955  157.8910235 -172.8958044   29.9119801  -54.6790089   34.3461316 \n##            7            8            9           10 \n##   -7.8977584    0.6726376  -28.1393497   50.3144442\n\n\n11.5.1 ハウスマン検定\n帰無仮説が変量効果モデル, 対立仮説が固定効果モデルの検定はハウスマン検定を実施する. ハウスマン検定では, 変量効果モデルと固定効果モデルの係数の差が統計的に有意かどうかを検定する. phtest(gi,gr) コマンドで, 固定効果モデル (gi) と変量効果モデル (gr) のハウスマン検定を実行する.\n\nphtest(gi,gr)\n## \n##  Hausman Test\n## \n## data:  inv ~ value + capital\n## chisq = 2.3304, df = 2, p-value = 0.3119\n## alternative hypothesis: one model is inconsistent",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>パネル分析</span>"
    ]
  },
  {
    "objectID": "10-panel.html#クラスターロバスト分散",
    "href": "10-panel.html#クラスターロバスト分散",
    "title": "11  パネル分析",
    "section": "11.6 クラスターロバスト分散",
    "text": "11.6 クラスターロバスト分散\n固定効果モデルにおいて, 分散不均一が疑われる場合, クラスターロバスト分散を用いる. 時間効果がない固定効果モデル (gi) について, クラスターロバスト標準誤差を計算するには, coeftest() 関数と vcovHC() 関数を組み合わせて使用する. coeftest(gi, vcov=vcovHC(gi, type=\"sss\")) コマンドで, type=\"sss\" を指定したクラスターロバスト分散を用いた係数検定を実行する.\n\ncoeftest(gi,vcov=vcovHC(gi,type=\"sss\"))\n## \n## t test of coefficients:\n## \n##         Estimate Std. Error t value  Pr(&gt;|t|)    \n## value   0.110124   0.015156  7.2660 9.596e-12 ***\n## capital 0.310065   0.052618  5.8927 1.726e-08 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n時間効果モデル (gi2) についても同様に, クラスターロバスト標準誤差を計算できる. coeftest(gi2, vcov=vcovHC(gi2, type=\"sss\")) コマンドで, 時間効果モデルにおけるクラスターロバスト分散を用いた係数検定を実行する.\n\ncoeftest(gi2,vcov=vcovHC(gi2,type=\"sss\"))\n## \n## t test of coefficients:\n## \n##         Estimate Std. Error t value  Pr(&gt;|t|)    \n## value   0.117716   0.010263 11.4697 &lt; 2.2e-16 ***\n## capital 0.357916   0.045367  7.8893  3.62e-13 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nSTATA の計算結果に合わせるには, 個別固定効果モデルに年ダミーを明示的に追加する必要がある. update(gi, .~. + factor(year)) コマンドで, モデル gi に年ダミーを追加して更新し, git に格納する. その後 coeftest(git, vcov=vcovHC(git, type=\"sss\")) コマンドで, クラスターロバスト分散を用いた係数検定を実行する. gi2 と git のどちらを採用するかによって結果が変わってしまうので注意されたい.\n\ngit &lt;- update(gi, .~. + factor(year))\ncoeftest(git,vcov=vcovHC(git,type=\"sss\"))\n## \n## t test of coefficients:\n## \n##                    Estimate Std. Error t value  Pr(&gt;|t|)    \n## value              0.117716   0.010794 10.9055 &lt; 2.2e-16 ***\n## capital            0.357916   0.047715  7.5012 3.424e-12 ***\n## factor(year)1936 -19.197405  20.640669 -0.9301 0.3536580    \n## factor(year)1937 -40.690009  33.190087 -1.2260 0.2219160    \n## factor(year)1938 -39.226404  15.692472 -2.4997 0.0133837 *  \n## factor(year)1939 -69.470288  26.923231 -2.5803 0.0107211 *  \n## factor(year)1940 -44.235085  17.323706 -2.5534 0.0115505 *  \n## factor(year)1941 -18.804463  17.797543 -1.0566 0.2922130    \n## factor(year)1942 -21.139792  14.125147 -1.4966 0.1363608    \n## factor(year)1943 -42.977623  12.509017 -3.4357 0.0007437 ***\n## factor(year)1944 -43.098772  10.965103 -3.9305 0.0001234 ***\n## factor(year)1945 -55.683040  15.159383 -3.6732 0.0003212 ***\n## factor(year)1946 -31.169284  20.858408 -1.4943 0.1369549    \n## factor(year)1947 -39.392242  26.363118 -1.4942 0.1369835    \n## factor(year)1948 -43.716514  38.769856 -1.1276 0.2610913    \n## factor(year)1949 -73.495099  38.147491 -1.9266 0.0557069 .  \n## factor(year)1950 -75.896112  36.695524 -2.0683 0.0401383 *  \n## factor(year)1951 -62.480912  49.279892 -1.2679 0.2065854    \n## factor(year)1952 -64.632341  51.417852 -1.2570 0.2104874    \n## factor(year)1953 -67.717966  43.622288 -1.5524 0.1224442    \n## factor(year)1954 -93.526221  31.637576 -2.9562 0.0035603 ** \n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n11.6.1 分散不均一の検定\n固定効果モデルにおいて, 分散不均一かどうかを検定するには, Breusch-Pagan 検定を実施する. bptest() 関数を使用して, 企業ダミーを含むモデルで検定を行う. bptest(inv ~ value + capital + factor(firm), data=pdata) コマンドで, 個別固定効果モデルの分散不均一性を検定する.\n\nbptest(inv ~ value + capital + factor(firm), data=pdata)\n## \n##  studentized Breusch-Pagan test\n## \n## data:  inv ~ value + capital + factor(firm)\n## BP = 85.836, df = 11, p-value = 1.086e-13\n\n時間効果モデルの場合, 企業ダミーと年ダミーの両方を含めて検定を行う. bptest(inv ~ value + capital + factor(firm) + factor(year), data=pdata) コマンドで, 時間効果モデルの分散不均一性を検定する.\n\nbptest(inv ~ value + capital + factor(firm) + factor(year),data=pdata)\n## \n##  studentized Breusch-Pagan test\n## \n## data:  inv ~ value + capital + factor(firm) + factor(year)\n## BP = 97.357, df = 30, p-value = 4.833e-09",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>パネル分析</span>"
    ]
  }
]