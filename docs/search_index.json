[
["index.html", "R と RStudio はじめに 0.1 R とは 0.2 R のインストール 0.3 R の設定 0.4 R の使い方", " R と RStudio 宮﨑憲治 2017-11-04 はじめに 0.1 R とは Rは統計・データ解析・統計グラフ作成のためのオープンソースソフトである. https://ja.wikipedia.org/wiki/R%E8%A8%80%E8%AA%9E 0.2 R のインストール Rをインストールするには https://cran.r-project.org/ にいき, 該当機種のファイルをダウンロードする. ダウンロードしたあとに実行すればインストールされる. Windows の場合, 32bit か 64bit を選択する. 最近のパソコンの CPU は 64bit と考えられるが, どちらかわからなければ 32bit にしておけばよい. Ubuntu なら ppa を使って導入してもよい. sudo add-apt-repository ppa:marutter/rrutter sudo apt-get update sudo apt-get install r-base r-base-dev 0.3 R の設定 設定ファイル .Rprofile をホームディレクトリに作成すれば, 設定を変更できる. ホームディレクトリはユーザー名が kenji のとき, Windows なら通常 C:\\Users\\kenji である. バックスラッシュ \\ は \\(\\yen\\) と読み替えて頂きたい. 最初は .Rprofile を特に作成しなくても大丈夫である. 0.4 R の使い方 Windows だとコマンドプロンプトから R と入力して立ち上げるか, R のアイコンをダブルクリックすると, Rコンソールと言われる画面が現れる. コマンドプロンプトからだと最初の表示が文字化けしている可能性があるが, その後の起動に問題ないはずである. アイコンがなければ, Winキーを押した後, rgui と入力すれば起動できる. Mac や Ubuntu だとターミナルから R と入力して起動できる. 立ち上げた後, コンソールから そこにコマンドを入力すると, その結果が直後に出力される. 終了には q() とする. 作業スペースを保存するかと聞かれたなら, No を意味する n を選択する. コマンド入力中, 最後の括弧を付け忘れたり, 正しく実行ができないときがある. たとえば, rnorm(5 としてEnterキーを押せば, 次の行に + とでてくる. ここでは正しく ) を付けて再度Enterキーを押せば正しく実行されるが, ときにはどれを入力すれば正しく実行されるかわからない一方で, 単にEnterを押すだけだと, 再度入力を求められることがある. そうしたとときは通常左上にあるエスケープキー (ESC) を押せば途中入力がキャンセルされる. R はRコンソールから対話式にコマンドを入力していく方法と, 拡張子 R のスクリプトファイルを実行していくやり方がある. 実行履歴を記録するためにスクリプトファイルを作成していくやり方を推奨する. スクリプトファイル project.R を Rコンソールから実行するには, source(&quot;project.R&quot;) とすればよい. R外部のコマンドプロンプトから実行するには Rscript project.R とすればよい. 起動できないときには, 環境変数の PATH にRの実行ファイルの場所が登録されていない可能性がある. また外部ファイルを導入する際やファイルを外部出力する際には, 現在の作業ディレクトリに気をつけなければならない. 現在の作業ディレクトリの場所はRコンソールから getwd() とすれば, 確認できる. Windows だと通常の表記と異なっていることに注意されたい. 作業ディレクトリの指定は以下のようにする. setwd(PATH) Windows のとき指定の仕方に注意が必要である. たとえば作業ディレクトリが C:\\Users\\kenji\\work\\project のとき, setwd(&quot;C:/Users/kenji/work/project&quot;) となる. バックスラッシュ \\ (\\(\\yen\\)) を スラッシュ / に変更しなければならない. "],
["01-base.html", "1 基本 1.1 電卓としての R 1.2 関数電卓としてのR 1.3 R の型 1.4 変数 1.5 パッケージ", " 1 基本 R の基本として以下の2つのサイトでオンラインで学習することをオススメする. ただし英語である. http://tryr.codeschool.com/ https://www.datacamp.com/courses/free-introduction-to-r また以下の日本語版のチートシートが有用である. https://www.rstudio.com/wp-content/uploads/2016/10/r-cheat-sheet-ja.pdf R についての動画はまず以下を見ていただきたい. http://dotinstall.com/lessons/basic_r 日本語で合計40分くらいで13分割して配信している. 他にも Youtube にいけば他にも多数動画がある. 1.1 電卓としての R R は電卓してとして使える. 数値を扱う算術演算子として以下のものが代表的である. 演算子 説明 例 + 足し算 5 + 2 = 7 - 引き算 5 - 2 = 3 * 掛け算 5 * 2 = 10 / 割り算 5 / 2 = 2.5 ^, ** べき算 5 ^ 2 = 25, 5 ** 2 = 25 %% 割り算の余り 5 %% 2 = 1 %/% 割り算の切り下げ 5 %/% 2 = 2 5 + 2 ## [1] 7 5 - 2 ## [1] 3 5 * 2 ## [1] 10 5 / 2 ## [1] 2.5 5 ^ 2 ## [1] 25 5 ** 2 ## [1] 25 5 %% 2 ## [1] 1 5 %/% 2 ## [1] 2 1.2 関数電卓としてのR R は関数として使える. たとえば以下の関数がある. 関数 説明 sqrt() 平方根 \\(\\sqrt{\\cdot}\\) exp() 指数 log() 対数 factorial() 順列 choose() 組み合わせ abs() 絶対値 round() 四捨五入 floor() 切り下げ ceiling() 切り上げ sqrt(10) ## [1] 3.162278 exp(10) ## [1] 22026.47 log(10) ## [1] 2.302585 factorial(4) ## [1] 24 choose(4,2) ## [1] 6 abs(-10) ## [1] 10 round(3.5) ## [1] 4 floor(3.5) ## [1] 3 ceiling(3.5) ## [1] 4 関数の括弧に入る数値を引数という. 組み合せを計算する関数 choose の引数は2つある. 複数の引数は , で区切る. 引数の順序は指定すれば変更可能である. choose(4, 2) ## [1] 6 choose(n=4, k=2) ## [1] 6 choose(k=2, n=4) ## [1] 6 また幾つかの引数は入力しなくても. デフォルトで設定してあることがある. それぞれの関数のヘルプを確認されたい. 関数のヘルプはコマンド choose の場合 help(choose) ?choose で調べることができる. 1.3 R の型 Rにおいて値は型 (type) をもち, 型として数値 (numeric) と文字列 (character) と論理値 (logical) など1がある. 多くの言語と違い, あらかじめ宣言する必要なく, 自動的に決定される. 数値には整数 (integer) と, 実数をコンピュータ的に扱っている倍数精度小数 (double) など2がある. 整数か倍数精度小数かは自動的に振り分けられるが, 明示的に数字の後に L をつけて整数を指定することができる. 文字は &quot; (ダブルクオーテーション) もしくは ' (シングルクォーテーション) で区切られる. TRUE もしくは FALSE を取る値を論理値 (logical) という. 省略して T と F とあわらせることもできるが混乱するので個人的に推奨しない. 値の型は関数 typeof() で確認できる. typeof(3) ## [1] &quot;double&quot; typeof(3L) ## [1] &quot;integer&quot; typeof(&quot;3&quot;) ## [1] &quot;character&quot; typeof(TRUE) ## [1] &quot;logical&quot; typeof(FALSE) ## [1] &quot;logical&quot; typeof(T) ## [1] &quot;logical&quot; typeof(F) ## [1] &quot;logical&quot; 特殊な値として, 無限大を意味する Inf, 非数を意味する NaN, 欠損値を意味する NA , 空を意味する NULL がある. Inf と Nan の型は数値として分類され, NA の型は論理値として分類される. また NULL は NULL という特別な型である. 1/0 ## [1] Inf typeof(1/0) ## [1] &quot;double&quot; 0/0 ## [1] NaN typeof(0/0) ## [1] &quot;double&quot; typeof(NA) ## [1] &quot;logical&quot; typeof(NULL) ## [1] &quot;NULL&quot; 1.4 変数 値は変数 (variable) に代入することによって再利用が可能になる. Rでは代入のことを付値 (assign) といい, 以下のように実行される. x &lt;- 4 4 -&gt; x x = 4 assign(&quot;x&quot;,4) 多くのプログラム言語では3番目のやり方をだけであるが, R では最初のやり方を推奨している.3 代入した値を確認するには単にその変数を入力すればよい. 代入と同時に確認するには丸括弧をつけるとよい. x ## [1] 4 (x&lt;-3) ## [1] 3 付値される変数として, 記号と数字からはじまらなければ, ほぼ自由に作れる. アルファベットについて大文字と小文字が区別されることに注意されたい. また日本語も変数に使えるが, 機種によって文字コードが違うため, 避けて使うほうが望ましい. 扱える変数は if などいくつか4はエラーになるが, pi のようにすでに組み込まれている変数も変更して指定することができる. pi ## [1] 3.141593 pi &lt;- 3 pi ## [1] 3 関数 objects() を使うことで，現在どんなオブジェクトがあるかを調べられる． R は変数や関数を全てオブジェクトとして扱う言語である. また，前に定義したオブジェクトを消す場合 rm() を用いる． すでに組み込まれた変数を上書きした pi を削除するともとの変数が復活する. rm(pi) pi ## [1] 3.141593 さらに，全てのオブジェクトを消す場合は rm(list=ls(all=TRUE)) とすればよい． 1.5 パッケージ R においてパッケージを導入することによって, 機能を拡張させることができる. パッケージ pkg を導入するため一度だけ以下を実行する. install.packages(&quot;pkg&quot;, dependencies = =TRUE) とする. オプション dependencies = TRUE 依存するパッケージを同時に導入してくれる. パッケージ pkg が導入していれば, そのコマンド cmd を実行するには pkg::cmd とパッケージとコマンドの間に :: とする. もしくは library(pkg) もしくは require(pkg) 予め入力しておけば, 最初の pkg:: を省略することができる. なお複数のパッケージで同じ名前のコマンドがある場合, あとで library もしくは require としたパッケージの方が優先させるので注意されたい. 他にも日付 (Date) やバイナリ (raw) がある.↩ 他にも複素数 (complex) がある.↩ 例えば以下を参照されたい: http://adv-r.had.co.nz/Style.html↩ break, else, FALSE, for, function, if in Inf, NA, NaN, next NULL, repeat, TRUE, while など↩ "],
["02-rstudio.html", "2 RStudio 2.1 RStudio とは 2.2 RStudio のインストール 2.3 RStudio の設定 2.4 RStudio の使い方", " 2 RStudio 2.1 RStudio とは RStudio は R の統合開発環境 (IDE, Integrated Development Enviroment) の一つである. オープンソース版が存在する. https://ja.wikipedia.org/wiki/R-Studio 2.2 RStudio のインストール オープンソース版のRStudio のインストールは https://www.rstudio.com/products/rstudio/download/ にいき, 該当機種のファイルをダウンロードする. ダウンロードしたあとに実行すればインストールされる. Ubuntu ならサーバー版を導入するとよい. https://www.rstudio.com/products/rstudio/download-server/ 2.3 RStudio の設定 メニューバーの [Tools] から [Global Options…] を選択することで設定を変更できる. [General] で以下のように [Restore .RData …] のチェックを外していいて, その下を Never にしている. これは, 立ち上げたきに環境をクリーンし, 終了時に, データの保存を聞かれないようにするためである. 次に, [Code] の タブ [Saving] で. [Default text encoding] を UTF-8 としている. Windows 以外だとOSのシステムフォントが同じなので問題ない. ただ, Windows は SJIS を拡張した CP932 なので, 注意が必要である. Windows のRは UTF-8 を選択してもR自身はCP932処理している. ただ, 他のOSとの併用の場合, UTF-8 にしたほうがよいだろう. またHTMLファイルは UTF-8 でのファイルが前提になりつつあるので, HTML として出力を考えているなら, UTF-8 としたほうが無難である. またインターネットで公開されている日本語のRファイルは Windows の使用が前提となっているため, 文字コードが CP932 であることが多い. Windows 以外を使っている場合, 一時的に文字コードを SJIS を選択する必要がある. あと, [R Markdown] で 真ん中あたりの [Show output preview in:] を View Pane に変更する 2.4 RStudio の使い方 RStudio の使い方として日本語版のチートシートがある. https://github.com/rstudio/cheatsheets/raw/master/translations/japanese/rstudio-IDE-cheatsheet_ja.pdf RStudio プロジェクト単位で複数のソースコードを管理するのことが推奨される. そうするとプロジェクトごとに作業ディレクトリが設定される. プロジェクトはメニューバー の [File] から [New Project] を選択する. そうすると新たに新たにディレクトリを作成するか, 既存のディレクトリを採用するかなどが選べる. また, バージョン管理ソフトを導入していればそこから取り入れることも可能となる. プロジェクトを立ち上げると左にコンソールペイン (Console Pane) が, 右側に上下に二分割されたペインが現れる. この配置は メニューバーの [Tools] から [Project Options -&gt; Pane Layout] を選べば変更可能である. コンソールペインにコマンドを入力するとその結果が直下に返される. 何か入力した後に, Ctrl + l (Cmd + l) を押すと, 画面が更新される. 上下の矢印キーで過去に実行したコマンドを選択できる. メニューバー の [File] から [New File -&gt; RScript] を選択するか, Ctrl + Shift + n (Cmd + Shift + n) と入力するか, メニューバー下の一番左の白紙のアイコンをクリックすると, Rのスクリプトファイルが新規に作られる. スクリプフォファイルを開くと左側のコンソール画面の上にソースペインが登場する. ここにソースコードを書く. ソースペインで何かコマンドを書いていきながら, ソースコードの該当行で Ctrl + Enter (Cmd + Return) と入力するか, ソースペインの上側の右に並んでいるアイコンのうち, 左側のRunと書かれたアイコンをクリックすると, 該当行がコンソール画面で実行される. 複数行選択した後に, メニューバー の [Code] から [Run Selected line(s)] を選ぶか, Ctrl + Shift + Enter (Cmd + Shift + Enter) と入力すると複数行をまとめて実行させることも可能である. メニューバー の [File] から [Save] を選択するか, Ctrl + s (Cmd + s) と入力するか, メニューバー下の左から3番目のフロッピーディスクアイコンをクリック すると, スクリプトファイルを保存することができる. またメニューバー の [File] から [Open] を選択するか, Ctrl + o (Cmd + o) と入力するか, メニューバー下の左から2番めのフォルダを開くアイコンをクリックすると, 既存のスクリプトファイルを開くことができる. 右上のペインには Environment と History のタブがある. Environment は現在使っているオブジェクトが表示される. 最初は空白である. 変数に数値を代入 (R の言い方ではオブジェクトに付値) することによって, 値が付け加わっている. History はこれまでの履歴が記録される. 履歴の一部ををエディトペインかコンソールペインに挿入することができる. 右下のペインには Files, Plots, Packages, Help, Viewer のタブがある. Files ペインはWindowsではエクスプローラーのようなもので, Mac はFinder のようなもので, ファイル管理をおこなう. ファイル管理として新たなフォルダを作成したり, ファイルを削除したり, ファイル名を変更したりする. Plots ペインはコンソール画面で作図をコマンドの実行したら, 表示されるペインである. そこで作成した図をコマンドを使わずに保存したりすることができる. Packages ペインは現在Rに導入されているパッケージリストが表示される. そこに無いパッケージはメニューバーの [Tools] から [Install Packages…] を選択して実行すればよい. すでにあるパッケージは, パッケージ名の左側のボックスをチェックすれば, ライブライリ名を付けずにコマンドを実行させることができる. Help ペインはその名の通り, ヘルプ画面が表示される. コンソールペインから help (コマンド) もしくは ?コマンド と入力するとそのコマンドのヘルプがこのペインに表示される. R ではソースペインやコンソールペインで, コマンド入力していると, コマンドの後補があらわてくる. [TAB] でコマンドを補完できる. さらにそのコマンドでどのような引数が使われるのかも示される. さらに [TAB] を押せば, 引数を選べるだけでなく, 簡単なコマンドの説明がある. そのときに [F1] を押せば, より詳細なヘルプが立ち上がる. また Packages パインから該当パッケージをクリックするとそのパッケージのコマンド一覧が Help ペインに表示される. 最後のViewer ペインは R Markdown で作成したファイルを HTMLで出力したときに表示されるペインである. 最初の設定だと別のウィンドウ画面として結果が表示される. このペインに出力されるためには [Tools -&gt; R Markdown] にいき, 真ん中あたりの [Show output preview in:] を View Pane に変更する必要がある. その上でソースペインから [Ctrl + Shift + k] とするか, ソースペインの左側のアイコン群の一番右側のノートのアイコンをクリックすると, 確認画面が現れるので HTML を押す. そうするとそのコードがすべて実行されて, 実行結果が作図も含めてHTMLファイルに出力される. もしくはメニューバーの [File] から [Knit Document…] としを選択するとよい. これは knitr と rmarkdown いわれるパッケージを利用したもので, Rのコードを埋め込んだマークダウンファイルを作成し, そこからHTMLファイルを作成する. 他にも word ファイル や pdf ファイル生成することも適切に設定していれば可能である. ソースコードだけでなく, マークダウンファイルに R コマンドを埋め込んだ Rmd ファイルを作成することができる それは新規作成でRスクリプトでなく, R Notebook や R Markdown を選択すればよい. "],
["03-vector.html", "3 ベクトル 3.1 ベクトル 3.2 算術演算子 3.3 論理演算子 3.4 比較演算子 3.5 要素 3.6 関数 3.7 規則的なベクトル 3.8 乱数ベクトル", " 3 ベクトル 3.1 ベクトル Rでは同じ型の値を集めたものをベクトルという. ベクトルは c() を用いて構成する. (num&lt;-c(2,3,7,9)) ## [1] 2 3 7 9 (chr &lt;- c(&quot;cat&quot;,&quot;dog&quot;,&quot;cow&quot;)) ## [1] &quot;cat&quot; &quot;dog&quot; &quot;cow&quot; ベクトルには長さという属性 (attribute) が付く. length(num) ## [1] 4 length(chr) ## [1] 3 ベクトルはオブジェクトの基本であり, 一つの値は長さが1のベクトルと考える. 型が同じでない場合, 強制的に同じ型に変換される. 文字列が含まれればすべて文字列になる. 数値と論理値の場合は論理値の TRUE が1に FALSE が0に変換される. (x&lt;- c(1,4)) ## [1] 1 4 typeof(x) ## [1] &quot;double&quot; (y &lt;- c(2,FALSE,&quot;4&quot;)) ## [1] &quot;2&quot; &quot;FALSE&quot; &quot;4&quot; typeof(y) ## [1] &quot;character&quot; (z &lt;- c(2,FALSE)) ## [1] 2 0 typeof(z) ## [1] &quot;double&quot; 3.2 算術演算子 四則演算などの算術演算子はその対象を数値ベクトルに拡張できる. ベクトルの算術演算子はその要素ごと行う. a&lt;-c(2,3,3,3) b&lt;-c(3,3,5,7) a+b ## [1] 5 6 8 10 a-b ## [1] -1 0 -2 -4 a*b ## [1] 6 9 15 21 a/b ## [1] 0.6666667 1.0000000 0.6000000 0.4285714 a^b ## [1] 8 27 243 2187 片方が値, 同じ長さのベクトルとして演算が実行される. a+2 ## [1] 4 5 5 5 a-2 ## [1] 0 1 1 1 a*2 ## [1] 4 6 6 6 a/2 ## [1] 1.0 1.5 1.5 1.5 a^2 ## [1] 4 9 9 9 一般に長さが違う場合, 短いほうが繰り返される. c&lt;-c(1,2) a+c ## [1] 3 5 4 5 a-c ## [1] 1 1 2 1 a*c ## [1] 2 6 3 6 a/c ## [1] 2.0 1.5 3.0 1.5 a^c ## [1] 2 9 3 9 なお 短いほうが長い方の約数でないと警告がでる. 3.3 論理演算子 論理値に対して演算をおこなって論理値を返す論理演算子というものがある. Rには, 論理演算子として, 否定 (!), または (|), かつ (&amp;) がある. 論理演算子もベクトルごとに評価できる. logic1 &lt;- c(TRUE, FALSE, FALSE) logic2 &lt;- c(TRUE, TRUE, FALSE) !logic1 ## [1] FALSE TRUE TRUE logic1 | logic2 ## [1] TRUE TRUE FALSE logic1 &amp; logic2 ## [1] TRUE FALSE FALSE ベクトルのうちすべての要素が TRUE かどうかを評価する all や 少なくとも一つの要素が TRUE かどうかを評価する any というのがある. , any(logic1) ## [1] TRUE all(logic1) ## [1] FALSE 3.4 比較演算子 2つの値を比較してして論理値を返す比較演算子というものがある. Rには, 比較演算子として, 等しいか ==, どちらかが大きいか &gt;, &lt; がある. それぞれのベクトルの要素ごとに評価できる. vec1 &lt;- 1:4 vec2 &lt;- c(2,1,3,4) vec1 == vec2 ## [1] FALSE FALSE TRUE TRUE vec1 &gt; vec2 ## [1] FALSE TRUE FALSE FALSE vec1 &lt; vec2 ## [1] TRUE FALSE FALSE FALSE 他にも等しくない !=, 以上および以下 &gt;=, &lt;= がある. vec1 != vec2 # !(vec1==vec2) ## [1] TRUE TRUE FALSE FALSE vec1 &gt;= vec2 # (vec1 &gt; vec2 | vec1 == vec2) ## [1] FALSE TRUE TRUE TRUE vec1 &lt;= vec2 # (vec1 &lt; vec2 | vec1 == vec2) ## [1] TRUE FALSE TRUE TRUE 片方が値, 同じ長さのベクトルとして演算が実行される. vec1 &gt; 2 ## [1] FALSE FALSE TRUE TRUE 3.5 要素 ベクトルの要素はカギカッコで取り出す. num &lt;- c(2,3,7,9) num[3] ## [1] 7 取り出すだけななく付値することもできる. num[3] &lt;- 500 num ## [1] 2 3 500 9 マイナスをつけるとその要素以外を取り出す. num[-3] ## [1] 2 3 9 複数取り出すこともできる. num[c(1,4)] ## [1] 2 9 他にも論理値ベクトルを使って取り出すことができる. idx &lt;- c(TRUE,FALSE,TRUE,TRUE) num[idx] ## [1] 2 500 9 さらに比較演算子と組み合わせることができる. (num &gt; 4) ## [1] FALSE FALSE TRUE TRUE num[num &gt; 4] ## [1] 500 9 また : をもちいて連続したベクトルが作れるので, それを利用してベクトルを抜き出すことができる. 2:4 ## [1] 2 3 4 num[2:4] ## [1] 3 500 9 またベクトルには名前の属性をつけて構成することがでる. vec &lt;- c(x= 3, y =3, z = 4) また次のようにしてもよい. names(num) &lt;- letters[1:4] いずれに名前の属性をつけると次のようにしてアクセスが可能である. vec[&quot;x&quot;] ## x ## 3 num[&quot;d&quot;] ## d ## 9 3.6 関数 引数がベクトルの関数がいくつかある. これによってベクトルの和や積が簡単に扱える. x&lt;-c(1,2,3,4,5) sum(x) ## [1] 15 cumsum(x) ## [1] 1 3 6 10 15 prod(x) ## [1] 120 cumprod(x) ## [1] 1 2 6 24 120 平均, 中央値, 分散, 標準偏差などの統計関数も扱える. x &lt;- c(x,10) mean(x) ## [1] 4.166667 median(x) ## [1] 3.5 var(x) ## [1] 10.16667 sd(x) ## [1] 3.188521 ベクトルを並べ替えたり 最小値や最大値しめしたり, それが何番目の要素になるのかをしめすことができる. x &lt;- c(3,3,5,0) sort(x) ## [1] 0 3 3 5 sort(x,decreasing = TRUE) ## [1] 5 3 3 0 min(x) ## [1] 0 max(x) ## [1] 5 which.min(x) ## [1] 4 which.max(x) ## [1] 3 またベクトルに NA が含まれるき, 関数 mean などではデフォルトで結果が, NA になる. それを避けるには na.rm=TRUE というオプションを付ける必要がある. x &lt;- c(4,2,NA,3) mean(x) ## [1] NA mean(x, na.rm = TRUE) ## [1] 3 3.7 規則的なベクトル 1:5 のような規則的なベクトルを柔軟に作成するのに seq を用いるとよい. 1:5 ## [1] 1 2 3 4 5 seq(1, 5) ## [1] 1 2 3 4 5 seq(1, 5, by = 2) ## [1] 1 3 5 seq(1, 5, length.out = 4) ## [1] 1.000000 2.333333 3.666667 5.000000 繰り返しを作成することができる rep も覚えておくと便利である. rep(1, 5) ## [1] 1 1 1 1 1 rep(c(1, 2), times = 3) ## [1] 1 2 1 2 1 2 rep(c(1, 2), each = 3) ## [1] 1 1 1 2 2 2 またアルファベットの文字列もあらかじめ組み込まれている. letters ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; ## [18] &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; LETTERS ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; ## [18] &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; LETTERS[1:2] ## [1] &quot;A&quot; &quot;B&quot; 3.8 乱数ベクトル ベクトルを出鱈目に並べ直すには関数 sample を使う set.seed(10) sample(1:5) ## [1] 3 2 4 5 1 最初の行の関数 set.seed は他の環境でも再現可能性にするための設定である. さて, この乱数は一旦出力された値は二度とでない非復元抽出である. 復元抽出にするには sample(1:5, replace=TRUE) ## [1] 2 2 2 4 3 とオプション replace=TRUE をつける. いくつ取り出すかをオプション size で決められる. sample(LETTERS[1:2], size=10, replace=TRUE) ## [1] &quot;B&quot; &quot;B&quot; &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; 非復元抽出の場合, 取りうる値より大きくできないことに注意されたい. さらに確率を prob で変えることができる. sample(LETTERS[1:2], prob=c(0.8,0.2),size=10,replace=TRUE) ## [1] &quot;B&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; 独立な一様分布にしたがう長さ size のベクトルは runif(size) によって, 正規分布にしたがうベクトルは rnorm(size) で出力される. size &lt;- 8 runif(size) ## [1] 0.53559704 0.09308813 0.16980304 0.89983245 0.42263761 0.74774647 ## [7] 0.82265258 0.95465365 rnorm(size) ## [1] 0.4829785 -0.5963106 -2.1852868 -0.6748659 -2.1190612 -1.2651980 ## [7] -0.3736616 -0.6875554 "],
["04-dataframe.html", "4 データ構造 4.1 ベクトル 4.2 リスト 4.3 因子ベクトル 4.4 行列 4.5 データフレイム", " 4 データ構造 4.1 ベクトル Rでは同じ型の値を集めたものをベクトルという. ベクトルは c() を用いて構成する. (num&lt;-c(2,3,7,9)) ## [1] 2 3 7 9 (chr &lt;- c(&quot;cat&quot;,&quot;dog&quot;,&quot;cow&quot;)) ## [1] &quot;cat&quot; &quot;dog&quot; &quot;cow&quot; ベクトルには長さという属性 (attribute) が付く. length(num) ## [1] 4 length(chr) ## [1] 3 ベクトルはオブジェクトの基本であり, 一つの値は長さが1のベクトルと考える. 型が同じでない場合, 強制的に同じ型に変換される. 文字列が含まれればすべて文字列になる. 数値と論理値の場合は論理値の TRUE が1に FALSE が0に変換される. (x&lt;- c(1,4)) ## [1] 1 4 typeof(x) ## [1] &quot;double&quot; (y &lt;- c(2,FALSE,&quot;4&quot;)) ## [1] &quot;2&quot; &quot;FALSE&quot; &quot;4&quot; typeof(y) ## [1] &quot;character&quot; (z &lt;- c(2,FALSE)) ## [1] 2 0 typeof(z) ## [1] &quot;double&quot; 4.1.1 ベクトルのアクセス ベクトルの要素はカギカッコに整数値を代入することで 取り出すせることができる. たとえば3番目のベクトルの要素を取り出すには以下とする. num &lt;- c(2,3,7,9) num[3] ## [1] 7 また名前の属性をつけてベクトルを構成することがでる. vec &lt;- c(x= 3, y =3, z = 4) vec ## x y z ## 3 3 4 names(vec) ## [1] &quot;x&quot; &quot;y&quot; &quot;z&quot; すでにあるリストの場合, 次のようにしてもよい. names(num) &lt;- letters[1:4] num ## a b c d ## 2 3 7 9 いずれに名前の属性をつけると次のようにしてアクセスが可能である. vec[&quot;x&quot;] ## x ## 3 num[&quot;d&quot;] ## d ## 9 4.2 リスト ベクトルなどを集めたものをリストという. ベクトル型の違うベクトルを関数 list で集める. リストの属性には長さがある. (lst &lt;- list(&quot;a&quot;,c(3,3,2))) ## [[1]] ## [1] &quot;a&quot; ## ## [[2]] ## [1] 3 3 2 typeof(lst) ## [1] &quot;list&quot; length(lst) ## [1] 2 関数 class によってリストがであることが確認でき, str で属性を詳しく調べることができる. class(lst) ## [1] &quot;list&quot; str(lst) ## List of 2 ## $ : chr &quot;a&quot; ## $ : num [1:3] 3 3 2 リストとベクトルの違いとして, リスト自体もリストとして含められることがある. typeof(list(&quot;b&quot;,lst)) ## [1] &quot;list&quot; リストベクトルに変換するには unlist を用いる. それぞれの型が違う場合, 同じ型に強制変換される. lst&lt;-list(1:3,2:6) lst ## [[1]] ## [1] 1 2 3 ## ## [[2]] ## [1] 2 3 4 5 6 unlist(lst) ## [1] 1 2 3 2 3 4 5 6 unlist(list(&quot;a&quot;,1:4)) ## [1] &quot;a&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; 4.2.1 リストのアクセス リストの取りだすには, ベクトルのようにかぎかっこで数値を入力する. 以下は一番目のリストを表示している. lst[1] ## [[1]] ## [1] 1 2 3 また名前の属性をもてば, その名前を入力することで取り出すことができる. たと次のようにして名前の属性をつけたリストを作る. (lst &lt;- list(name=&quot;a&quot;,num=c(3,3,2))) ## $name ## [1] &quot;a&quot; ## ## $num ## [1] 3 3 2 names(lst) ## [1] &quot;name&quot; &quot;num&quot; その上で以下のようにすれば2番目の要素が取り出せる. lst[&quot;num&quot;] ## $num ## [1] 3 3 2 いずれにせよ取り出したののもリストになることに注意されたい. typeof(lst[1]) ## [1] &quot;list&quot; typeof(lst[&quot;num&quot;]) ## [1] &quot;list&quot; ベクトルとして取り出すには次のようにする. lst[[2]] ## [1] 3 3 2 typeof(lst[[2]]) ## [1] &quot;double&quot; 名前の属性がついていれば以下のようにもできる. lst[[&quot;num&quot;]] ## [1] 3 3 2 lst$num ## [1] 3 3 2 リストのなかのあるベクトルの平均値を求めるには次のようにする. ## mean(lst[[2]]) ## mean(lst[[&quot;num&quot;]]) mean(lst$num) ## [1] 2.666667 もしくは以下とする. with(lst, mean(num)) ## [1] 2.666667 なおリストの要素を消すには以下のようにする. lst$num &lt;- NULL lst ## $name ## [1] &quot;a&quot; 4.3 因子ベクトル 4.3.1 factor 文字列ベクトルを引数にした関数 factorによって 因子 (factor) ベクトルを作成できる. (x &lt;- c(&quot;L&quot;,&quot;S&quot;,&quot;M&quot;,&quot;M&quot;,&quot;L&quot;)) ## [1] &quot;L&quot; &quot;S&quot; &quot;M&quot; &quot;M&quot; &quot;L&quot; (x.fac &lt;- factor(x)) ## [1] L S M M L ## Levels: L M S 因子ベクトルの実体は level という属性をもつ整数ベクトルである. typeof(x.fac) ## [1] &quot;integer&quot; length(x.fac) ## [1] 5 levels(x.fac) ## [1] &quot;L&quot; &quot;M&quot; &quot;S&quot; 関数 class によって因数ベクトルがであることが確認でき, str で属性を詳しく調べることができる. class(x.fac) ## [1] &quot;factor&quot; str(x.fac) ## Factor w/ 3 levels &quot;L&quot;,&quot;M&quot;,&quot;S&quot;: 1 3 2 2 1 また水準の表示順は自動的にアルファベット順になるが, それを変更するには次のようにする. (x.factor &lt;- factor(x,levels=c(&quot;S&quot;,&quot;M&quot;,&quot;L&quot;))) ## [1] L S M M L ## Levels: S M L この水準に順序構造を付与するには次のようにする. (x.order &lt;- ordered(x,levels=c(&quot;S&quot;,&quot;M&quot;,&quot;L&quot;))) ## [1] L S M M L ## Levels: S &lt; M &lt; L 4.3.2 cut また数値を区間ごとに区分した因子ベクトルも作成可能である. 0から10までの値を発生させる. x &lt;- runif(10,0,10) x ## [1] 4.003271 5.036024 4.801610 1.218557 6.985596 4.789283 4.025132 ## [8] 6.736584 5.214231 2.009371 5等分するには以下のようにする. cut(x, breaks=5) ## [1] (3.53,4.68] (4.68,5.83] (4.68,5.83] (1.21,2.37] (5.83,6.99] ## [6] (4.68,5.83] (3.53,4.68] (5.83,6.99] (4.68,5.83] (1.21,2.37] ## Levels: (1.21,2.37] (2.37,3.53] (3.53,4.68] (4.68,5.83] (5.83,6.99] これは登場したデータの最大値と最小値の幅を5等分している. 区間を指定するには以下のようにベクトルで指定する. cut(x,breaks=c(0,2,4,6,8,10)) ## [1] (4,6] (4,6] (4,6] (0,2] (6,8] (4,6] (4,6] (6,8] (4,6] (2,4] ## Levels: (0,2] (2,4] (4,6] (6,8] (8,10] 0より大きく2以下, 2より大きく4以下,… となっている. 0も含めるのなら include.lowest=TRUE というオプションをつける. cut(x, breaks=seq(0,10,2),include.lowest=TRUE) ## [1] (4,6] (4,6] (4,6] [0,2] (6,8] (4,6] (4,6] (6,8] (4,6] (2,4] ## Levels: [0,2] (2,4] (4,6] (6,8] (8,10] またこれを0以上2未満, 2以上4未満, … とするにはオプション right=FALSE をつける. cut(x, breaks=seq(0,10,2),right=FALSE,include.lowest=TRUE) ## [1] [4,6) [4,6) [4,6) [0,2) [6,8) [4,6) [4,6) [6,8) [4,6) [2,4) ## Levels: [0,2) [2,4) [4,6) [6,8) [8,10] このとき, include.lowest=TRUE は最大値を含めることを意味する. また因子の名称はオプション labels で変更可能である. cut(x, breaks=seq(0,10,2),right=FALSE,include.lowest=TRUE, labels =c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;)) ## [1] C C C A D C C D C B ## Levels: A B C D E 4.4 行列 ベクトルに縦と横の次元を付与することによって行列 (matrix) を作ることができる. mat &lt;- matrix(1:10, nrow=2,ncol=5) mat ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 またオプション byrow=TRUE で横から行列を作成できる. matrix(1:10, nrow=2,ncol=5,byrow = TRUE) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 2 3 4 5 ## [2,] 6 7 8 9 10 この行列の実体は dim という属性を持つ数値ベクトルである. typeof(mat) ## [1] &quot;integer&quot; length(mat) ## [1] 10 dim(mat) ## [1] 2 5 dim(mat) ## [1] 2 5 他にもそれぞれの要素の次元は以下で得ることができる. nrow(mat) ## [1] 2 ncol(mat) ## [1] 5 関数 class によって因数ベクトルがであることが確認でき, str で属性を詳しく調べることができる. class(mat) ## [1] &quot;matrix&quot; str(mat) ## int [1:2, 1:5] 1 2 3 4 5 6 7 8 9 10 4.4.1 行列の演算 縦での結合は rbind を用いる mata&lt;-matrix(1:5,nrow=1,ncol=5) rbind(mat,mata) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 ## [3,] 1 2 3 4 5 横での結合は cbind を用いる matb&lt;-matrix(1:4,nrow=2,ncol=2) cbind(mat,matb) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] ## [1,] 1 3 5 7 9 1 3 ## [2,] 2 4 6 8 10 2 4 転置行列は以下のようにすればよい. t(mat) ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 ## [3,] 5 6 ## [4,] 7 8 ## [5,] 9 10 通常の * は要素ごとの掛け算になる. 数学で用いられる行列同士の掛け算は %*% を実施する. matb %*% mat ## [,1] [,2] [,3] [,4] [,5] ## [1,] 7 15 23 31 39 ## [2,] 10 22 34 46 58 行列のことが一致させる必要がある. また列ごとの合計, 行ごとの合計は以下を実施する. colSums(mat) ## [1] 3 7 11 15 19 rowSums(mat) ## [1] 25 30 返り値はベクトルになる. 行列のすべての要素を足すには sum でよい. sum(mat) ## [1] 55 また列ごとの平均, 行ごとの平均は以下を実施する. colMeans(mat) ## [1] 1.5 3.5 5.5 7.5 9.5 rowMeans(mat) ## [1] 5 6 4.4.2 行列のアクセス 行列からベクトルの取り出し以下のようにｓる. mat[2,] ## [1] 2 4 6 8 10 ベクトルのまま取り出されてしまう. オプション drop=FALSE をつけると行列のまま取り出すことができる. mat[, 3, drop=FALSE] ## [,1] ## [1,] 5 ## [2,] 6 2つ同時に取り出すにときは特にオプションをしていしなくても行列として取り出せる. mat[,2:3] ## [,1] [,2] ## [1,] 3 5 ## [2,] 4 6 要素の取り出し mat[2,3] ## [1] 6 行列に名前を付けることができる. rownames(mat) &lt;- letters[1:2] colnames(mat) &lt;- 1:5 mat ## 1 2 3 4 5 ## a 1 3 5 7 9 ## b 2 4 6 8 10 これによって以下のようにしてもアクセス可能である. mat[&quot;a&quot;,&quot;3&quot;] ## [1] 5 なお名前は次のようにしてあとから作成することができる. dimnames(mat) &lt;- list(LETTERS[1:2],2:6) mat ## 2 3 4 5 6 ## A 1 3 5 7 9 ## B 2 4 6 8 10 4.5 データフレイム 同じ長さのベクトルを組み合わせたリストをデータフレイム (dataframe) という. データフレイムは次のようにして作られる. df &lt;- data.frame(x = rnorm(10), y = letters[1:10]) データフレイムは大規模なことが多いので最初の数行だけをみるためには head をもちいる. head(df) ## x y ## 1 -0.8590929 a ## 2 -1.3674449 b ## 3 -0.2737766 c ## 4 -0.4788242 d ## 5 -0.3126285 e ## 6 -0.6290982 f データの簡単な統計表は summary を使うとよい. summary(df) ## x y ## Min. :-2.60081 a :1 ## 1st Qu.:-0.80159 b :1 ## Median :-0.39573 c :1 ## Mean :-0.41520 d :1 ## 3rd Qu.: 0.07077 e :1 ## Max. : 1.39208 f :1 ## (Other):4 よりプログラム言語としてのデータ構造を調べるには str を使えばよい. str(df) ## &#39;data.frame&#39;: 10 obs. of 2 variables: ## $ x: num -0.859 -1.367 -0.274 -0.479 -0.313 ... ## $ y: Factor w/ 10 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,..: 1 2 3 4 5 6 7 8 9 10 データフレイムはリストである. typeof(df) ## [1] &quot;list&quot; class(df) ## [1] &quot;data.frame&quot; リストのように長さと名前をもつ. length(df) ## [1] 2 names(df) ## [1] &quot;x&quot; &quot;y&quot; 行列と同じ次元をもつ. dim(df) ## [1] 10 2 ncol(df) ## [1] 2 nrow(df) ## [1] 10 ncol(df) は length(df) と同じである. 行列と同じ名前をもつ. dimnames(df) ## [[1]] ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; ## ## [[2]] ## [1] &quot;x&quot; &quot;y&quot; colnames(df) ## [1] &quot;x&quot; &quot;y&quot; rownames(df) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; colnames(df) は names(df) と同じである. 4.5.1 データフレイムの演算 データフレイムは行列でもあるので, 注意があるが 行列での演算がほとんどそのまま利用できる. rbind(df, c(3,&quot;a&quot;)) ## x y ## 1 -0.85909285708271 a ## 2 -1.36744485431212 b ## 3 -0.273776565630475 c ## 4 -0.478824167084888 d ## 5 -0.312628465883223 e ## 6 -0.629098232725711 f ## 7 0.791986795006527 g ## 8 0.185618678382722 h ## 9 -2.6008131015349 i ## 10 1.39208288143789 j ## 11 3 a cbind(df,z=runif(10)) ## x y z ## 1 -0.8590929 a 0.04574575 ## 2 -1.3674449 b 0.81958309 ## 3 -0.2737766 c 0.73691148 ## 4 -0.4788242 d 0.92400877 ## 5 -0.3126285 e 0.10133997 ## 6 -0.6290982 f 0.63315593 ## 7 0.7919868 g 0.88698844 ## 8 0.1856187 h 0.07319147 ## 9 -2.6008131 i 0.90465416 ## 10 1.3920829 j 0.83563112 転置行列は行列として出力可能である. 以下のようにデータフレイムに因子ベクトルが含まれていたら全て文字列になる. t(df) ## [,1] [,2] [,3] [,4] [,5] ## x &quot;-0.8590929&quot; &quot;-1.3674449&quot; &quot;-0.2737766&quot; &quot;-0.4788242&quot; &quot;-0.3126285&quot; ## y &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; ## [,6] [,7] [,8] [,9] [,10] ## x &quot;-0.6290982&quot; &quot; 0.7919868&quot; &quot; 0.1856187&quot; &quot;-2.6008131&quot; &quot; 1.3920829&quot; ## y &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; データフレイムの構成ベクトルがすべて論理値もしくは数値のとき, 同じ行数と列数のデータフレイムの要素ごとの四則演算は可能である. ただし, 通常の行列演算を実施するには, 行列に変換しなければならない. また データフレイムの構成ベクトルがすべて論理値もしくは数値のとき, 列ごとの合計, 行ごとの合計が可能である. dff&lt;-data.frame(a=1:5,b=c(TRUE, TRUE, TRUE, FALSE,FALSE)) colSums(dff) ## a b ## 15 3 rowSums(dff) ## [1] 2 3 4 4 5 返り値はベクトルになる. 行列のすべての要素を足すには sum でよい. sum(dff) ## [1] 18 また列ごとの平均, 行ごとの平均は以下を実施する. colMeans(dff) ## a b ## 3.0 0.6 rowMeans(dff) ## [1] 1.0 1.5 2.0 2.0 2.5 4.5.2 データフレイムのアクセス データのアクセスとして, ベクトルのように一つのカギカッコで取り出すと以下のようになる. df[&quot;x&quot;] ## x ## 1 -0.8590929 ## 2 -1.3674449 ## 3 -0.2737766 ## 4 -0.4788242 ## 5 -0.3126285 ## 6 -0.6290982 ## 7 0.7919868 ## 8 0.1856187 ## 9 -2.6008131 ## 10 1.3920829 他にも df[1] でもよいが, いずれにせよデータフレイムとして取り出されてしまう. ベクトルとして取り出すには以下を実施する. df$x ## [1] -0.8590929 -1.3674449 -0.2737766 -0.4788242 -0.3126285 -0.6290982 ## [7] 0.7919868 0.1856187 -2.6008131 1.3920829 他にも df[[&quot;x&quot;]], df[[1]], df[,&quot;x&quot;], df[,1] でもよい. ある変数 $x$ の5番目の要素を取り出して別の値100`を代入するには以下のようにする. df$x[5] &lt;- 100 他にも df[[&quot;x&quot;]][5], df[[1]][5], df[5,&quot;x&quot;], df[5,1] でもよい. データフレイムのある変数の平均値を求めるには次のようにする. mean(df$x) ## [1] 9.616064 もしくは以下とする. with(df, mean(x)) ## [1] 9.616064 他にも attach(df) を使うやり方もあるが, 現在では推奨されない. なおリストの要素を消すには以下のようにする. df$x &lt;- NULL "],
["05-datainput.html", "5 データ入力 5.1 はじめに 5.2 csv ファイル 5.3 EXCEL ファイル 5.4 STATA 5.5 R に入っているデータ 5.6 インターネットからデータ入力 5.7 その他のデータ入力", " 5 データ入力 library(tidyverse) 5.1 はじめに R においてデータ分析をおこなうには データ入力する必要がある. データについてがR やパッケージに入っている場合があるが, 多くは外部ファイルを取り込むことになる. 読み込まれたデータはRではデータフレイム (dataframe) となる. データフレイムは同じ長さのベクトルを組み合わせたリストのことである. たてばデータフレイムは次のようにして作られる. df &lt;- data.frame(x = rnorm(10), y = letters[1:10]) ただデータフレイムは自動的に文字列が因子ベクトルに変換されてしまう. これを避けるには次のように stringsAsFactors= FALSE をつける. df &lt;- data.frame(x = rnorm(10), y = letters[1:10], stringsAsFactors= FALSE) str(df) ## &#39;data.frame&#39;: 10 obs. of 2 variables: ## $ x: num -2.398 -0.43 -0.199 0.512 -2.598 ... ## $ y: chr &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ... もしくはライブラリ dplyr にある data_frame を用いれば, そのようなオプションを付けることなくデータフレイムを拡張したクラスを作ることができる. library(dplyr) df &lt;- data_frame(x = rnorm(10), y = letters[1:10]) str(df) ## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 10 obs. of 2 variables: ## $ x: num 0.638 -0.476 -0.235 -0.62 -0.111 ... ## $ y: chr &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ... 外部ファイルから入力するさいには getwd() で現在のワークングディレクトリとファイルが一致しているかどうかを確認しなければならない. もし一致していないのなら setwd で変更する必要がある. また RStudio はメニューバーの File から Import Dataset からインタラクティブに外部ファイルが入力可能である. いったんこれで入力したとしても, history ペインでどのようなコマンドを実行したかを確認して, 次回も実行できるよう記録しておくとよい. 5.2 csv ファイル csv ファイルの csv とは comma separated variable の略で, その名の通りコンマでわけられた変数が以下のようなテキストファイルである. var1, var2, var3 3, 4,&quot;text&quot; 4, 4, &quot;text&quot; ... 最初の一行は変数名を含まれていることが多いけれど, ない場合もあり事前に確認が必要である. R 以外の計算機で作成した結果を csv で保存しておけば, それを R に取り込むことができる. csv ファイルをRに取り込むには関数 raed.table を使うのが基本である. df &lt;- read.table(&quot;data.csv&quot;, header=TRUE, sep = &quot;,&quot;) こうすればオブジェクト df にデータフレイムとして導入される. 関数 read.csv を使えば, 以上のオプションを付ける必要がない. df &lt;- read.table(&quot;data.csv&quot;) 外部からファイルを取り込んだ場合, 文字列は自動的に因子ベクトルに変換されてしまう. これを避けるには次のようにオプションをつける必要がある. df &lt;- read.table(&quot;data.csv&quot;, stringsAsFactors= FALSE) ファイルを書き込むときには次のようにする. write.csv(df,&quot;data.csv&quot;, row.names = FALSE) このオプションはファイルの一列目に rownames が書き込まれるのを避けるための設定である. もしくはライブラリ readr を導入する. ファイルの読み込みは以下となる. library(readr) df &lt;- read_csv(&quot;data.csv&quot;) 特にオプションをつけなくても, 文字列は自動的に因子ベクトルに変換されない. ファイルの書き込みは以下となる. write_csv(df,&quot;data.csv&quot;) 特にオプションをつけなくても, rownames は書き込まない. 5.3 EXCEL ファイル EXCELはビジネスにおいてデファクトスタンダードになっているスプレッドシートソフトウェアである. R は EXCEL のデータを扱うことができる. 最近のEXCELデータの拡張子は xlsx である. これを導入するにはライブラリ readxl を使えばよい. library(readxl) df &lt;- read_excel(&quot;data.xlsx&quot;,1) ファイルdata.xls の一枚目のシートを意味する. 直接シート名を指定することができる. read_excel(&quot;data.xlsx&quot;,&quot;Revenues&quot;) こちらは「Revenues」という名前のシートを意味する. EXCELから入力するときには, 一行目を変数名にして, 列ごとに変数を揃えておかなければならない. 最終行に合計などがあれば, それも変数として入力してしまうので, 注意が必要である. またEXCELからcsvファイルに変換して, ファイルを読み込ませる方法がある. これは2点ほど注意が必要である. まず EXCEL で桁をしめすコンマのまま保存すると文字列として保存されてしまう. そうしたファイルを read.csv で読み込む数値でなく⽂字列として読み込まれてしまう . それを避けるには , 桁を示すコンマを無しに直して保存しなければならない. なお read_csv をもちいるなら数値として読み込んでくれる また変数名をアルファベットのみにしておいたほうがトラブルが少ない . 日本語が含まれている場合に , EXCEL 上 で csv 形式に変換して保存したときにシフト JIS で保存されてしまう . Linux や Mac では文字コードをUTF-8 にしているので そのままの読み込みだと⽇本語が⽂字化けになる . Windows でも RStudio を導入したときに最初に文字コードを UTF-8 に設定していたのなら同じように文字化けになる. それを防ぐためには , read.csv を用いるときは df &lt;- read.csv(&quot;data.csv&quot;, stringAsFactors=FALSE, fileEncoding=&quot;SJIS&quot;) として, read_csv を用いるときは df &lt;- read_csv(&quot;data.csv&quot;, locale=locale(encoding = &quot;SJIS&quot;)) とする必要がある. 私の使った印象だとライブラリ readxl は賢く日本語を扱ってくれっるので, 日本語が含まれている場合, csv に変換せず, そのまま入力したほうがよい. 5.4 STATA Stata は多くの経済学者が実証分析に用いている統計パッケージである. R は Stata のデータを扱うことができる. Stata のデータは拡張子 dta で保存されている. これを導入するにはライブラリ foreign を用いる. library(foreign) df &lt;- read.dta(&quot;data.dta&quot;) ただ, 最新のstataには対応していない. 最新のstataに対応するにはライブラリ haven を導入する. library(haven) df &lt;- read_dta(&quot;data.dta&quot;) 他にも SAS や SPSS などの統計パッケージのデータも取り込むことができる. 5.5 R に入っているデータ R およびパッケージにはいくつかのデータがはいっている. どのようなデータが利用可能課は以下のコマンドで調べくことができる. data() それがどのような変数が含まれているのかを調べるには, help を使えばよい. help(cars) パッケージのデータは関数 data をつかって利用可能になる. library(AER) ## 要求されたパッケージ car をロード中です ## ## 次のパッケージを付け加えます: &#39;car&#39; ## 以下のオブジェクトは &#39;package:dplyr&#39; からマスクされています: ## ## recode ## 以下のオブジェクトは &#39;package:purrr&#39; からマスクされています: ## ## some ## 要求されたパッケージ lmtest をロード中です ## 要求されたパッケージ zoo をロード中です ## ## 次のパッケージを付け加えます: &#39;zoo&#39; ## 以下のオブジェクトは &#39;package:base&#39; からマスクされています: ## ## as.Date, as.Date.numeric ## 要求されたパッケージ sandwich をロード中です ## 要求されたパッケージ survival をロード中です data(CPS1985) summary(CPS1985) ## wage education experience age ## Min. : 1.000 Min. : 2.00 Min. : 0.00 Min. :18.00 ## 1st Qu.: 5.250 1st Qu.:12.00 1st Qu.: 8.00 1st Qu.:28.00 ## Median : 7.780 Median :12.00 Median :15.00 Median :35.00 ## Mean : 9.024 Mean :13.02 Mean :17.82 Mean :36.83 ## 3rd Qu.:11.250 3rd Qu.:15.00 3rd Qu.:26.00 3rd Qu.:44.00 ## Max. :44.500 Max. :18.00 Max. :55.00 Max. :64.00 ## ethnicity region gender occupation ## cauc :440 south:156 male :289 worker :156 ## hispanic: 27 other:378 female:245 technical :105 ## other : 67 services : 83 ## office : 97 ## sales : 38 ## management: 55 ## sector union married ## manufacturing: 99 no :438 no :184 ## construction : 24 yes: 96 yes:350 ## other :411 ## ## ## 5.6 インターネットからデータ入力 またWebスクレイピングをしてインターネットのサイトから直接入手できる. 幾つかのデータベースでは api が公開されて, それにもとづいてパッケージが作成されている. yahoo finance (quantmod) yahoo finance Japan (RFinanceYJ) World Development Indicators (WDI) Eurostat (eurostat) e-stat (estatap) また直接, インターネットのファイルをダウンロードすることもできる. library(haven) URL &lt;- &quot;http://fmwww.bc.edu/ec-p/data/wooldridge/attend.dta&quot; df &lt;-read_dta(URL) もし一旦ファイルとして保存しておくなら以下のように実施する. if(!file.exists(&quot;mroz.dta&quot;)) download.file(URL, &quot;mroz.dta&quot;,method=&quot;curl&quot;) library(haven) df &lt;- read_dta(&quot;mroz.dta&quot;) 5.7 その他のデータ入力 Rのバイナルファイルとして保存していれば, それを読み込むことができる. ただ私はほとんど利用したことがない. 他にもリレーショナルデータベースにアクセスして, データを入手できる. これも私はほとんど利用したことがない. "],
["06-datawrangling.html", "6 整然データ 6.1 データ整形 6.2 データ結合 6.3 tidyr 6.4 実践例", " 6 整然データ http://r4ds.had.co.nz/tidy-data.html データが整然 (tidy) であるとは次の条件を満たすデータのことである. 個々の変数 (variable) が1つの列 (column) である 個々の観測 (observation) が1つの行 (row) である 個々の値 (value) が1つのセル (cell) である これをこのようなデータを使って, データを整形する方法, またはそうしたデータにする方法を紹介する. ここでは以下のライブラリに全面に依存する. library(tidyverse) ## Loading tidyverse: ggplot2 ## Loading tidyverse: tibble ## Loading tidyverse: tidyr ## Loading tidyverse: readr ## Loading tidyverse: purrr ## Loading tidyverse: dplyr ## Conflicts with tidy packages ---------------------------------------------- ## filter(): dplyr, stats ## lag(): dplyr, stats 特に dplyr と tidyr を用いる. 6.1 データ整形 データセット mtcars を取り扱う. この最初の6つを見るには以下を実施する. mtcars %&gt;% head() ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 ここで %&gt;% はパイプ処理といって, head(mtcars) と同じ効果をもたらす. 括弧が重複する場合, こちらのほうがわかりやすい. ライブラリ dplyr でデータフレイムの処理が簡単になる. select で変数を選択できる. mtcars %&gt;% select(mpg, disp) %&gt;% head() ## mpg disp ## Mazda RX4 21.0 160 ## Mazda RX4 Wag 21.0 160 ## Datsun 710 22.8 108 ## Hornet 4 Drive 21.4 258 ## Hornet Sportabout 18.7 360 ## Valiant 18.1 225 filter により条件に応じた抽出ができる. mtcars %&gt;% select(mpg, disp) %&gt;% filter(disp &gt; 300) %&gt;% head() ## mpg disp ## 1 18.7 360 ## 2 14.3 360 ## 3 10.4 472 ## 4 10.4 460 ## 5 14.7 440 ## 6 15.5 318 rename により変数名を変更することができる. 日本語でも一応対応している. mtcars %&gt;% select(mpg, disp) %&gt;% rename(速度 =mpg, 距離 =disp) %&gt;% head() ## 速度 距離 ## Mazda RX4 21.0 160 ## Mazda RX4 Wag 21.0 160 ## Datsun 710 22.8 108 ## Hornet 4 Drive 21.4 258 ## Hornet Sportabout 18.7 360 ## Valiant 18.1 225 arrange により順序を変更できる. mtcars %&gt;% select(mpg, disp) %&gt;% arrange(mpg) %&gt;% head() ## mpg disp ## 1 10.4 472 ## 2 10.4 460 ## 3 13.3 350 ## 4 14.3 360 ## 5 14.7 440 ## 6 15.0 301 逆順には以下のようにすればよい. mtcars %&gt;% select(mpg, disp) %&gt;% arrange(desc(mpg)) %&gt;% head() ## mpg disp ## 1 33.9 71.1 ## 2 32.4 78.7 ## 3 30.4 75.7 ## 4 30.4 95.1 ## 5 27.3 79.0 ## 6 26.0 120.3 新しい変数を作成するには以下のように mutate を用いる. mtcars %&gt;% select(mpg) %&gt;% mutate(gpm = 1/mpg) %&gt;% head() ## mpg gpm ## 1 21.0 0.04761905 ## 2 21.0 0.04761905 ## 3 22.8 0.04385965 ## 4 21.4 0.04672897 ## 5 18.7 0.05347594 ## 6 18.1 0.05524862 以下は20より大きいとTRUE, そうでないと FALSE をとる変数を作成している. mtcars %&gt;% select(mpg) %&gt;% mutate(binarympg = ifelse(mpg&gt;20,TRUE,FALSE)) %&gt;% head() ## mpg binarympg ## 1 21.0 TRUE ## 2 21.0 TRUE ## 3 22.8 TRUE ## 4 21.4 TRUE ## 5 18.7 FALSE ## 6 18.1 FALSE summarize により変数の基本統計表を作成できる. mtcars %&gt;% summarize(avg = mean(mpg), sd =sd(mpg)) ## avg sd ## 1 20.09062 6.026948 group_by と summarize を組み合わせてグループごとの基本統計量も作成できる. mtcars %&gt;% group_by(cyl) %&gt;% summarize(n = n(), avg = mean(mpg), sd =sd(mpg)) ## # A tibble: 3 x 4 ## cyl n avg sd ## &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 4 11 26.66364 4.509828 ## 2 6 7 19.74286 1.453567 ## 3 8 14 15.10000 2.560048 6.2 データ結合 dplyr 2つのデータフレイムを結合する便利なコマンドがある. 列の追加は bind_rows を用いる. df1 &lt;- data_frame(X=1:2, Y=1:2) df2 &lt;- data_frame(X=4, Y=4) bind_rows(df1,df2) ## # A tibble: 3 x 2 ## X Y ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 ## 2 2 2 ## 3 4 4 行の追加は bind_rows を用いる. df3 &lt;- data_frame(Z=5:6) bind_cols(df1,df3) ## # A tibble: 2 x 3 ## X Y Z ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 1 5 ## 2 2 2 6 2つのデータフレイムで共通部分を用いて結合させるには4つのやり方がある. dfx &lt;- data_frame(id=c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;), X=1:3) dfy &lt;- data_frame(id=c(&quot;A&quot;,&quot;B&quot;,&quot;D&quot;), Y=c(TRUE,FALSE,TRUE)) 左側の dfx がすべて残るように結合するには, left_join を実行する. left_join(dfx,dfy,by=&quot;id&quot;) ## # A tibble: 3 x 3 ## id X Y ## &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; ## 1 A 1 TRUE ## 2 B 2 FALSE ## 3 C 3 NA 右側の dfx がすべて残るように結合するには, right_join を実行する. right_join(dfx,dfy,by=&quot;id&quot;) ## # A tibble: 3 x 3 ## id X Y ## &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; ## 1 A 1 TRUE ## 2 B 2 FALSE ## 3 D NA TRUE 両方がすべて残るように結合するには, full_join を実行する. full_join(dfx,dfy,by=&quot;id&quot;) ## # A tibble: 4 x 3 ## id X Y ## &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; ## 1 A 1 TRUE ## 2 B 2 FALSE ## 3 C 3 NA ## 4 D NA TRUE 両方にある行のみ残して結合するには, inner_join を実行する. inner_join(dfx,dfy,by=&quot;id&quot;) ## # A tibble: 2 x 3 ## id X Y ## &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; ## 1 A 1 TRUE ## 2 B 2 FALSE 6.3 tidyr 以下のデータセットを考える. df &lt;- data_frame( time = 2010:2014, X = rnorm(5, 0, 1), Y = rnorm(5, 0, 2), Z = rnorm(5, 0, 4) ) df ## # A tibble: 5 x 4 ## time X Y Z ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2010 -0.8836525 3.3211008 2.1807797 ## 2 2011 -1.5873558 1.5285498 -0.3560135 ## 3 2012 -0.3456018 -4.0260267 -0.1229725 ## 4 2013 0.6748653 0.5894253 5.2754334 ## 5 2014 -0.2541605 0.7876047 2.2398179 それぞれの変数名をキーとして, 値を示した表は gather で作れる. df_gather &lt;- df %&gt;% gather(key,value,-time) df_gather ## # A tibble: 15 x 3 ## time key value ## &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2010 X -0.8836525 ## 2 2011 X -1.5873558 ## 3 2012 X -0.3456018 ## 4 2013 X 0.6748653 ## 5 2014 X -0.2541605 ## 6 2010 Y 3.3211008 ## 7 2011 Y 1.5285498 ## 8 2012 Y -4.0260267 ## 9 2013 Y 0.5894253 ## 10 2014 Y 0.7876047 ## 11 2010 Z 2.1807797 ## 12 2011 Z -0.3560135 ## 13 2012 Z -0.1229725 ## 14 2013 Z 5.2754334 ## 15 2014 Z 2.2398179 spread でもとに戻ることができる. df_gather %&gt;% spread(key, value) ## # A tibble: 5 x 4 ## time X Y Z ## * &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2010 -0.8836525 3.3211008 2.1807797 ## 2 2011 -1.5873558 1.5285498 -0.3560135 ## 3 2012 -0.3456018 -4.0260267 -0.1229725 ## 4 2013 0.6748653 0.5894253 5.2754334 ## 5 2014 -0.2541605 0.7876047 2.2398179 spread で time にすると別の形で展開できる. df_spread &lt;- df_gather %&gt;% spread(time, value) df_spread ## # A tibble: 3 x 6 ## key `2010` `2011` `2012` `2013` `2014` ## * &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 X -0.8836525 -1.5873558 -0.3456018 0.6748653 -0.2541605 ## 2 Y 3.3211008 1.5285498 -4.0260267 0.5894253 0.7876047 ## 3 Z 2.1807797 -0.3560135 -0.1229725 5.2754334 2.2398179 以下のようにすればもとに戻る. df_spread %&gt;% gather(time,value,-key) ## # A tibble: 15 x 3 ## key time value ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 X 2010 -0.8836525 ## 2 Y 2010 3.3211008 ## 3 Z 2010 2.1807797 ## 4 X 2011 -1.5873558 ## 5 Y 2011 1.5285498 ## 6 Z 2011 -0.3560135 ## 7 X 2012 -0.3456018 ## 8 Y 2012 -4.0260267 ## 9 Z 2012 -0.1229725 ## 10 X 2013 0.6748653 ## 11 Y 2013 0.5894253 ## 12 Z 2013 5.2754334 ## 13 X 2014 -0.2541605 ## 14 Y 2014 0.7876047 ## 15 Z 2014 2.2398179 gather をうまく使えば変数ごとの基本統計量の表を作ることができる. cars %&gt;% gather(variable,value) %&gt;% group_by(variable) %&gt;% summarize(nobs = n(), avg = mean(value), sd =sd(value)) ## # A tibble: 2 x 4 ## variable nobs avg sd ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 dist 50 42.98 25.769377 ## 2 speed 50 15.40 5.287644 日本語だと次のようにすればよい. tab &lt;- cars %&gt;% rename(距離=dist,速度=speed ) %&gt;% gather(変数,value) %&gt;% group_by(変数) %&gt;% summarize(観測数 = n(), 平均 = mean(value), 標準偏差 =sd(value)) head(tab) ## # A tibble: 2 x 4 ## 変数 観測数 平均 標準偏差 ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 距離 50 42.98 25.769377 ## 2 速度 50 15.40 5.287644 6.4 実践例 tidyr を用いた別の例をみてみよう. 横軸を年としたデータセット df がある. df &lt;- data_frame(name=letters, &quot;2010&quot;=rnorm(26),&quot;2011&quot;=rnorm(26),&quot;2012&quot;=rnorm(26)) head(df) ## # A tibble: 6 x 4 ## name `2010` `2011` `2012` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 a 0.665900887 -1.4570771 1.8619019 ## 2 b 0.779040048 1.3303049 0.6278156 ## 3 c -0.650140250 1.1360588 0.5879385 ## 4 d 1.046370478 1.1994111 0.1930334 ## 5 e 0.768785804 -0.5035934 -1.4707854 ## 6 f -0.002939387 -0.9628309 0.1312938 data.frame でないことに注意されたい. また, 年ごとのデータセット df_2010, df_2011, df_2012 が3つある. df_2010 &lt;- data_frame(name=letters,runif=runif(26)) df_2011 &lt;- data_frame(name=letters,runif=runif(26)) df_2012 &lt;- data_frame(name=letters,runif=runif(26)) これら4つのデータセットを1つにまとめよう. まずデータ df についてであるが, gather をつかう. df_rnorm &lt;- df %&gt;% gather(time,rnorm,-name) %&gt;% mutate(time=as.numeric(time)) head(df_rnorm) ## # A tibble: 6 x 3 ## name time rnorm ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 a 2010 0.665900887 ## 2 b 2010 0.779040048 ## 3 c 2010 -0.650140250 ## 4 d 2010 1.046370478 ## 5 e 2010 0.768785804 ## 6 f 2010 -0.002939387 時間の変数を数値に変換している. データセット df_2010, df_2011, df_2012 をつなげる. df_runif &lt;- bind_rows(df_2010,df_2011,df_2012) %&gt;% bind_cols(time=rep(2010:2012,each=26)) head(df_runif) ## # A tibble: 6 x 3 ## name runif time ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 a 0.80417414 2010 ## 2 b 0.25425828 2010 ## 3 c 0.96478171 2010 ## 4 d 0.03206685 2010 ## 5 e 0.91033079 2010 ## 6 f 0.13780703 2010 それぞれの年の変数を付け加えている. これを full_join を用いてつなげる. df_full &lt;- full_join(df_rnorm,df_runif,by=c(&quot;name&quot;,&quot;time&quot;)) head(df_full) ## # A tibble: 6 x 4 ## name time rnorm runif ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 a 2010 0.665900887 0.80417414 ## 2 b 2010 0.779040048 0.25425828 ## 3 c 2010 -0.650140250 0.96478171 ## 4 d 2010 1.046370478 0.03206685 ## 5 e 2010 0.768785804 0.91033079 ## 6 f 2010 -0.002939387 0.13780703 "],
["07-regression.html", "7 回帰分析 7.1 単回帰モデル 7.2 重回帰モデル 7.3 最小二乗推定量のための仮定について", " 7 回帰分析 仮想的に以下のようにデータを生成する. N &lt;- 100 x&lt;-runif(N) w&lt;-sample(c(&quot;H&quot;,&quot;T&quot;),N,replace=TRUE) y &lt;- 10 + 2*x + ifelse(w==&quot;H&quot;,1,0) + rnorm(N) df &lt;- data.frame(w,x,y) plot(y~x) 7.1 単回帰モデル 次の単回帰モデルを考えてる. \\(x\\) は説明変数で, \\(y\\) は被説明変数である. \\(u\\) は誤差項である. パラメータとして \\(\\alpha\\) は切片パラメータ, \\(\\beta\\) は傾きパラメータである. \\[ y = \\alpha + \\beta x + u \\] 暗黙に次の仮定を置いている. \\((x_i,y_i)\\) は独立同一分布にしたがう. \\(E[u_i]=0\\) である. \\(u_i\\) と \\(x_i\\) は独立である. \\(u_i\\) は正規分布にしたがう. このとき最小二乗推定量は一致で, 不偏であり, 正規分布にしたがう. 一致とは推定量が観測値を増やすことによって真のパラメータに (確率) 収束することある. 不偏とは推定量の期待値が真のパラメータになることである. また他の線形不偏推定量のなかで最も分散が小さいことも知られている. R で回帰分析を実施するには lm を実施する. fm &lt;- lm(y ~ x, data=df) fm 自体はリストであり, 以下の要素がある. typeof(fm) ## [1] &quot;list&quot; names(fm) ## [1] &quot;coefficients&quot; &quot;residuals&quot; &quot;effects&quot; &quot;rank&quot; ## [5] &quot;fitted.values&quot; &quot;assign&quot; &quot;qr&quot; &quot;df.residual&quot; ## [9] &quot;xlevels&quot; &quot;call&quot; &quot;terms&quot; &quot;model&quot; 係数は次のコマンドを実施する. coef(fm) ## (Intercept) x ## 10.832887 1.332382 # coefficients(fm) 作図すると以下のようになる. plot(y~x,data=df) abline(fm) 残差は次のコマンドを実施する. head(resid(fm)) ## 1 2 3 4 5 6 ## -0.65517848 -1.72860253 0.09968133 0.98191310 0.51084050 0.74994725 # residuals(fm) # with(fm, residuals) 予測値は次のコマンドを実施する. head(fitted(fm)) ## 1 2 3 4 5 6 ## 11.33972 11.28127 10.85670 11.60313 12.09374 11.95589 # fitted.values(fm) # with(fm, fitted.values) 残差自乗和は次のコマンドを実施する. deviance(fm) ## [1] 86.61579 sum(resid(fm)^2) ## [1] 86.61579 7.1.1 ティー検定 その結果を見るには summary を実施する. summary(fm) ## ## Call: ## lm(formula = y ~ x, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -2.37912 -0.63194 0.05035 0.62633 2.49817 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 10.8329 0.1935 55.984 &lt; 2e-16 *** ## x 1.3324 0.3192 4.174 6.48e-05 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.9401 on 98 degrees of freedom ## Multiple R-squared: 0.151, Adjusted R-squared: 0.1423 ## F-statistic: 17.42 on 1 and 98 DF, p-value: 6.481e-05 これをみれば各変数の係数がゼロのティー検定も可能である. 他にも, 残差標準誤差, 決定係数, 修正済み決定係数, 全ての係数がゼロであるF検定も可能である. summary(fm) もリストであり, それぞれの要素は以下である. typeof(summary(fm)) ## [1] &quot;list&quot; names(summary(fm)) ## [1] &quot;call&quot; &quot;terms&quot; &quot;residuals&quot; &quot;coefficients&quot; ## [5] &quot;aliased&quot; &quot;sigma&quot; &quot;df&quot; &quot;r.squared&quot; ## [9] &quot;adj.r.squared&quot; &quot;fstatistic&quot; &quot;cov.unscaled&quot; 単なる fm と同じ名前もあるが, 中身が違っている場合もある. 例えば residuals は同じであるが, 係数はより情報が加わっている. coef(summary(fm)) ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 10.832887 0.1934988 55.984258 3.282385e-76 ## x 1.332382 0.3191955 4.174188 6.481267e-05 # coefficients(summary(fm)) 残差の標準誤差 sqrt(deviance(fm)/df.residual(fm)) ## [1] 0.9401248 with(summary(fm),sigma) ## [1] 0.9401248 決定係数は次のようにして計算する. 1-deviance(fm)/with(df, sum((y-mean(y))^2)) ## [1] 0.1509553 with(summary(fm),r.squared) ## [1] 0.1509553 調整済み決定係数は次のようにして計算する. 1-(deviance(fm)/df.residual(fm))/with(df, sum((y-mean(y))^2/(nrow(df)-1))) ## [1] 0.1422916 with(summary(fm),adj.r.squared) ## [1] 0.1422916 7.1.2 対数変換 次のモデルを考える. \\[ y = \\alpha + \\beta \\log(x) + u \\] 対数変換をおこなう場合, log を用いるとよい. fm &lt;- lm(y~log(x),data=df) summary(fm) ## ## Call: ## lm(formula = y ~ log(x), data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -2.27379 -0.63531 -0.03501 0.69479 2.47561 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 11.8944 0.1336 89.023 &lt; 2e-16 *** ## log(x) 0.3890 0.1025 3.796 0.000255 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.9527 on 98 degrees of freedom ## Multiple R-squared: 0.1282, Adjusted R-squared: 0.1193 ## F-statistic: 14.41 on 1 and 98 DF, p-value: 0.0002552 作図すると以下のようになる. plot(y~log(x),data=df) abline(fm) 被説明変数が対数の場合も同様である. fm &lt;- lm(log(y)~x,data=df) summary(fm) ## ## Call: ## lm(formula = log(y) ~ x, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.242424 -0.053172 0.008385 0.053277 0.208899 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 2.37944 0.01696 140.309 &lt; 2e-16 *** ## x 0.11775 0.02797 4.209 5.69e-05 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.08239 on 98 degrees of freedom ## Multiple R-squared: 0.1531, Adjusted R-squared: 0.1445 ## F-statistic: 17.72 on 1 and 98 DF, p-value: 5.688e-05 作図すると以下のようになる. plot(log(y)~x,data=df) abline(fm) 7.1.3 切片なし回帰モデル 次のモデルを考える. \\[ y = \\beta x + u \\] 切片なしモデルを推定したい場合は次のように -1 とする. fm &lt;- lm(y~x-1,data=df) summary(fm) ## ## Call: ## lm(formula = y ~ x - 1, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -5.454 -1.660 2.885 6.192 11.829 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## x 16.9514 0.8861 19.13 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 5.372 on 99 degrees of freedom ## Multiple R-squared: 0.7871, Adjusted R-squared: 0.7849 ## F-statistic: 365.9 on 1 and 99 DF, p-value: &lt; 2.2e-16 もしくは +0 を加える. fm &lt;- lm(y~x+0,data=df) summary(fm) ## ## Call: ## lm(formula = y ~ x + 0, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -5.454 -1.660 2.885 6.192 11.829 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## x 16.9514 0.8861 19.13 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 5.372 on 99 degrees of freedom ## Multiple R-squared: 0.7871, Adjusted R-squared: 0.7849 ## F-statistic: 365.9 on 1 and 99 DF, p-value: &lt; 2.2e-16 7.2 重回帰モデル 説明変数として \\(w\\) を加えたモデルを考える. \\[ y = \\alpha + \\beta x +\\gamma w+ u \\] 暗黙に次の仮定を置いている. \\((w_i, x_i,y_i)\\) は独立同一分布にしたがう. \\(E[u_i]=0\\) である. \\(u_i\\) と \\((x_i, w_i)\\) は独立である. \\(u_i\\) は正規分布にしたがう. 多重共線性は存在しない. つまり \\(x_i\\) は \\(w_i\\) の一次変換で表せない. 説明変数を加えたいときには + と変数名を使うことができる. fm &lt;- lm(y~x+w,data=df) summary(fm) ## ## Call: ## lm(formula = y ~ x + w, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -2.59803 -0.64957 0.00347 0.50105 2.27949 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 11.0522 0.2068 53.432 &lt; 2e-16 *** ## x 1.3261 0.3105 4.270 4.55e-05 *** ## wT -0.4695 0.1835 -2.558 0.0121 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.9146 on 97 degrees of freedom ## Multiple R-squared: 0.2046, Adjusted R-squared: 0.1882 ## F-statistic: 12.48 on 2 and 97 DF, p-value: 1.506e-05 R の特徴は因子もとくに変換することなくダミー変数として扱える. 7.2.1 自乗項 説明変数として自乗項を加えたモデルを考える. \\[ y = \\alpha + \\beta x + \\gamma x^2 + u \\] R では単に自乗するのでなく I(x^2) としなければならない. fm &lt;- lm(y~x+I(x^2),data=df) summary(fm) ## ## Call: ## lm(formula = y ~ x + I(x^2), data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -2.43708 -0.61107 0.04124 0.59306 2.45423 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 10.9183 0.2990 36.513 &lt;2e-16 *** ## x 0.8574 1.3032 0.658 0.512 ## I(x^2) 0.4523 1.2028 0.376 0.708 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.9443 on 97 degrees of freedom ## Multiple R-squared: 0.1522, Adjusted R-squared: 0.1347 ## F-statistic: 8.706 on 2 and 97 DF, p-value: 0.000333 7.2.2 交差項 説明変数として交差項を加えたモデルを考える. \\[ y = \\alpha + \\beta x + \\gamma w + \\delta xw + u \\] 説明変数 x と wの自乗項は自乗項は x:w である. fm&lt;-lm(y~x+w+x:w,data=df) summary(fm) ## ## Call: ## lm(formula = y ~ x + w + x:w, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -2.59237 -0.65249 0.00366 0.50031 2.28472 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 11.04578 0.26103 42.315 &lt; 2e-16 *** ## x 1.33812 0.43064 3.107 0.00248 ** ## wT -0.45607 0.37895 -1.204 0.23174 ## x:wT -0.02532 0.62511 -0.040 0.96778 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.9194 on 96 degrees of freedom ## Multiple R-squared: 0.2046, Adjusted R-squared: 0.1798 ## F-statistic: 8.233 on 3 and 96 DF, p-value: 6.244e-05 もしくは以下のように * を使って簡便的に表せる. fm &lt;- lm(y~x*w,data=df) summary(fm) ## ## Call: ## lm(formula = y ~ x * w, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -2.59237 -0.65249 0.00366 0.50031 2.28472 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 11.04578 0.26103 42.315 &lt; 2e-16 *** ## x 1.33812 0.43064 3.107 0.00248 ** ## wT -0.45607 0.37895 -1.204 0.23174 ## x:wT -0.02532 0.62511 -0.040 0.96778 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.9194 on 96 degrees of freedom ## Multiple R-squared: 0.2046, Adjusted R-squared: 0.1798 ## F-statistic: 8.233 on 3 and 96 DF, p-value: 6.244e-05 7.2.3 エフ検定 今, 帰無仮説が \\[ y = \\alpha + \\beta x + u \\] で, 対立仮説が \\[ y = \\alpha + \\beta x + \\gamma w + \\delta xw + u \\] となる検定を実施したい. これは複数の係数がゼロであるエフ検定である. コマンド anova を用いればエフ検定できる. fm0 &lt;- lm(y~x,data=df) fm1 &lt;- lm(y~x*w,data=df) anova(fm0,fm1) ## Analysis of Variance Table ## ## Model 1: y ~ x ## Model 2: y ~ x * w ## Res.Df RSS Df Sum of Sq F Pr(&gt;F) ## 1 98 86.616 ## 2 96 81.140 2 5.4761 3.2395 0.04351 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 順番を変えても, 検定統計量自体に変更はない. anova(fm1,fm0) ## Analysis of Variance Table ## ## Model 1: y ~ x * w ## Model 2: y ~ x ## Res.Df RSS Df Sum of Sq F Pr(&gt;F) ## 1 96 81.140 ## 2 98 86.616 -2 -5.4761 3.2395 0.04351 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 またモデルの更新として update を使えば簡単になる場合もある. fm1 &lt;- update(fm0, .~. +w + w:x) anova(fm0,fm1) ## Analysis of Variance Table ## ## Model 1: y ~ x ## Model 2: y ~ x + w + x:w ## Res.Df RSS Df Sum of Sq F Pr(&gt;F) ## 1 98 86.616 ## 2 96 81.140 2 5.4761 3.2395 0.04351 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 7.3 最小二乗推定量のための仮定について 単回帰において以下の仮定を置いていた. \\((x_i,y_i)\\) は独立同一分布にしたがう. \\(E[u_i]=0\\) である. \\(u_i\\) と \\(x_i\\) は独立である. \\(u_i\\) は正規分布にしたがう. 十分な観測値が得られるばあい, \\(u_i\\) が正規分布にしたがっていないくても, 中心極限定理定理より, 最小二乗法推定量は正規分布に近似できる. 7.3.1 ロバスト分散 また \\(u_i\\) と \\(x_i\\) は独立でなく, \\(u_i\\) と \\(x_i\\) が無相関という弱い条件のもとでも, 一致推定量であることが知られている. ただ不偏推定量は保証できない. また 線形推定量のなかで最小の分散とも言えない. 細かく言えば, 独立でなく無相関のとき, 誤差項 \\(u_i\\) の条件付き分散が一定でなくなる. ただし, 別の分散のもとで正規分布に近似できることがしられている.5 つまり, 説明変数と誤差項が無相関であるが, 独立とまでは言い切れない場合, 最小二乗推定量を実行した際, 別の方法で分散を推定する必要がある. この別の分散をロバスト分散という. R でロバスト分散を推定するにはパッケージ AER を導入するのが簡単である. は次のコマンドを実行すればよい. library(AER) coeftest(fm1,vcov=vcovHC) ## ## t test of coefficients: ## ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 11.045784 0.324614 34.0275 &lt; 2.2e-16 *** ## x 1.338115 0.508831 2.6298 0.009952 ** ## wT -0.456074 0.432238 -1.0551 0.294007 ## x:wT -0.025315 0.682563 -0.0371 0.970492 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 先の値と標準誤差が違っていることが確認できるであろう. ただこの値は STATA と少し異なっている. STATA と同じにするには coeftest(fm1,vcov=vcovHC(fm1,type=&quot;HC1&quot;)) ## ## t test of coefficients: ## ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 11.045784 0.312326 35.3662 &lt; 2.2e-16 *** ## x 1.338115 0.489500 2.7336 0.007459 ** ## wT -0.456074 0.417211 -1.0932 0.277063 ## x:wT -0.025315 0.656949 -0.0385 0.969342 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 としなければならない. 7.3.2 分散不均一の検定 誤差項の分散が均一かどうかは検定可能である. 有名な検定方法としてBP検定というものがある. BP検定は帰無仮説が分散均一で, 対立仮説が分散が被説名編数と線形関係になっている場合の検定である. R では以下のように実施すればよい. bptest(fm1) ## ## studentized Breusch-Pagan test ## ## data: fm1 ## BP = 1.7816, df = 3, p-value = 0.619 ここでの例ではP値が5%を超えているので帰無仮説を棄却できないので, 分散均一を仮定してよいことが示唆されている. 残差の自乗を被説明変数として回帰分析をおこない, その決定係数に観測数をかけたものが検定統計量となる. bpt &lt;- lm(I(resid(fm1)^2)~w*x,data=df) (bpt &lt;- nrow(df)*summary(bpt)$r.squared) ## [1] 1.781583 1-pchisq(bpt,df=3) ## [1] 0.6189509 これまでのBPテストは誤差項の分散が説明変数の線形関係あることを暗黙に仮定している. 非線形性を考慮するために説明変数の二次項を導入した分散不均一性の検定をホワイト検定という. 二次項を加えると煩雑になるため, 予測値を使って計算することがある. ホワイトテストは以下で実施する. wht &lt;- lm(I(resid(fm1)^2)~fitted(fm1)+I(fitted(fm1)^2),data=df) (wht &lt;- nrow(df)*summary(wht)$r.squared) ## [1] 1.162315 1-pchisq(wht,df=2) ## [1] 0.5592505 ホワイト検定でも分散均一が示唆されている. このように分散均一性は検定することが可能であるが, そもそも分散均一が疑われる場合は, ロバスト分散で推定するので十分であるため最近の実証分析ではこの検定は実施されない. 正確には観測される変数に4次のモーメントが存在するという仮定が必要となる. この仮定の直感的な意味は異常値が存在しないことである.↩ "]
]
