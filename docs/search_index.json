[
["index.html", "R と RStudio はじめに 0.1 R とは 0.2 R のインストール 0.3 R の設定 0.4 R の使い方", " R と RStudio 宮﨑憲治 2020-10-01 はじめに 0.1 R とは Rは統計・データ解析・統計グラフ作成のためのオープンソースソフトである. 0.2 R のインストール Rをインストールするには https://cran.r-project.org/ にいき, 該当機種のファイルをダウンロードする. ダウンロードしたあとに実行すればインストールされる. Windows の場合, 32bit か 64bit を選択する. 最近のパソコンの CPU は 64bit と考えられるが, どちらかわからなければ 32bit にしておけばよい. Ubuntu なら ppa を使って導入してもよい. sudo add-apt-repository ppa:marutter/rrutter sudo apt-get update sudo apt-get install r-base r-base-dev 0.3 R の設定 設定ファイル .Rprofile をホームディレクトリに作成すれば, 設定を変更できる. ホームディレクトリはユーザー名が kenji のとき, Windows なら通常 C:\\Users\\kenji である. バックスラッシュ \\ は \\(\\yen\\) と読み替えて頂きたい. 最初は .Rprofile を特に作成しなくても大丈夫である. 0.4 R の使い方 Windows だとコマンドプロンプトから R と入力して立ち上げるか, R のアイコンをダブルクリックすると, Rコンソールと言われる画面が現れる. コマンドプロンプトからだと最初の表示が文字化けしている可能性があるが, その後の起動に問題ないはずである. アイコンがなければ, Winキーを押した後, rgui と入力すれば起動できる. Mac や Ubuntu だとターミナルから R と入力して起動できる. 立ち上げた後, コンソールから そこにコマンドを入力すると, その結果が直後に出力される. 終了には q() とする. 作業スペースを保存するかと聞かれたなら, No を意味する n を選択する. コマンド入力中, 最後の括弧を付け忘れたり, 正しく実行ができないときがある. たとえば, rnorm(5 としてEnterキーを押せば, 次の行に + とでてくる. ここでは正しく ) を付けて再度Enterキーを押せば正しく実行されるが, ときにはどれを入力すれば正しく実行されるかわからない一方で, 単にEnterを押すだけだと, 再度入力を求められることがある. そうしたとときは通常左上にあるエスケープキー (ESC) を押せば途中入力がキャンセルされる. R はRコンソールから対話式にコマンドを入力していく方法と, 拡張子 R のスクリプトファイルを実行していくやり方がある. 実行履歴を記録するためにスクリプトファイルを作成していくやり方を推奨する. スクリプトファイル project.R を Rコンソールから実行するには, source(&quot;project.R&quot;) とすればよい. R外部のコマンドプロンプトから実行するには Rscript project.R とすればよい. 起動できないときには, 環境変数の PATH にRの実行ファイルの場所が登録されていない可能性がある. また外部ファイルを導入する際やファイルを外部出力する際には, 現在の作業ディレクトリに気をつけなければならない. 現在の作業ディレクトリの場所はRコンソールから getwd() とすれば, 確認できる. Windows だと通常の表記と異なっていることに注意されたい. 作業ディレクトリの指定は以下のようにする. setwd(PATH) Windows のとき指定の仕方に注意が必要である. たとえば作業ディレクトリが C:\\Users\\kenji\\work\\project のとき, setwd(&quot;C:/Users/kenji/work/project&quot;) となる. バックスラッシュ \\ (\\(\\yen\\)) を スラッシュ / に変更しなければならない. "],
["01-base.html", "1 基本 1.1 電卓としての R 1.2 関数電卓としてのR 1.3 R の型 1.4 変数 1.5 パッケージ", " 1 基本 R の基本として以下の2つのサイトでオンラインで学習することをオススメする. ただし英語である. http://tryr.codeschool.com/ https://www.datacamp.com/courses/free-introduction-to-r また以下の日本語版のチートシートが有用である. https://www.rstudio.com/wp-content/uploads/2016/10/r-cheat-sheet-ja.pdf R についての動画はまず以下を見ていただきたい. http://dotinstall.com/lessons/basic_r 日本語で合計40分くらいで13分割して配信している. 他にも Youtube にいけば他にも多数動画がある. 1.1 電卓としての R R は電卓してとして使える. 数値を扱う算術演算子として以下のものが代表的である. 演算子 説明 例 + 足し算 5 + 2 = 7 - 引き算 5 - 2 = 3 * 掛け算 5 * 2 = 10 / 割り算 5 / 2 = 2.5 ^, ** べき算 5 ^ 2 = 25, 5 ** 2 = 25 %% 割り算の余り 5 %% 2 = 1 %/% 割り算の切り下げ 5 %/% 2 = 2 5 + 2 ## [1] 7 5 - 2 ## [1] 3 5 * 2 ## [1] 10 5 / 2 ## [1] 2.5 5 ^ 2 ## [1] 25 5 ** 2 ## [1] 25 5 %% 2 ## [1] 1 5 %/% 2 ## [1] 2 1.2 関数電卓としてのR R は関数として使える. たとえば以下の関数がある. 関数 説明 sqrt() 平方根 \\(\\sqrt{\\cdot}\\) exp() 指数 log() 対数 factorial() 階乗 choose() 組み合わせ abs() 絶対値 round() 四捨五入 floor() 切り下げ ceiling() 切り上げ sqrt(10) ## [1] 3.162278 exp(10) ## [1] 22026.47 log(10) ## [1] 2.302585 factorial(4) ## [1] 24 choose(4,2) ## [1] 6 abs(-10) ## [1] 10 round(3.5) ## [1] 4 floor(3.5) ## [1] 3 ceiling(3.5) ## [1] 4 関数の括弧に入る数値を引数という. 組み合せを計算する関数 choose の引数は2つある. 複数の引数は , で区切る. 引数の順序は指定すれば変更可能である. choose(4, 2) ## [1] 6 choose(n=4, k=2) ## [1] 6 choose(k=2, n=4) ## [1] 6 また幾つかの引数は入力しなくても. デフォルトで設定してあることがある. それぞれの関数のヘルプを確認されたい. 関数のヘルプはコマンド choose の場合 help(choose) ?choose で調べることができる. 1.3 R の型 Rにおいて値は型 (type) をもち, 型として数値 (numeric) と文字列 (character) と論理値 (logical) など1がある. 多くの言語と違い, あらかじめ宣言する必要なく, 自動的に決定される. 数値には整数 (integer) と, 実数をコンピュータ的に扱っている倍数精度小数 (double) など2がある. 整数か倍数精度小数かは自動的に振り分けられるが, 明示的に数字の後に L をつけて整数を指定することができる. 文字は \" (ダブルクオーテーション) もしくは ' (シングルクォーテーション) で区切られる. TRUE もしくは FALSE を取る値を論理値 (logical) という. 省略して T と F とあわらせることもできるが混乱するので個人的に推奨しない. 値の型は関数 typeof() で確認できる. typeof(3) ## [1] &quot;double&quot; typeof(3L) ## [1] &quot;integer&quot; typeof(&quot;3&quot;) ## [1] &quot;character&quot; typeof(TRUE) ## [1] &quot;logical&quot; typeof(FALSE) ## [1] &quot;logical&quot; typeof(T) ## [1] &quot;logical&quot; typeof(F) ## [1] &quot;logical&quot; 特殊な値として, 無限大を意味する Inf, 非数を意味する NaN, 欠損値を意味する NA , 空を意味する NULL がある. Inf と Nan の型は数値として分類され, NA の型は論理値として分類される. また NULL は NULL という特別な型である. 1/0 ## [1] Inf typeof(1/0) ## [1] &quot;double&quot; 0/0 ## [1] NaN typeof(0/0) ## [1] &quot;double&quot; typeof(NA) ## [1] &quot;logical&quot; typeof(NULL) ## [1] &quot;NULL&quot; 1.4 変数 値は変数 (variable) に代入することによって再利用が可能になる. Rでは代入のことを付値 (assign) といい, 以下のように実行される. x &lt;- 4 4 -&gt; x x = 4 assign(&quot;x&quot;,4) 多くのプログラム言語では3番目のやり方をだけであるが, R では最初のやり方を推奨している.3 代入した値を確認するには単にその変数を入力すればよい. 代入と同時に確認するには丸括弧をつけるとよい. x ## [1] 4 (x&lt;-3) ## [1] 3 付値される変数として, 記号と数字からはじまらなければ, ほぼ自由に作れる. アルファベットについて大文字と小文字が区別されることに注意されたい. また日本語も変数に使えるが, 機種によって文字コードが違うため, 避けて使うほうが望ましい. 扱える変数は if などいくつか4はエラーになるが, pi のようにすでに組み込まれている変数も変更して指定することができる. pi ## [1] 3.141593 pi &lt;- 3 pi ## [1] 3 関数 objects() を使うことで，現在どんなオブジェクトがあるかを調べられる． R は変数や関数を全てオブジェクトとして扱う言語である. また，前に定義したオブジェクトを消す場合 rm() を用いる． すでに組み込まれた変数を上書きした pi を削除するともとの変数が復活する. rm(pi) pi ## [1] 3.141593 さらに，全てのオブジェクトを消す場合は rm(list=ls(all=TRUE)) とすればよい． 1.5 パッケージ R においてパッケージを導入することによって, 機能を拡張させることができる. パッケージ pkg を導入するため一度だけ以下を実行する. install.packages(&quot;pkg&quot;) とする. なおオプション dependencies = TRUE とすれば依存するパッケージを全て導入してくれる. パッケージ pkg が導入していれば, そのパッケージにあるコマンド cmd を実行するには pkg::cmd とパッケージとコマンドの間に :: とする必要がある. もしくは library(pkg) もしくは require(pkg) 予め入力しておけば, 最初の pkg:: を省略することができる. なお複数のパッケージで同じ名前のコマンドがある場合, あとで library もしくは require としたパッケージの方が優先させるので注意されたい. なお library と require に使い方にほとんど違いがないが, require だと以下のように存在しなければインストールするように設定できる. if (!require(lattice)){ install.packages(&quot;lattice&quot;) require(lattice) } ただ私は昔からの癖で library を使っている. 他にも日付 (Date) やバイナリ (raw) がある.↩︎ 他にも複素数 (complex) がある.↩︎ 例えば以下を参照されたい: http://adv-r.had.co.nz/Style.html↩︎ break, else, FALSE, for, function, if in Inf, NA, NaN, next NULL, repeat, TRUE, while など↩︎ "],
["02-rstudio.html", "2 RStudio 2.1 RStudio とは 2.2 RStudio のインストール 2.3 RStudio の設定 2.4 RStudio の使い方", " 2 RStudio 2.1 RStudio とは RStudio は R の統合開発環境 (IDE, Integrated Development Enviroment) の一つである. オープンソース版が存在する. https://ja.wikipedia.org/wiki/R-Studio 2.2 RStudio のインストール オープンソース版のRStudio のインストールは https://www.rstudio.com/products/rstudio/download/ にいき, 該当機種のファイルをダウンロードする. ダウンロードしたあとに実行すればインストールされる. Ubuntu ならサーバー版を導入するとよい. https://www.rstudio.com/products/rstudio/download-server/ 2.3 RStudio の設定 メニューバーの [Tools] から [Global Options…] を選択することで設定を変更できる. [General] で以下のように [Restore .RData …] のチェックを外していいて, その下を Never にしている. これは, 立ち上げたきに環境をクリーンし, 終了時に, データの保存を聞かれないようにするためである. 次に, [Code] の タブ [Saving] で. [Default text encoding] を UTF-8 とする. Windows 以外だとOSのシステムフォントが同じなので問題ない. しかし Windows は SJIS を拡張した CP932 なので, 注意が必要である. Windows のRは UTF-8 を選択してもR自身はCP932処理している. ただ, 他のOSとの併用の場合, UTF-8 にしたほうがよいだろう. またHTMLファイルは UTF-8 でのファイルが前提になりつつあるので, HTML として出力を考えているなら, UTF-8 としたほうが無難である. またインターネットで公開されている日本語のRファイルは Windows の使用が前提となっているため, 文字コードが CP932 であることが多い. Windows 以外を使っている場合, 一時的に文字コードを SJIS を選択する必要がある. あと, [R Markdown] で 真ん中あたりの [Show output preview in:] を View Pane に変更する 2.4 RStudio の使い方 RStudio の使い方として日本語版のチートシートがある. https://github.com/rstudio/cheatsheets/raw/master/translations/japanese/rstudio-IDE-cheatsheet_ja.pdf 英語であるがこの動画も有益である. 第一章だけ公開されている. https://www.datacamp.com/courses/working-with-the-rstudio-ide-part-1 RStudio プロジェクト単位で複数のソースコードを管理するのことが推奨される. そうするとプロジェクトごとに作業ディレクトリが設定される. プロジェクトはメニューバー の [File] から [New Project] を選択する. そうすると新たに新たにディレクトリを作成するか, 既存のディレクトリを採用するかなどが選べる. また, バージョン管理ソフトを導入していればそこから取り入れることも可能となる. プロジェクトを立ち上げると左にコンソールペイン (Console Pane) が, 右側に上下に二分割されたペインが現れる. この配置は メニューバーの [Tools] から [Project Options -&gt; Pane Layout] を選べば変更可能である. コンソールペインにコマンドを入力するとその結果が直下に返される. 何か入力した後に, Ctrl + l (Cmd + l) を押すと, 画面が更新される. 上下の矢印キーで過去に実行したコマンドを選択できる. メニューバー の [File] から [New File -&gt; RScript] を選択するか, Ctrl + Shift + n (Cmd + Shift + n) と入力するか, メニューバー下の一番左の白紙のアイコンをクリックすると, Rのスクリプトファイルが新規に作られる. スクリプフォファイルを開くと左側のコンソール画面の上にソースペインが登場する. ここにソースコードを書く. ソースペインで何かコマンドを書いていきながら, ソースコードの該当行で Ctrl + Enter (Cmd + Return) と入力するか, ソースペインの上側の右に並んでいるアイコンのうち, 左側のRunと書かれたアイコンをクリックすると, 該当行がコンソール画面で実行される. 複数行選択した後に, メニューバー の [Code] から [Run Selected line(s)] を選ぶか, Ctrl + Shift + Enter (Cmd + Shift + Enter) と入力すると複数行をまとめて実行させることも可能である. メニューバー の [File] から [Save] を選択するか, Ctrl + s (Cmd + s) と入力するか, メニューバー下の左から3番目のフロッピーディスクアイコンをクリック すると, スクリプトファイルを保存することができる. またメニューバー の [File] から [Open] を選択するか, Ctrl + o (Cmd + o) と入力するか, メニューバー下の左から2番めのフォルダを開くアイコンをクリックすると, 既存のスクリプトファイルを開くことができる. 右上のペインには Environment と History のタブがある. Environment は現在使っているオブジェクトが表示される. 最初は空白である. 変数に数値を代入 (R の言い方ではオブジェクトに付値) することによって, 値が付け加わっている. History はこれまでの履歴が記録される. 履歴の一部ををエディトペインかコンソールペインに挿入することができる. 右下のペインには Files, Plots, Packages, Help, Viewer のタブがある. Files ペインはWindowsではエクスプローラーのようなもので, Mac はFinder のようなもので, ファイル管理をおこなう. ファイル管理として新たなフォルダを作成したり, ファイルを削除したり, ファイル名を変更したりする. またワーキングディレクトリを直感的に設定することもできる. ワーキングを設定したい場所に移動して, Files ペインの上に並んでいるアイコンのうち, Moreをクリックし, [Set As Working Directory] をクリックすればよい. Plots ペインはコンソール画面で作図をコマンドの実行したら, 表示されるペインである. そこで作成した図をコマンドを使わずに保存したりすることができる. Packages ペインは現在Rに導入されているパッケージリストが表示される. そこに無いパッケージはメニューバーの [Tools] から [Install Packages…] を選択して実行すればよい. すでにあるパッケージは, パッケージ名の左側のボックスをチェックすれば, ライブライリ名を付けずにコマンドを実行させることができる. Help ペインはその名の通り, ヘルプ画面が表示される. コンソールペインから help (コマンド) もしくは ?コマンド と入力するとそのコマンドのヘルプがこのペインに表示される. R ではソースペインやコンソールペインで, コマンド入力していると, コマンドの後補があらわてくる. [TAB] でコマンドを補完できる. さらにそのコマンドでどのような引数が使われるのかも示される. さらに [TAB] を押せば, 引数を選べるだけでなく, 簡単なコマンドの説明がある. そのときに [F1] を押せば, より詳細なヘルプが立ち上がる. また Packages パインから該当パッケージをクリックするとそのパッケージのコマンド一覧が Help ペインに表示される. 最後のViewer ペインは R Markdown で作成したファイルを HTMLで出力したときに表示されるペインである. 最初の設定だと別のウィンドウ画面として結果が表示される. このペインに出力されるためには [Tools -&gt; R Markdown] にいき, 真ん中あたりの [Show output preview in:] を View Pane に変更する必要がある. その上でソースペインから [Ctrl + Shift + k] とするか, ソースペインの左側のアイコン群の一番右側のノートのアイコンをクリックすると, 確認画面が現れるので HTML を押す. そうするとそのコードがすべて実行されて, 実行結果が作図も含めてHTMLファイルに出力される. もしくはメニューバーの [File] から [Knit Document…] としを選択するとよい. これは knitr と rmarkdown いわれるパッケージを利用したもので, Rのコードを埋め込んだマークダウンファイルを作成し, そこからHTMLファイルを作成する. 他にも word ファイル や pdf ファイル生成することも適切に設定していれば可能である. ソースコードだけでなく, マークダウンファイルに R コマンドを埋め込んだ Rmd ファイルを作成することができる それは新規作成でRスクリプトでなく, R Notebook や R Markdown を選択すればよい. "],
["03-vector.html", "3 ベクトル 3.1 ベクトル 3.2 算術演算子 3.3 論理演算子 3.4 比較演算子 3.5 要素 3.6 関数 3.7 規則的なベクトル 3.8 乱数ベクトル", " 3 ベクトル 3.1 ベクトル Rでは同じ型の値を集めたものをベクトルという. ベクトルは c() を用いて構成する. (num&lt;-c(2,3,7,9)) ## [1] 2 3 7 9 (chr &lt;- c(&quot;cat&quot;,&quot;dog&quot;,&quot;cow&quot;)) ## [1] &quot;cat&quot; &quot;dog&quot; &quot;cow&quot; ベクトルには長さという属性 (attribute) が付く. length(num) ## [1] 4 length(chr) ## [1] 3 ベクトルはオブジェクトの基本であり, 一つの値は長さが1のベクトルと考える. 型が同じでない場合, 強制的に同じ型に変換される. 文字列が含まれればすべて文字列になる. 数値と論理値の場合は論理値の TRUE が1に FALSE が0に変換される. (x&lt;- c(1,4)) ## [1] 1 4 typeof(x) ## [1] &quot;double&quot; (y &lt;- c(2,FALSE,&quot;4&quot;)) ## [1] &quot;2&quot; &quot;FALSE&quot; &quot;4&quot; typeof(y) ## [1] &quot;character&quot; (z &lt;- c(2,FALSE)) ## [1] 2 0 typeof(z) ## [1] &quot;double&quot; 3.2 算術演算子 四則演算などの算術演算子はその対象を数値ベクトルに拡張できる. ベクトルの算術演算子はその要素ごと行う. a&lt;-c(2,3,3,3) b&lt;-c(3,3,5,7) a+b ## [1] 5 6 8 10 a-b ## [1] -1 0 -2 -4 a*b ## [1] 6 9 15 21 a/b ## [1] 0.6666667 1.0000000 0.6000000 0.4285714 a^b ## [1] 8 27 243 2187 片方が値, 同じ長さのベクトルとして演算が実行される. a+2 ## [1] 4 5 5 5 a-2 ## [1] 0 1 1 1 a*2 ## [1] 4 6 6 6 a/2 ## [1] 1.0 1.5 1.5 1.5 a^2 ## [1] 4 9 9 9 一般に長さが違う場合, 短いほうが繰り返される. c&lt;-c(1,2) a+c ## [1] 3 5 4 5 a-c ## [1] 1 1 2 1 a*c ## [1] 2 6 3 6 a/c ## [1] 2.0 1.5 3.0 1.5 a^c ## [1] 2 9 3 9 なお 短いほうが長い方の約数でないと警告がでる. 3.3 論理演算子 論理値に対して演算をおこなって論理値を返す論理演算子というものがある. Rには, 論理演算子として, 否定 (!), または (|), かつ (&amp;) がある. 論理演算子もベクトルごとに評価できる. logic1 &lt;- c(TRUE, FALSE, FALSE) logic2 &lt;- c(TRUE, TRUE, FALSE) !logic1 ## [1] FALSE TRUE TRUE logic1 | logic2 ## [1] TRUE TRUE FALSE logic1 &amp; logic2 ## [1] TRUE FALSE FALSE ベクトルのうちすべての要素が TRUE かどうかを評価する all や 少なくとも一つの要素が TRUE かどうかを評価する any というのがある. , any(logic1) ## [1] TRUE all(logic1) ## [1] FALSE 3.4 比較演算子 2つの値を比較してして論理値を返す比較演算子というものがある. Rには, 比較演算子として, 等しいか ==, どちらかが大きいか &gt;, &lt; がある. それぞれのベクトルの要素ごとに評価できる. vec1 &lt;- 1:4 vec2 &lt;- c(2,1,3,4) vec1 == vec2 ## [1] FALSE FALSE TRUE TRUE vec1 &gt; vec2 ## [1] FALSE TRUE FALSE FALSE vec1 &lt; vec2 ## [1] TRUE FALSE FALSE FALSE 等しくない !=, 以上および以下 &gt;=, &lt;= がある. vec1 != vec2 # !(vec1==vec2) ## [1] TRUE TRUE FALSE FALSE vec1 &gt;= vec2 # (vec1 &gt; vec2 | vec1 == vec2) ## [1] FALSE TRUE TRUE TRUE vec1 &lt;= vec2 # (vec1 &lt; vec2 | vec1 == vec2) ## [1] TRUE FALSE TRUE TRUE 片方が値, 同じ長さのベクトルとしても演算が実行される. vec1 &gt; 2 ## [1] FALSE FALSE TRUE TRUE さらに %in% という演算子がある. これは左のベクトルが右のベクトルに含まれるかどうかを示すものである. vec1 %in% 4:5 ## [1] FALSE FALSE FALSE TRUE 3.5 要素 ベクトルの要素はカギカッコで取り出す. num &lt;- c(2,3,7,9) num[3] ## [1] 7 取り出すだけななく付値することもできる. num[3] &lt;- 500 num ## [1] 2 3 500 9 マイナスをつけるとその要素以外を取り出す. num[-3] ## [1] 2 3 9 複数取り出すこともできる. num[c(1,4)] ## [1] 2 9 他にも論理値ベクトルを使って取り出すことができる. idx &lt;- c(TRUE,FALSE,TRUE,TRUE) num[idx] ## [1] 2 500 9 さらに比較演算子と組み合わせることができる. (num &gt; 4) ## [1] FALSE FALSE TRUE TRUE num[num &gt; 4] ## [1] 500 9 また : をもちいて連続したベクトルが作れるので, それを利用してベクトルを抜き出すことができる. 2:4 ## [1] 2 3 4 num[2:4] ## [1] 3 500 9 またベクトルには名前の属性をつけて構成することがでる. vec &lt;- c(x= 3, y =3, z = 4) また次のようにしてもよい. names(num) &lt;- letters[1:4] いずれに名前の属性をつけると次のようにしてアクセスが可能である. vec[&quot;x&quot;] ## x ## 3 num[&quot;d&quot;] ## d ## 9 3.6 関数 引数がベクトルの関数がいくつかある. これによってベクトルの和や積が簡単に扱える. x&lt;-c(1,2,3,4,5) sum(x) ## [1] 15 cumsum(x) ## [1] 1 3 6 10 15 prod(x) ## [1] 120 cumprod(x) ## [1] 1 2 6 24 120 平均, 中央値, 分散, 標準偏差などの統計関数も扱える. x &lt;- c(x,10) mean(x) ## [1] 4.166667 median(x) ## [1] 3.5 var(x) ## [1] 10.16667 sd(x) ## [1] 3.188521 ベクトルを並べ替えたり 最小値や最大値しめしたり, それが何番目の要素になるのかをしめすことができる. x &lt;- c(3,3,5,0) sort(x) ## [1] 0 3 3 5 sort(x,decreasing = TRUE) ## [1] 5 3 3 0 min(x) ## [1] 0 max(x) ## [1] 5 which.min(x) ## [1] 4 which.max(x) ## [1] 3 またベクトルに NA が含まれるき, 関数 mean などではデフォルトで結果が, NA になる. それを避けるには na.rm=TRUE というオプションを付ける必要がある. x &lt;- c(4,2,NA,3) mean(x) ## [1] NA mean(x, na.rm = TRUE) ## [1] 3 3.7 規則的なベクトル 1:5 のような規則的なベクトルを柔軟に作成するのに seq を用いるとよい. 1:5 ## [1] 1 2 3 4 5 seq(1, 5) ## [1] 1 2 3 4 5 seq(1, 5, by = 2) ## [1] 1 3 5 seq(1, 5, length.out = 4) ## [1] 1.000000 2.333333 3.666667 5.000000 繰り返しを作成することができる rep も覚えておくと便利である. rep(1, 5) ## [1] 1 1 1 1 1 rep(c(1, 2), times = 3) ## [1] 1 2 1 2 1 2 rep(c(1, 2), each = 3) ## [1] 1 1 1 2 2 2 またアルファベットの文字列もあらかじめ組み込まれている. letters ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; ## [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; LETTERS ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; ## [20] &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; LETTERS[1:2] ## [1] &quot;A&quot; &quot;B&quot; 3.8 乱数ベクトル ベクトルを出鱈目に並べ直すには関数 sample を使う set.seed(10) sample(1:5) ## [1] 3 1 2 5 4 最初の行の関数 set.seed は他の環境でも再現可能性にするための設定である. さて, この乱数は一旦出力された値は二度とでない非復元抽出である. 復元抽出にするには sample(1:5, replace=TRUE) ## [1] 3 2 2 2 5 とオプション replace=TRUE をつける. いくつ取り出すかをオプション size で決められる. sample(LETTERS[1:2], size=10, replace=TRUE) ## [1] &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;A&quot; 非復元抽出の場合, 取りうる値より大きくできないことに注意されたい. さらに確率を prob で変えることができる. sample(LETTERS[1:2], prob=c(0.8,0.2),size=10,replace=TRUE) ## [1] &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;A&quot; &quot;A&quot; 独立な一様分布にしたがう長さ size のベクトルは runif(size) によって, 正規分布にしたがうベクトルは rnorm(size) で出力される. size &lt;- 8 runif(size) ## [1] 0.27548386 0.22890394 0.01443391 0.72896456 0.24988047 0.16118328 0.01704265 ## [8] 0.48610035 rnorm(size) ## [1] -1.26519802 -0.37366156 -0.68755543 -0.87215883 -0.10176101 -0.25378053 ## [7] -1.85374045 -0.07794607 "],
["04-dataframe.html", "4 データ構造 4.1 ベクトル 4.2 リスト 4.3 因子ベクトル 4.4 行列 4.5 データフレイム", " 4 データ構造 4.1 ベクトル Rでは同じ型の値を集めたものをベクトルという. ベクトルは c() を用いて構成する. (num&lt;-c(2,3,7,9)) ## [1] 2 3 7 9 (chr &lt;- c(&quot;cat&quot;,&quot;dog&quot;,&quot;cow&quot;)) ## [1] &quot;cat&quot; &quot;dog&quot; &quot;cow&quot; ベクトルには長さという属性 (attribute) が付く. length(num) ## [1] 4 length(chr) ## [1] 3 ベクトルはオブジェクトの基本であり, 一つの値は長さが1のベクトルと考える. 型が同じでない場合, 強制的に同じ型に変換される. 文字列が含まれればすべて文字列になる. 数値と論理値の場合は論理値の TRUE が1に FALSE が0に変換される. (x&lt;- c(1,4)) ## [1] 1 4 typeof(x) ## [1] &quot;double&quot; (y &lt;- c(2,FALSE,&quot;4&quot;)) ## [1] &quot;2&quot; &quot;FALSE&quot; &quot;4&quot; typeof(y) ## [1] &quot;character&quot; (z &lt;- c(2,FALSE)) ## [1] 2 0 typeof(z) ## [1] &quot;double&quot; 4.1.1 ベクトルのアクセス ベクトルの要素はカギカッコに整数値を代入することで 取り出すせることができる. たとえば3番目のベクトルの要素を取り出すには以下とする. num &lt;- c(2,3,7,9) num[3] ## [1] 7 また名前の属性をつけてベクトルを構成することがでる. vec &lt;- c(x= 3, y =3, z = 4) vec ## x y z ## 3 3 4 names(vec) ## [1] &quot;x&quot; &quot;y&quot; &quot;z&quot; すでにあるリストの場合, 次のようにしてもよい. names(num) &lt;- letters[1:4] num ## a b c d ## 2 3 7 9 いずれに名前の属性をつけると次のようにしてアクセスが可能である. vec[&quot;x&quot;] ## x ## 3 num[&quot;d&quot;] ## d ## 9 4.2 リスト ベクトルなどを集めたものをリストという. ベクトル型の違うベクトルを関数 list で集める. リストの属性には長さがある. (lst &lt;- list(&quot;a&quot;,c(3,3,2))) ## [[1]] ## [1] &quot;a&quot; ## ## [[2]] ## [1] 3 3 2 typeof(lst) ## [1] &quot;list&quot; length(lst) ## [1] 2 関数 class によってリストがであることが確認でき, str で属性を詳しく調べることができる. class(lst) ## [1] &quot;list&quot; str(lst) ## List of 2 ## $ : chr &quot;a&quot; ## $ : num [1:3] 3 3 2 リストとベクトルの違いとして, リスト自体もリストとして含められることがある. typeof(list(&quot;b&quot;,lst)) ## [1] &quot;list&quot; リストベクトルに変換するには unlist を用いる. それぞれの型が違う場合, 同じ型に強制変換される. lst&lt;-list(1:3,2:6) lst ## [[1]] ## [1] 1 2 3 ## ## [[2]] ## [1] 2 3 4 5 6 unlist(lst) ## [1] 1 2 3 2 3 4 5 6 unlist(list(&quot;a&quot;,1:4)) ## [1] &quot;a&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; 4.2.1 リストのアクセス リストの取りだすには, ベクトルのようにかぎかっこで数値を入力する. 以下は一番目のリストを表示している. lst[1] ## [[1]] ## [1] 1 2 3 また名前の属性をもてば, その名前を入力することで取り出すことができる. たと次のようにして名前の属性をつけたリストを作る. (lst &lt;- list(name=&quot;a&quot;,num=c(3,3,2))) ## $name ## [1] &quot;a&quot; ## ## $num ## [1] 3 3 2 names(lst) ## [1] &quot;name&quot; &quot;num&quot; その上で以下のようにすれば2番目の要素が取り出せる. lst[&quot;num&quot;] ## $num ## [1] 3 3 2 いずれにせよ取り出したののもリストになることに注意されたい. typeof(lst[1]) ## [1] &quot;list&quot; typeof(lst[&quot;num&quot;]) ## [1] &quot;list&quot; ベクトルとして取り出すには次のようにする. lst[[2]] ## [1] 3 3 2 typeof(lst[[2]]) ## [1] &quot;double&quot; 名前の属性がついていれば以下のようにもできる. lst[[&quot;num&quot;]] ## [1] 3 3 2 lst$num ## [1] 3 3 2 リストのなかのあるベクトルの平均値を求めるには次のようにする. ## mean(lst[[2]]) ## mean(lst[[&quot;num&quot;]]) mean(lst$num) ## [1] 2.666667 もしくは以下とする. with(lst, mean(num)) ## [1] 2.666667 なおリストの要素を消すには以下のようにする. lst$num &lt;- NULL lst ## $name ## [1] &quot;a&quot; 4.3 因子ベクトル 4.3.1 factor 文字列ベクトルを引数にした関数 factorによって 因子 (factor) ベクトルを作成できる. (x &lt;- c(&quot;L&quot;,&quot;S&quot;,&quot;M&quot;,&quot;M&quot;,&quot;L&quot;)) ## [1] &quot;L&quot; &quot;S&quot; &quot;M&quot; &quot;M&quot; &quot;L&quot; (x.fac &lt;- factor(x)) ## [1] L S M M L ## Levels: L M S 因子ベクトルの実体は level という属性をもつ整数ベクトルである. typeof(x.fac) ## [1] &quot;integer&quot; length(x.fac) ## [1] 5 levels(x.fac) ## [1] &quot;L&quot; &quot;M&quot; &quot;S&quot; 関数 class によって因数ベクトルがであることが確認でき, str で属性を詳しく調べることができる. class(x.fac) ## [1] &quot;factor&quot; str(x.fac) ## Factor w/ 3 levels &quot;L&quot;,&quot;M&quot;,&quot;S&quot;: 1 3 2 2 1 また水準の表示順は自動的にアルファベット順になるが, それを変更するには次のようにする. (x.factor &lt;- factor(x,levels=c(&quot;S&quot;,&quot;M&quot;,&quot;L&quot;))) ## [1] L S M M L ## Levels: S M L この水準に順序構造を付与するには次のようにする. (x.order &lt;- ordered(x,levels=c(&quot;S&quot;,&quot;M&quot;,&quot;L&quot;))) ## [1] L S M M L ## Levels: S &lt; M &lt; L 4.3.2 cut また数値を区間ごとに区分した因子ベクトルも作成可能である. 0から10までの値を発生させる. x &lt;- runif(10,0,10) x ## [1] 1.448061 1.242444 4.915462 9.978543 4.254607 7.279891 4.200208 6.039185 ## [9] 2.500370 5.594718 5等分するには以下のようにする. cut(x, breaks=5) ## [1] (1.23,2.99] (1.23,2.99] (4.74,6.48] (8.23,9.99] (2.99,4.74] (6.48,8.23] ## [7] (2.99,4.74] (4.74,6.48] (1.23,2.99] (4.74,6.48] ## Levels: (1.23,2.99] (2.99,4.74] (4.74,6.48] (6.48,8.23] (8.23,9.99] これは登場したデータの最大値と最小値の幅を5等分している. 区間を指定するには以下のようにベクトルで指定する. cut(x,breaks=c(0,2,4,6,8,10)) ## [1] (0,2] (0,2] (4,6] (8,10] (4,6] (6,8] (4,6] (6,8] (2,4] (4,6] ## Levels: (0,2] (2,4] (4,6] (6,8] (8,10] 0より大きく2以下, 2より大きく4以下,… となっている. 0も含めるのなら include.lowest=TRUE というオプションをつける. cut(x, breaks=seq(0,10,2),include.lowest=TRUE) ## [1] [0,2] [0,2] (4,6] (8,10] (4,6] (6,8] (4,6] (6,8] (2,4] (4,6] ## Levels: [0,2] (2,4] (4,6] (6,8] (8,10] またこれを0以上2未満, 2以上4未満, … とするにはオプション right=FALSE をつける. cut(x, breaks=seq(0,10,2),right=FALSE,include.lowest=TRUE) ## [1] [0,2) [0,2) [4,6) [8,10] [4,6) [6,8) [4,6) [6,8) [2,4) [4,6) ## Levels: [0,2) [2,4) [4,6) [6,8) [8,10] このとき, include.lowest=TRUE は最大値を含めることを意味する. また因子の名称はオプション labels で変更可能である. cut(x, breaks=seq(0,10,2),right=FALSE,include.lowest=TRUE, labels =c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;)) ## [1] A A C E C D C D B C ## Levels: A B C D E 4.4 行列 ベクトルに縦と横の次元を付与することによって行列 (matrix) を作ることができる. mat &lt;- matrix(1:10, nrow=2,ncol=5) mat ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 またオプション byrow=TRUE で横から行列を作成できる. matrix(1:10, nrow=2,ncol=5,byrow = TRUE) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 2 3 4 5 ## [2,] 6 7 8 9 10 この行列の実体は dim という属性を持つ数値ベクトルである. typeof(mat) ## [1] &quot;integer&quot; length(mat) ## [1] 10 dim(mat) ## [1] 2 5 他にもそれぞれの要素の次元は以下で得ることができる. nrow(mat) ## [1] 2 ncol(mat) ## [1] 5 関数 class によって因数ベクトルがであることが確認でき, str で属性を詳しく調べることができる. class(mat) ## [1] &quot;matrix&quot; &quot;array&quot; str(mat) ## int [1:2, 1:5] 1 2 3 4 5 6 7 8 9 10 4.4.1 行列の演算 縦での結合は rbind を用いる mata&lt;-matrix(1:5,nrow=1,ncol=5) rbind(mat,mata) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 ## [3,] 1 2 3 4 5 横での結合は cbind を用いる matb&lt;-matrix(1:4,nrow=2,ncol=2) cbind(mat,matb) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] ## [1,] 1 3 5 7 9 1 3 ## [2,] 2 4 6 8 10 2 4 転置行列は以下のようにすればよい. t(mat) ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 ## [3,] 5 6 ## [4,] 7 8 ## [5,] 9 10 通常の * は要素ごとの掛け算になる. 数学で用いられる行列同士の掛け算は %*% を実施する. matb %*% mat ## [,1] [,2] [,3] [,4] [,5] ## [1,] 7 15 23 31 39 ## [2,] 10 22 34 46 58 行列のことが一致させる必要がある. また列ごとの合計, 行ごとの合計は以下を実施する. colSums(mat) ## [1] 3 7 11 15 19 rowSums(mat) ## [1] 25 30 返り値はベクトルになる. 行列のすべての要素を足すには sum でよい. sum(mat) ## [1] 55 また列ごとの平均, 行ごとの平均は以下を実施する. colMeans(mat) ## [1] 1.5 3.5 5.5 7.5 9.5 rowMeans(mat) ## [1] 5 6 4.4.2 行列のアクセス 行列からベクトルの取り出し以下のようにｓる. mat[2,] ## [1] 2 4 6 8 10 ベクトルのまま取り出されてしまう. オプション drop=FALSE をつけると行列のまま取り出すことができる. mat[, 3, drop=FALSE] ## [,1] ## [1,] 5 ## [2,] 6 2つ同時に取り出すにときは特にオプションをしていしなくても行列として取り出せる. mat[,2:3] ## [,1] [,2] ## [1,] 3 5 ## [2,] 4 6 要素の取り出し mat[2,3] ## [1] 6 行列に名前を付けることができる. rownames(mat) &lt;- letters[1:2] colnames(mat) &lt;- 1:5 mat ## 1 2 3 4 5 ## a 1 3 5 7 9 ## b 2 4 6 8 10 これによって以下のようにしてもアクセス可能である. mat[&quot;a&quot;,&quot;3&quot;] ## [1] 5 なお名前は次のようにしてあとから作成することができる. dimnames(mat) &lt;- list(LETTERS[1:2],2:6) mat ## 2 3 4 5 6 ## A 1 3 5 7 9 ## B 2 4 6 8 10 4.5 データフレイム 同じ長さのベクトルを組み合わせたリストをデータフレイム (dataframe) という. データフレイムは次のようにして作られる. df &lt;- data.frame(x = rnorm(10), y = letters[1:10]) データフレイムは大規模なことが多いので最初の数行だけをみるためには head をもちいる. head(df) ## x y ## 1 -0.1173711 a ## 2 0.6452485 b ## 3 -2.1368910 c ## 4 -0.2025232 d ## 5 -0.6225914 e ## 6 0.9606878 f データの簡単な統計表は summary を使うとよい. summary(df) ## x y ## Min. :-2.13689 Length:10 ## 1st Qu.:-0.18124 Class :character ## Median : 0.06802 Mode :character ## Mean : 0.09098 ## 3rd Qu.: 0.88183 ## Max. : 1.17220 よりプログラム言語としてのデータ構造を調べるには str を使えばよい. str(df) ## &#39;data.frame&#39;: 10 obs. of 2 variables: ## $ x: num -0.117 0.645 -2.137 -0.203 -0.623 ... ## $ y: chr &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ... データフレイムはリストである. typeof(df) ## [1] &quot;list&quot; class(df) ## [1] &quot;data.frame&quot; リストのように長さと名前をもつ. length(df) ## [1] 2 names(df) ## [1] &quot;x&quot; &quot;y&quot; 行列と同じ次元をもつ. dim(df) ## [1] 10 2 ncol(df) ## [1] 2 nrow(df) ## [1] 10 ncol(df) は length(df) と同じである. 行列と同じ名前をもつ. dimnames(df) ## [[1]] ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; ## ## [[2]] ## [1] &quot;x&quot; &quot;y&quot; colnames(df) ## [1] &quot;x&quot; &quot;y&quot; rownames(df) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; colnames(df) は names(df) と同じである. 4.5.1 データフレイムの演算 データフレイムは行列でもあるので, 注意があるが 行列での演算がほとんどそのまま利用できる. rbind(df, c(3,&quot;a&quot;)) ## x y ## 1 -0.117371107449346 a ## 2 0.645248484152778 b ## 3 -2.13689099747362 c ## 4 -0.20252323748115 d ## 5 -0.622591351453794 e ## 6 0.96068783648491 f ## 7 0.18707990088201 g ## 8 1.17220290346128 h ## 9 -0.0510397617056437 i ## 10 1.07501134031966 j ## 11 3 a cbind(df,z=runif(10)) ## x y z ## 1 -0.11737111 a 0.1031385 ## 2 0.64524848 b 0.5389381 ## 3 -2.13689100 c 0.9485900 ## 4 -0.20252324 d 0.1447809 ## 5 -0.62259135 e 0.8960003 ## 6 0.96068784 f 0.1418294 ## 7 0.18707990 g 0.4087217 ## 8 1.17220290 h 0.6284056 ## 9 -0.05103976 i 0.2650579 ## 10 1.07501134 j 0.8377570 転置行列は行列として出力可能である. 以下のようにデータフレイムに因子ベクトルが含まれていたら全て文字列になる. t(df) ## [,1] [,2] [,3] [,4] [,5] ## x &quot;-0.11737111&quot; &quot; 0.64524848&quot; &quot;-2.13689100&quot; &quot;-0.20252324&quot; &quot;-0.62259135&quot; ## y &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; ## [,6] [,7] [,8] [,9] [,10] ## x &quot; 0.96068784&quot; &quot; 0.18707990&quot; &quot; 1.17220290&quot; &quot;-0.05103976&quot; &quot; 1.07501134&quot; ## y &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; データフレイムの構成ベクトルがすべて論理値もしくは数値のとき, 同じ行数と列数のデータフレイムの要素ごとの四則演算は可能である. ただし, 通常の行列演算を実施するには, 行列に変換しなければならない. また データフレイムの構成ベクトルがすべて論理値もしくは数値のとき, 列ごとの合計, 行ごとの合計が可能である. dff&lt;-data.frame(a=1:5,b=c(TRUE, TRUE, TRUE, FALSE,FALSE)) colSums(dff) ## a b ## 15 3 rowSums(dff) ## [1] 2 3 4 4 5 返り値はベクトルになる. 行列のすべての要素を足すには sum でよい. sum(dff) ## [1] 18 また列ごとの平均, 行ごとの平均は以下を実施する. colMeans(dff) ## a b ## 3.0 0.6 rowMeans(dff) ## [1] 1.0 1.5 2.0 2.0 2.5 4.5.2 データフレイムのアクセス データのアクセスとして, ベクトルのように一つのカギカッコで取り出すと以下のようになる. df[&quot;x&quot;] ## x ## 1 -0.11737111 ## 2 0.64524848 ## 3 -2.13689100 ## 4 -0.20252324 ## 5 -0.62259135 ## 6 0.96068784 ## 7 0.18707990 ## 8 1.17220290 ## 9 -0.05103976 ## 10 1.07501134 他にも df[1] でもよいが, いずれにせよデータフレイムとして取り出されてしまう. ベクトルとして取り出すには以下を実施する. df$x ## [1] -0.11737111 0.64524848 -2.13689100 -0.20252324 -0.62259135 0.96068784 ## [7] 0.18707990 1.17220290 -0.05103976 1.07501134 他にも df[[\"x\"]], df[[1]], df[,\"x\"], df[,1] でもよい. ある変数 $x$ の5番目の要素を取り出して別の値100`を代入するには以下のようにする. df$x[5] &lt;- 100 他にも df[[\"x\"]][5], df[[1]][5], df[5,\"x\"], df[5,1] でもよい. データフレイムのある変数の平均値を求めるには次のようにする. mean(df$x) ## [1] 10.15324 もしくは以下とする. with(df, mean(x)) ## [1] 10.15324 他にも attach(df) を使うやり方もあるが, 現在では推奨されない. なおリストの要素を消すには以下のようにする. df$x &lt;- NULL "],
["05-datainput.html", "5 データ入力 5.1 はじめに 5.2 csv ファイル 5.3 EXCEL ファイル 5.4 STATA 5.5 R に入っているデータ 5.6 インターネットからデータ入力 5.7 その他のデータ入力", " 5 データ入力 library(tidyverse) 5.1 はじめに R においてデータ分析をおこなうには データ入力する必要がある. データについてがR やパッケージに入っている場合があるが, 多くは外部ファイルを取り込むことになる. 読み込まれたデータはRではデータフレイム (dataframe) となる. データフレイムは同じ長さのベクトルを組み合わせたリストのことである. 例えばデータフレイムは次のようにして作られる. df &lt;- data.frame(x = rnorm(10), y = letters[1:10]) str(df) ## &#39;data.frame&#39;: 10 obs. of 2 variables: ## $ x: num -0.84 3.321 0.299 -0.139 0.781 ... ## $ y: chr &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ... ただデータフレイムは自動的に文字列が因子ベクトルに変換されてしまう. これを避けるには次のように stringsAsFactors= FALSE をつける. df &lt;- data.frame(x = rnorm(10), y = letters[1:10], stringsAsFactors= FALSE) str(df) ## &#39;data.frame&#39;: 10 obs. of 2 variables: ## $ x: num 1.273 -0.228 -0.596 -0.866 -1.086 ... ## $ y: chr &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ... もしくはライブラリ dplyr にある data_frame を用いれば, そのようなオプションを付けることなくデータフレイムを拡張したクラスを作ることができる. library(dplyr) df &lt;- data_frame(x = rnorm(10), y = letters[1:10]) ## Warning: `data_frame()` is deprecated as of tibble 1.1.0. ## Please use `tibble()` instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_warnings()` to see where this warning was generated. str(df) ## tibble [10 × 2] (S3: tbl_df/tbl/data.frame) ## $ x: num [1:10] -0.0634 0.9815 1.2471 0.169 1.2714 ... ## $ y: chr [1:10] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ... 以降, それぞれのファイル形式ごとにファイル入力について説明する. いずれのファイル形式にせよ, 外部ファイルから入力するさいには 現在のワークングディレクトリとファイルの場所をきちんと把握しておかなければならない. 現在のワーキングディレクトリは以下のコマンドで確認できる. getwd() またワーキングディレクトリを変更するには setwd を実行する. 例えば, 現在のワーキングディレクトリの位置が C:\\Users\\kenji\\work\\project にあり, データ data.csv が C:\\Users\\kenji\\work\\project\\data にある場合, df &lt;- read.table(&quot;work/data.csv&quot;, header=TRUE, sep = &quot;,&quot;) とするか, ワーキングディレクトリを変更しなければならない. setwd(&quot;C:/Users/kenji/work/project/data&quot;) df &lt;- read.table(&quot;data.csv&quot;, header=TRUE, sep = &quot;,&quot;) また RStudio はメニューバーの File から Import Dataset からインタラクティブに外部ファイルが入力可能である. いったんこれで入力したとしても, history ペインでどのようなコマンドを実行したかを確認して, 次回も実行できるよう記録しておくとよい. 5.2 csv ファイル csv ファイルの csv とは comma separated variable の略で, その名の通りコンマでわけられた変数が以下のようなテキストファイルである. var1, var2, var3 3, 4,&quot;text&quot; 4, 4, &quot;text&quot; ... 最初の一行は変数名を含まれていることが多いけれど, ない場合もあり事前に確認が必要である. R 以外の計算機で作成した結果を csv で保存しておけば, それを R に取り込むことができる. csv ファイルをRに取り込むには関数 raed.table を使うのが基本である. df &lt;- read.table(&quot;data.csv&quot;, header=TRUE, sep = &quot;,&quot;) こうすればオブジェクト df にデータフレイムとして導入される. 関数 read.csv を使えば, 以上のオプションを付ける必要がない. df &lt;- read.table(&quot;data.csv&quot;) 外部からファイルを取り込んだ場合, 文字列は自動的に因子ベクトルに変換されてしまう. これを避けるには次のようにオプションをつける必要がある. df &lt;- read.table(&quot;data.csv&quot;, stringsAsFactors= FALSE) ファイルを書き込むときには次のようにする. write.csv(df,&quot;data.csv&quot;, row.names = FALSE) このオプションはファイルの一列目に rownames が書き込まれるのを避けるための設定である. もしくはライブラリ readr を導入する. ファイルの読み込みは以下となる. library(readr) df &lt;- read_csv(&quot;data.csv&quot;) 特にオプションをつけなくても, 文字列は自動的に因子ベクトルに変換されない. ファイルの書き込みは以下となる. write_csv(df,&quot;data.csv&quot;) 特にオプションをつけなくても, rownames は書き込まない. 日本語が含まれるcsvファイルについては注意が必要である. これについては次の節で触れることにする. 5.3 EXCEL ファイル EXCELはビジネスにおいてデファクトスタンダードになっているスプレッドシートソフトウェアである. R は EXCEL のデータを扱うことができる. 最近のEXCELデータの拡張子は xlsx である. これを導入するにはライブラリ readxl を使えばよい. library(readxl) df &lt;- read_excel(&quot;data.xlsx&quot;,1) ファイルdata.xls の一枚目のシートを意味する. 直接シート名を指定することができる. read_excel(&quot;data.xlsx&quot;,&quot;Revenues&quot;) こちらは「Revenues」という名前のシートを意味する. EXCELから入力するときには, 一行目を変数名にして, 列ごとに変数を揃えておかなければならない. 最終行に合計などがあれば, それも変数として入力してしまうので, 注意が必要である. またEXCELからcsvファイルに変換して, ファイルを読み込ませる方法がある. これは2点ほど注意が必要である. まず EXCEL で桁をしめすコンマのまま保存すると文字列として保存されてしまう. そうしたファイルを read.csv で読み込む数値でなく⽂字列として読み込まれてしまう . それを避けるには , 桁を示すコンマを無しに直して保存しなければならない. なお read_csv をもちいるなら数値として読み込んでくれる また変数名をアルファベットのみにしておいたほうがトラブルが少ない . 日本語が含まれている場合に , EXCEL 上 で csv 形式に変換して保存したときにシフト JIS で保存されてしまう . Linux や Mac では文字コードをUTF-8 にしているので そのままの読み込みだと⽇本語が⽂字化けになる . Windows でも RStudio を導入したときに最初に文字コードを UTF-8 に設定していたのなら同じように文字化けになる. それを防ぐためには , read.csv を用いるときは df &lt;- read.csv(&quot;data.csv&quot;, stringAsFactors=FALSE, fileEncoding=&quot;SJIS&quot;) として, read_csv を用いるときは df &lt;- read_csv(&quot;data.csv&quot;, locale=locale(encoding = &quot;SJIS&quot;)) とする必要がある. 私の使った印象だとライブラリ readxl は賢く日本語を扱ってくれるので, 日本語が含まれている場合, csv に変換せず, そのまま入力したほうがよい. 5.4 STATA Stata は多くの経済学者が実証分析に用いている統計パッケージである. R は Stata のデータを扱うことができる. Stata のデータは拡張子 dta で保存されている. これを導入するにはライブラリ foreign を用いる. library(foreign) df &lt;- read.dta(&quot;data.dta&quot;) ただ, 最新の Stata には対応していない. 最新の Stata に対応するにはライブラリ haven を導入する. library(haven) df &lt;- read_dta(&quot;data.dta&quot;) 他にも SAS や SPSS などの統計パッケージのデータも取り込むことができる. 5.5 R に入っているデータ R およびパッケージにはいくつかのデータがはいっている. どのようなデータが利用可能かは以下のコマンドで調べることができる. data() それがどのような変数が含まれているのかを調べるには, help を使えばよい. help(cars) パッケージのデータは関数 data をつかって利用可能になる. library(AER) ## 要求されたパッケージ car をロード中です ## 要求されたパッケージ carData をロード中です ## ## 次のパッケージを付け加えます: &#39;car&#39; ## 以下のオブジェクトは &#39;package:dplyr&#39; からマスクされています: ## ## recode ## 以下のオブジェクトは &#39;package:purrr&#39; からマスクされています: ## ## some ## 要求されたパッケージ lmtest をロード中です ## 要求されたパッケージ zoo をロード中です ## ## 次のパッケージを付け加えます: &#39;zoo&#39; ## 以下のオブジェクトは &#39;package:base&#39; からマスクされています: ## ## as.Date, as.Date.numeric ## 要求されたパッケージ sandwich をロード中です ## 要求されたパッケージ survival をロード中です data(CPS1985) summary(CPS1985) ## wage education experience age ## Min. : 1.000 Min. : 2.00 Min. : 0.00 Min. :18.00 ## 1st Qu.: 5.250 1st Qu.:12.00 1st Qu.: 8.00 1st Qu.:28.00 ## Median : 7.780 Median :12.00 Median :15.00 Median :35.00 ## Mean : 9.024 Mean :13.02 Mean :17.82 Mean :36.83 ## 3rd Qu.:11.250 3rd Qu.:15.00 3rd Qu.:26.00 3rd Qu.:44.00 ## Max. :44.500 Max. :18.00 Max. :55.00 Max. :64.00 ## ethnicity region gender occupation sector ## cauc :440 south:156 male :289 worker :156 manufacturing: 99 ## hispanic: 27 other:378 female:245 technical :105 construction : 24 ## other : 67 services : 83 other :411 ## office : 97 ## sales : 38 ## management: 55 ## union married ## no :438 no :184 ## yes: 96 yes:350 ## ## ## ## 5.6 インターネットからデータ入力 またWebスクレイピングをしてインターネットのサイトから直接入手できる. 幾つかのデータベースでは api が公開されて, それにもとづいてパッケージが作成されている. Yahoo! Finance (quantmod) Yahoo! Finance Japan (RFinanceYJ) World Development Indicators (WDI) Eurostat (eurostat) e-stat (estatap) また直接, インターネットのファイルをダウンロードすることもできる. library(haven) URL &lt;- &quot;http://fmwww.bc.edu/ec-p/data/wooldridge/attend.dta&quot; df &lt;-read_dta(URL) もし一旦ファイルとして保存しておくなら以下のように実施する. if(!file.exists(&quot;mroz.dta&quot;)) download.file(URL, &quot;mroz.dta&quot;,method=&quot;curl&quot;) library(haven) df &lt;- read_dta(&quot;mroz.dta&quot;) 5.7 その他のデータ入力 Rのバイナルファイルとして保存していれば, それを読み込むことができる. ただ私はほとんど利用したことがない. 他にもリレーショナルデータベースにアクセスして, データを入手できる. これも私はほとんど利用したことがない. "],
["06-datawrangling.html", "6 整然データ 6.1 データ整形 6.2 データ結合 6.3 tidyr 6.4 実践例", " 6 整然データ http://r4ds.had.co.nz/tidy-data.html データが整然 (tidy) であるとは次の条件を満たすデータのことである. 個々の変数 (variable) が1つの列 (column) である 個々の観測 (observation) が1つの行 (row) である 個々の値 (value) が1つのセル (cell) である tidy data これをこのようなデータを使って, データを整形する方法, またはそうしたデータにする方法を紹介する. ここでは以下のライブラリに全面に依存する. library(tidyverse) 特に dplyr と tidyr を用いる. 6.1 データ整形 データセット mtcars を取り扱う. この最初の6つを見るには以下を実施する. mtcars %&gt;% head() ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 ここで %&gt;% はパイプ処理といって, head(mtcars) と同じ効果をもたらす. 括弧が重複する場合, こちらのほうがわかりやすい. ライブラリ dplyr でデータフレイムの処理が簡単になる. select で変数を選択できる. mtcars %&gt;% select(mpg, disp) %&gt;% head() ## mpg disp ## Mazda RX4 21.0 160 ## Mazda RX4 Wag 21.0 160 ## Datsun 710 22.8 108 ## Hornet 4 Drive 21.4 258 ## Hornet Sportabout 18.7 360 ## Valiant 18.1 225 filter により条件に応じた抽出ができる. mtcars %&gt;% select(mpg, disp) %&gt;% filter(disp &gt; 300) %&gt;% head() ## mpg disp ## Hornet Sportabout 18.7 360 ## Duster 360 14.3 360 ## Cadillac Fleetwood 10.4 472 ## Lincoln Continental 10.4 460 ## Chrysler Imperial 14.7 440 ## Dodge Challenger 15.5 318 rename により変数名を変更することができる. 日本語でも一応対応している. mtcars %&gt;% select(mpg, disp) %&gt;% rename(速度 =mpg, 距離 =disp) %&gt;% head() ## 速度 距離 ## Mazda RX4 21.0 160 ## Mazda RX4 Wag 21.0 160 ## Datsun 710 22.8 108 ## Hornet 4 Drive 21.4 258 ## Hornet Sportabout 18.7 360 ## Valiant 18.1 225 arrange により順序を変更できる. mtcars %&gt;% select(mpg, disp) %&gt;% arrange(mpg) %&gt;% head() ## mpg disp ## Cadillac Fleetwood 10.4 472 ## Lincoln Continental 10.4 460 ## Camaro Z28 13.3 350 ## Duster 360 14.3 360 ## Chrysler Imperial 14.7 440 ## Maserati Bora 15.0 301 逆順には以下のようにすればよい. mtcars %&gt;% select(mpg, disp) %&gt;% arrange(desc(mpg)) %&gt;% head() ## mpg disp ## Toyota Corolla 33.9 71.1 ## Fiat 128 32.4 78.7 ## Honda Civic 30.4 75.7 ## Lotus Europa 30.4 95.1 ## Fiat X1-9 27.3 79.0 ## Porsche 914-2 26.0 120.3 新しい変数を作成するには以下のように mutate を用いる. mtcars %&gt;% select(mpg) %&gt;% mutate(gpm = 1/mpg) %&gt;% head() ## mpg gpm ## 1 21.0 0.04761905 ## 2 21.0 0.04761905 ## 3 22.8 0.04385965 ## 4 21.4 0.04672897 ## 5 18.7 0.05347594 ## 6 18.1 0.05524862 以下は20より大きいとTRUE, そうでないと FALSE をとる変数を作成している. mtcars %&gt;% select(mpg) %&gt;% mutate(binarympg = ifelse(mpg&gt;20,TRUE,FALSE)) %&gt;% head() ## mpg binarympg ## 1 21.0 TRUE ## 2 21.0 TRUE ## 3 22.8 TRUE ## 4 21.4 TRUE ## 5 18.7 FALSE ## 6 18.1 FALSE summarize により変数の基本統計表を作成できる. mtcars %&gt;% summarize(avg = mean(mpg), sd =sd(mpg)) ## avg sd ## 1 20.09062 6.026948 group_by と summarize を組み合わせてグループごとの基本統計量も作成できる. mtcars %&gt;% group_by(cyl) %&gt;% summarize(n = n(), avg = mean(mpg), sd =sd(mpg)) ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 3 x 4 ## cyl n avg sd ## &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 4 11 26.7 4.51 ## 2 6 7 19.7 1.45 ## 3 8 14 15.1 2.56 6.2 データ結合 dplyr 2つのデータフレイムを結合する便利なコマンドがある. 列の追加は bind_rows を用いる. df1 &lt;- data_frame(X=1:2, Y=1:2) ## Warning: `data_frame()` is deprecated as of tibble 1.1.0. ## Please use `tibble()` instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_warnings()` to see where this warning was generated. df2 &lt;- data_frame(X=4, Y=4) bind_rows(df1,df2) ## # A tibble: 3 x 2 ## X Y ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 ## 2 2 2 ## 3 4 4 行の追加は bind_rows を用いる. df3 &lt;- data_frame(Z=5:6) bind_cols(df1,df3) ## # A tibble: 2 x 3 ## X Y Z ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 1 5 ## 2 2 2 6 2つのデータフレイムで共通部分を用いて結合させるには4つのやり方がある. dfx &lt;- data_frame(id=c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;), X=1:3) dfy &lt;- data_frame(id=c(&quot;A&quot;,&quot;B&quot;,&quot;D&quot;), Y=c(TRUE,FALSE,TRUE)) 左側の dfx がすべて残るように結合するには, left_join を実行する. left_join(dfx,dfy,by=&quot;id&quot;) ## # A tibble: 3 x 3 ## id X Y ## &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; ## 1 A 1 TRUE ## 2 B 2 FALSE ## 3 C 3 NA 右側の dfx がすべて残るように結合するには, right_join を実行する. right_join(dfx,dfy,by=&quot;id&quot;) ## # A tibble: 3 x 3 ## id X Y ## &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; ## 1 A 1 TRUE ## 2 B 2 FALSE ## 3 D NA TRUE 両方がすべて残るように結合するには, full_join を実行する. full_join(dfx,dfy,by=&quot;id&quot;) ## # A tibble: 4 x 3 ## id X Y ## &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; ## 1 A 1 TRUE ## 2 B 2 FALSE ## 3 C 3 NA ## 4 D NA TRUE 両方にある行のみ残して結合するには, inner_join を実行する. inner_join(dfx,dfy,by=&quot;id&quot;) ## # A tibble: 2 x 3 ## id X Y ## &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; ## 1 A 1 TRUE ## 2 B 2 FALSE 6.3 tidyr 以下のデータセットを考える. df &lt;- data_frame( time = 2010:2014, X = rnorm(5, 0, 1), Y = rnorm(5, 0, 2), Z = rnorm(5, 0, 4) ) df ## # A tibble: 5 x 4 ## time X Y Z ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2010 -1.02 -1.04 -3.98 ## 2 2011 -0.697 1.05 -8.38 ## 3 2012 -0.189 1.91 -7.38 ## 4 2013 2.76 -2.86 -1.81 ## 5 2014 1.85 -1.02 1.98 それぞれの変数名をキーとして, 値を示した表は gather で作れる. df_gather &lt;- df %&gt;% gather(key,value,-time) df_gather ## # A tibble: 15 x 3 ## time key value ## &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2010 X -1.02 ## 2 2011 X -0.697 ## 3 2012 X -0.189 ## 4 2013 X 2.76 ## 5 2014 X 1.85 ## 6 2010 Y -1.04 ## 7 2011 Y 1.05 ## 8 2012 Y 1.91 ## 9 2013 Y -2.86 ## 10 2014 Y -1.02 ## 11 2010 Z -3.98 ## 12 2011 Z -8.38 ## 13 2012 Z -7.38 ## 14 2013 Z -1.81 ## 15 2014 Z 1.98 spread でもとに戻ることができる. df_gather %&gt;% spread(key, value) ## # A tibble: 5 x 4 ## time X Y Z ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2010 -1.02 -1.04 -3.98 ## 2 2011 -0.697 1.05 -8.38 ## 3 2012 -0.189 1.91 -7.38 ## 4 2013 2.76 -2.86 -1.81 ## 5 2014 1.85 -1.02 1.98 spread で time にすると別の形で展開できる. df_spread &lt;- df_gather %&gt;% spread(time, value) df_spread ## # A tibble: 3 x 6 ## key `2010` `2011` `2012` `2013` `2014` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 X -1.02 -0.697 -0.189 2.76 1.85 ## 2 Y -1.04 1.05 1.91 -2.86 -1.02 ## 3 Z -3.98 -8.38 -7.38 -1.81 1.98 以下のようにすればもとに戻る. df_spread %&gt;% gather(time,value,-key) ## # A tibble: 15 x 3 ## key time value ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 X 2010 -1.02 ## 2 Y 2010 -1.04 ## 3 Z 2010 -3.98 ## 4 X 2011 -0.697 ## 5 Y 2011 1.05 ## 6 Z 2011 -8.38 ## 7 X 2012 -0.189 ## 8 Y 2012 1.91 ## 9 Z 2012 -7.38 ## 10 X 2013 2.76 ## 11 Y 2013 -2.86 ## 12 Z 2013 -1.81 ## 13 X 2014 1.85 ## 14 Y 2014 -1.02 ## 15 Z 2014 1.98 gather をうまく使えば変数ごとの基本統計量の表を作ることができる. cars %&gt;% gather(variable,value) %&gt;% group_by(variable) %&gt;% summarize(nobs = n(), avg = mean(value), sd =sd(value)) ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 2 x 4 ## variable nobs avg sd ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 dist 50 43.0 25.8 ## 2 speed 50 15.4 5.29 日本語だと次のようにすればよい. tab &lt;- cars %&gt;% rename(距離=dist,速度=speed ) %&gt;% gather(変数,value) %&gt;% group_by(変数) %&gt;% summarize(観測数 = n(), 平均 = mean(value), 標準偏差 =sd(value)) ## `summarise()` ungrouping output (override with `.groups` argument) head(tab) ## # A tibble: 2 x 4 ## 変数 観測数 平均 標準偏差 ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 距離 50 43.0 25.8 ## 2 速度 50 15.4 5.29 6.4 実践例 tidyr を用いた別の例をみてみよう. 横軸を年としたデータセット df がある. df &lt;- data_frame(name=letters, &quot;2010&quot;=rnorm(26),&quot;2011&quot;=rnorm(26),&quot;2012&quot;=rnorm(26)) head(df) ## # A tibble: 6 x 4 ## name `2010` `2011` `2012` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 a 0.241 -1.15 0.0152 ## 2 b -1.35 0.490 -1.13 ## 3 c -0.196 -0.0114 -0.311 ## 4 d -1.73 0.390 0.0446 ## 5 e -0.560 0.581 -0.537 ## 6 f 0.480 -0.440 -1.60 data.frame でないことに注意されたい. また, 年ごとのデータセット df_2010, df_2011, df_2012 が3つある. df_2010 &lt;- data_frame(name=letters,runif=runif(26)) df_2011 &lt;- data_frame(name=letters,runif=runif(26)) df_2012 &lt;- data_frame(name=letters,runif=runif(26)) これら4つのデータセットを1つにまとめよう. まずデータ df についてであるが, gather をつかう. df_rnorm &lt;- df %&gt;% gather(time,rnorm,-name) %&gt;% mutate(time=as.numeric(time)) head(df_rnorm) ## # A tibble: 6 x 3 ## name time rnorm ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 a 2010 0.241 ## 2 b 2010 -1.35 ## 3 c 2010 -0.196 ## 4 d 2010 -1.73 ## 5 e 2010 -0.560 ## 6 f 2010 0.480 時間の変数を数値に変換している. データセット df_2010, df_2011, df_2012 をつなげる. df_runif &lt;- bind_rows(df_2010,df_2011,df_2012) %&gt;% bind_cols(time=rep(2010:2012,each=26)) head(df_runif) ## # A tibble: 6 x 3 ## name runif time ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 a 0.0652 2010 ## 2 b 0.634 2010 ## 3 c 0.530 2010 ## 4 d 0.808 2010 ## 5 e 0.921 2010 ## 6 f 0.0473 2010 それぞれの年の変数を付け加えている. これを full_join を用いてつなげる. df_full &lt;- full_join(df_rnorm,df_runif,by=c(&quot;name&quot;,&quot;time&quot;)) head(df_full) ## # A tibble: 6 x 4 ## name time rnorm runif ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 a 2010 0.241 0.0652 ## 2 b 2010 -1.35 0.634 ## 3 c 2010 -0.196 0.530 ## 4 d 2010 -1.73 0.808 ## 5 e 2010 -0.560 0.921 ## 6 f 2010 0.480 0.0473 "],
["07-regression1.html", "7 古典的仮定のもとでの最小二乗法 7.1 単回帰モデル 7.2 重回帰モデル", " 7 古典的仮定のもとでの最小二乗法 library(AER) 7.1 単回帰モデル 次の単回帰モデルを考える. \\[ y = \\alpha + \\beta x + u \\] ここで \\(x\\) は説明変数で, \\(y\\) は被説明変数である. \\(u\\) は誤差項である. パラメータとして \\(\\alpha\\) は切片パラメータ, \\(\\beta\\) は傾きパラメータである. 次の仮定を置いている. \\((x_i,y_i)\\) は独立同一分布にしたがう. \\(E[u_i]=0\\) である. \\(u_i\\) と \\(x_i\\) は独立である. \\(u_i\\) は正規分布にしたがう. このとき最小二乗推定量は一致で, 不偏であり, 正規分布にしたがう. 一致とは推定量が観測値を増やすことによって真のパラメータに (確率) 収束することある. 不偏とは推定量の期待値が真のパラメータになることである. また他の線形不偏推定量のなかで最も分散が小さいことも知られている. 仮想的に以下のモデルを考える. N &lt;- 100 x &lt;- runif(N) y &lt;- 10 + 2*x + rnorm(N) df &lt;- data.frame(x,y) 作図すると以下である. plot(y~x) R で回帰分析を実施するには lm を実施する. fm &lt;- lm(y ~ x, data=df) fm 自体はリストであり, 以下の要素がある. typeof(fm) ## [1] &quot;list&quot; names(fm) ## [1] &quot;coefficients&quot; &quot;residuals&quot; &quot;effects&quot; &quot;rank&quot; ## [5] &quot;fitted.values&quot; &quot;assign&quot; &quot;qr&quot; &quot;df.residual&quot; ## [9] &quot;xlevels&quot; &quot;call&quot; &quot;terms&quot; &quot;model&quot; 係数は次のコマンドを実施する. coef(fm) ## (Intercept) x ## 10.175303 1.637939 # coefficients(fm) 傾きの推定値は以下でも実行可能である. with(df, cov(x,y)/var(x)) ## [1] 1.637939 作図すると以下のようになる. plot(y~x,data=df) abline(fm) 残差は次のコマンドを実施する. head(resid(fm)) ## 1 2 3 4 5 6 ## -1.456943382 -1.018246796 0.008625895 -0.745907415 1.552082406 -1.599191308 # residuals(fm) # with(fm, residuals) 予測値は次のコマンドを実施する. head(fitted(fm)) ## 1 2 3 4 5 6 ## 11.16229 10.84730 10.56691 10.80326 10.55394 10.50580 # fitted.values(fm) # with(fm, fitted.values) 残差自乗和は次のコマンドを実施する. deviance(fm) ## [1] 91.65505 sum(resid(fm)^2) ## [1] 91.65505 7.1.1 ティー検定 その結果を見るには summary を実施する. summary(fm) ## ## Call: ## lm(formula = y ~ x, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -2.7170 -0.7208 0.1273 0.6365 2.4806 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 10.1753 0.1985 51.269 &lt; 2e-16 *** ## x 1.6379 0.3442 4.759 6.7e-06 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.9671 on 98 degrees of freedom ## Multiple R-squared: 0.1877, Adjusted R-squared: 0.1795 ## F-statistic: 22.65 on 1 and 98 DF, p-value: 6.704e-06 これをみれば各変数の係数がゼロのティー検定の結果が示されている. 他にも, 残差標準誤差, 決定係数, 修正済み決定係数, 全ての係数がゼロであるエフ検定の結果も示されている. summary(fm) もリストであり, それぞれの要素は以下である. typeof(summary(fm)) ## [1] &quot;list&quot; names(summary(fm)) ## [1] &quot;call&quot; &quot;terms&quot; &quot;residuals&quot; &quot;coefficients&quot; ## [5] &quot;aliased&quot; &quot;sigma&quot; &quot;df&quot; &quot;r.squared&quot; ## [9] &quot;adj.r.squared&quot; &quot;fstatistic&quot; &quot;cov.unscaled&quot; 単なる fm と同じ名前もあるが, 中身が違っている場合もある. 例えば residuals は同じであるが, 係数はより情報が加わっている. coef(summary(fm)) ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 10.175303 0.1984690 51.268980 1.375148e-72 ## x 1.637939 0.3441544 4.759316 6.704460e-06 # coefficients(summary(fm)) 残差の標準誤差は次のようにして得られる. with(summary(fm),sigma) ## [1] 0.9670861 sqrt(deviance(fm)/df.residual(fm)) ## [1] 0.9670861 決定係数は次のようにして計算する. with(summary(fm),r.squared) ## [1] 0.1877404 1-deviance(fm)/with(df, sum((y-mean(y))^2)) ## [1] 0.1877404 調整済み決定係数は次のようにして計算する. with(summary(fm),adj.r.squared) ## [1] 0.1794521 1-(deviance(fm)/df.residual(fm))/with(df, sum((y-mean(y))^2/(nrow(df)-1))) ## [1] 0.1794521 7.1.2 対数変換 次のモデルを考える. \\[ y = \\alpha + \\beta \\log(x) + u \\] 対数変換をおこなう場合, log を用いるとよい. fm &lt;- lm(y~log(x),data=df) summary(fm) ## ## Call: ## lm(formula = y ~ log(x), data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -2.32100 -0.76612 0.05587 0.65795 2.74756 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 11.4138 0.1493 76.439 &lt; 2e-16 *** ## log(x) 0.4377 0.1170 3.742 0.000308 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 1.004 on 98 degrees of freedom ## Multiple R-squared: 0.125, Adjusted R-squared: 0.1161 ## F-statistic: 14 on 1 and 98 DF, p-value: 0.0003082 作図すると以下のようになる. plot(y~log(x),data=df) abline(fm) 被説明変数が対数の場合も同様である. fm &lt;- lm(log(y)~x,data=df) summary(fm) ## ## Call: ## lm(formula = log(y) ~ x, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.25872 -0.06652 0.01463 0.06128 0.19698 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 2.31891 0.01816 127.674 &lt;2e-16 *** ## x 0.14758 0.03150 4.686 9e-06 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.0885 on 98 degrees of freedom ## Multiple R-squared: 0.183, Adjusted R-squared: 0.1747 ## F-statistic: 21.96 on 1 and 98 DF, p-value: 9.001e-06 作図すると以下のようになる. plot(log(y)~x,data=df) abline(fm) 7.1.3 切片なし回帰モデル 次のモデルを考える. \\[ y = \\beta x + u \\] 切片なしモデルを推定したい場合は次のように -1 とする. fm &lt;- lm(y~x-1,data=df) summary(fm) ## ## Call: ## lm(formula = y ~ x - 1, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -7.9048 -0.7399 1.9294 5.8755 10.9723 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## x 17.0459 0.8801 19.37 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 5.075 on 99 degrees of freedom ## Multiple R-squared: 0.7912, Adjusted R-squared: 0.7891 ## F-statistic: 375.2 on 1 and 99 DF, p-value: &lt; 2.2e-16 もしくは +0 を加える. fm &lt;- lm(y~x+0,data=df) summary(fm) ## ## Call: ## lm(formula = y ~ x + 0, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -7.9048 -0.7399 1.9294 5.8755 10.9723 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## x 17.0459 0.8801 19.37 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 5.075 on 99 degrees of freedom ## Multiple R-squared: 0.7912, Adjusted R-squared: 0.7891 ## F-statistic: 375.2 on 1 and 99 DF, p-value: &lt; 2.2e-16 7.2 重回帰モデル 説明変数として \\(w\\) を加えたモデルを考える. \\[ y = \\alpha + \\beta x +\\gamma w+ u \\] 暗黙に次の仮定を置いている. \\((w_i, x_i,y_i)\\) は独立同一分布にしたがう. 誤差項の期待値はゼロである. \\(E[u_i]=0\\) である. 誤差項 \\(u_i\\) は説明変数 \\((x_i, w_i)\\) に対して独立である. 誤差項 \\(u_i\\) は正規分布にしたがう. 説明変数間に多重共線性は存在しない. つまり \\(x_i\\) は \\(w_i\\) の一次変換で表せない. 仮想的に以下のモデルを考える. N &lt;- 100 x&lt;-runif(N) w&lt;-sample(c(&quot;H&quot;,&quot;T&quot;),N,replace=TRUE) y &lt;- 10 + 2*x + ifelse(w==&quot;H&quot;,1,0) + rnorm(N) df &lt;- data.frame(w,x,y) 作図すると以下である. plot(y~x) 説明変数を加えたいときには + と変数名を使うことができる. fm &lt;- lm(y~x+w,data=df) summary(fm) ## ## Call: ## lm(formula = y ~ x + w, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -2.65280 -0.55880 -0.07384 0.59757 2.27899 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 10.5944 0.2093 50.627 &lt; 2e-16 *** ## x 2.7300 0.3225 8.466 2.72e-13 *** ## wT -0.7277 0.1971 -3.692 0.000368 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.9729 on 97 degrees of freedom ## Multiple R-squared: 0.4661, Adjusted R-squared: 0.4551 ## F-statistic: 42.34 on 2 and 97 DF, p-value: 6.052e-14 R の特徴は因子もとくに変換することなくダミー変数として扱える. 7.2.1 自乗項 説明変数として自乗項を加えたモデルを考える. \\[ y = \\alpha + \\beta x + \\gamma x^2 + u \\] R では単に自乗するのでなく I(x^2) としなければならない. fm &lt;- lm(y~x+I(x^2),data=df) summary(fm) ## ## Call: ## lm(formula = y ~ x + I(x^2), data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -2.44137 -0.60700 0.00071 0.59665 2.69090 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 9.9837 0.2969 33.623 &lt; 2e-16 *** ## x 4.5784 1.3347 3.430 0.000887 *** ## I(x^2) -1.8156 1.2595 -1.442 0.152639 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 1.028 on 97 degrees of freedom ## Multiple R-squared: 0.4039, Adjusted R-squared: 0.3916 ## F-statistic: 32.86 on 2 and 97 DF, p-value: 1.272e-11 7.2.2 交差項 説明変数として交差項を加えたモデルを考える. \\[ y = \\alpha + \\beta x + \\gamma w + \\delta xw + u \\] 説明変数 x と wの自乗項は自乗項は x:w である. fm&lt;-lm(y~x+w+x:w,data=df) summary(fm) ## ## Call: ## lm(formula = y ~ x + w + x:w, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -2.6898 -0.5470 -0.0726 0.6292 2.2415 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 10.5440 0.2545 41.432 &lt; 2e-16 *** ## x 2.8281 0.4276 6.615 2.11e-09 *** ## wT -0.6084 0.3926 -1.550 0.124 ## x:wT -0.2305 0.6551 -0.352 0.726 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.9773 on 96 degrees of freedom ## Multiple R-squared: 0.4668, Adjusted R-squared: 0.4501 ## F-statistic: 28.01 on 3 and 96 DF, p-value: 4.239e-13 もしくは以下のように * を使って簡便的に表せる. fm &lt;- lm(y~x*w,data=df) summary(fm) ## ## Call: ## lm(formula = y ~ x * w, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -2.6898 -0.5470 -0.0726 0.6292 2.2415 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 10.5440 0.2545 41.432 &lt; 2e-16 *** ## x 2.8281 0.4276 6.615 2.11e-09 *** ## wT -0.6084 0.3926 -1.550 0.124 ## x:wT -0.2305 0.6551 -0.352 0.726 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.9773 on 96 degrees of freedom ## Multiple R-squared: 0.4668, Adjusted R-squared: 0.4501 ## F-statistic: 28.01 on 3 and 96 DF, p-value: 4.239e-13 7.2.3 エフ検定 今, 帰無仮説が \\[ y = \\alpha + \\beta x + u \\] で, 対立仮説が \\[ y = \\alpha + \\beta x + \\gamma w + \\delta xw + u \\] となる検定を実施したい. これは複数の係数がゼロであるエフ検定である. 対立仮説の残差自乗和を \\(SSR\\) とし, その自由度を \\(df\\) とする. 自由度は観測数から説明変数の数を減じた数である. 帰無仮説の残差自乗和を \\(SSR_0\\) とし, 制約の数を \\(q\\) とする. 制約の数は帰無仮説の自由度から帰無仮説の自由度を差し引いた数である. このとき, 以下のF値は帰無仮説が正しいもと自由度 \\(df\\) と \\(q\\) のF分布にしたがう. \\[ \\frac{(SSR_0-SSR)/q}{SSR/df} \\] R でF値は次のようにして算出する. fm0 &lt;- lm(y~x,data=df) fm1 &lt;- lm(y~x*w,data=df) dof &lt;- fm1$df q &lt;- fm0$df-dof SSR0 &lt;- deviance(fm0) SSR &lt;- deviance(fm1) (F &lt;- ((SSR0-SSR)/q)/(SSR/dof)) ## [1] 6.814768 この時のP値は以下である. 1-pf(F,df1=q,df2=dof) ## [1] 0.00170803 これらの手順はコマンド anova を用いれば簡単に実現できる. anova(fm0,fm1) ## Analysis of Variance Table ## ## Model 1: y ~ x ## Model 2: y ~ x * w ## Res.Df RSS Df Sum of Sq F Pr(&gt;F) ## 1 98 104.707 ## 2 96 91.689 2 13.018 6.8148 0.001708 ** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 順番を変えても, 検定統計量自体に変更はない. anova(fm1,fm0) ## Analysis of Variance Table ## ## Model 1: y ~ x * w ## Model 2: y ~ x ## Res.Df RSS Df Sum of Sq F Pr(&gt;F) ## 1 96 91.689 ## 2 98 104.707 -2 -13.018 6.8148 0.001708 ** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 "],
["08-regression2.html", "8 現代的仮定のもとでの最小二乗法 8.1 正規性の仮定について 8.2 誤差項と説明変数が独立の仮定について 8.3 分散均一の検定", " 8 現代的仮定のもとでの最小二乗法 library(AER) 前節において以下の仮定を置いていた. \\((x_i,y_i)\\) は独立同一分布にしたがう. \\(E[u_i]=0\\) である. \\(u_i\\) と \\(x_i\\) は独立である. \\(u_i\\) は正規分布にしたがう. これらの仮定を緩めることで分析にどのような影響をあたえるのかを見ていく. 仮想的に以下のモデルを考える. N &lt;- 100 x&lt;-runif(N) w&lt;-sample(c(&quot;H&quot;,&quot;T&quot;),N,replace=TRUE) y &lt;- 10 + 2*x + ifelse(w==&quot;H&quot;,1,0) + rnorm(N) df &lt;- data.frame(w,x,y) 作図すると以下である. plot(y~x) 8.1 正規性の仮定について 十分な観測値が得られるばあい, \\(u_i\\) が正規分布にしたがっていないくても, 中心極限定理定理より, 最小二乗法推定量は正規分布に近似できる. ここの係数ゼロのティー検定について, ライブラリ AER を導入して coeftest を用いればよい. fm1 &lt;- lm(y~x+w,data=df) fm0 &lt;- lm(y~x,data=df) coeftest(fm1,df=Inf) ## ## z test of coefficients: ## ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 11.05648 0.22518 49.1000 &lt; 2.2e-16 *** ## x 1.69837 0.33519 5.0669 4.044e-07 *** ## wT -0.69855 0.18538 -3.7683 0.0001644 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ただ十分なデータのもとではティー値のままでもよい. 同様に複数制約の場合, エフ検定統計量に制約の数を乗じた統計量が 自由度が制約数のカイ二乗分布にしたがうことが知られている. これをR で実施するには waldtest を用いればよい. waldtest(fm0,fm1,test=&quot;Chisq&quot;) ## Wald test ## ## Model 1: y ~ x ## Model 2: y ~ x + w ## Res.Df Df Chisq Pr(&gt;Chisq) ## 1 98 ## 2 97 1 14.2 0.0001644 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 エフ検定も十分なデータのもとではそのままでよいであろう. オプション test を付けなければエフ検定を実施する. waldtest(fm0,fm1) ## Wald test ## ## Model 1: y ~ x ## Model 2: y ~ x + w ## Res.Df Df F Pr(&gt;F) ## 1 98 ## 2 97 1 14.2 0.0002823 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 これは anova と同じである. anova(fm0,fm1) ## Analysis of Variance Table ## ## Model 1: y ~ x ## Model 2: y ~ x + w ## Res.Df RSS Df Sum of Sq F Pr(&gt;F) ## 1 98 93.317 ## 2 97 81.401 1 11.916 14.2 0.0002823 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 複数制約の検定としてLM検定というのもある. 制約付きの回帰分析を実行し, その残差を制約なしのモデルの説明変数に回帰する. その決定係数に観測数を掛けた統計量が自由どが制約の数のカイ二乗分布にしたがうことが知られている. lmt &lt;- lm(I(resid(fm1))~w*x,data=df) (lmt &lt;- nrow(df)*summary(lmt)$r.squared) ## [1] 8.881425 1-pchisq(lmt,df=1) ## [1] 0.002880866 8.2 誤差項と説明変数が独立の仮定について また \\(u_i\\) と \\(x_i\\) は独立でなく, \\(u_i\\) と \\(x_i\\) が無相関という弱い条件のもとでも, 一致推定量であることが知られている. ただ不偏推定量は保証できない. また 線形推定量のなかで最小の分散とも言えない.5 また独立のときの標準誤差の推定量が一致推定量でない. ただし, 別の分散のもとで正規分布に近似できることがしられている.6 つまり, 説明変数と誤差項が無相関であるが, 独立とまでは言い切れない場合, 最小二乗推定量を実行した際, 別の方法で分散を推定する必要がある. この別の分散をロバスト分散という. R でロバスト分散を推定するにはパッケージ AER を導入するのが簡単である. は次のコマンド coeftest を実行すればよい. coeftest(fm1,vcov=vcovHC) ## ## t test of coefficients: ## ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 11.05648 0.23692 46.6667 &lt; 2.2e-16 *** ## x 1.69837 0.34558 4.9145 3.617e-06 *** ## wT -0.69855 0.19262 -3.6267 0.0004599 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 先の値と標準誤差が違っていることが確認できるであろう. ただこの値は STATA と少し異なっている. STATA と同じにするには coeftest(fm1,vcov=vcovHC(fm1,type=&quot;HC1&quot;)) ## ## t test of coefficients: ## ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 11.05648 0.23103 47.8564 &lt; 2.2e-16 *** ## x 1.69837 0.33754 5.0316 2.235e-06 *** ## wT -0.69855 0.18943 -3.6877 0.0003733 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 としなければならない. またティー分布でなく正規分布とすることもできる. coeftest(fm0,vcov=vcovHC,df=Inf) ## ## z test of coefficients: ## ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 10.60003 0.17982 58.9464 &lt; 2.2e-16 *** ## x 1.88421 0.35095 5.3688 7.925e-08 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 複数の係数についての検定は waldtest を実行すればよい. waldtest(fm0,fm1,vcov=vcovHC) ## Wald test ## ## Model 1: y ~ x ## Model 2: y ~ x + w ## Res.Df Df F Pr(&gt;F) ## 1 98 ## 2 97 1 13.153 0.0004599 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 先の結果はエフ検定であるが, カイ二乗検定を実施するには以下を実施すればよい. waldtest(fm0,fm1,vcov=vcovHC, test=&quot;Chisq&quot;) ## Wald test ## ## Model 1: y ~ x ## Model 2: y ~ x + w ## Res.Df Df Chisq Pr(&gt;Chisq) ## 1 98 ## 2 97 1 13.153 0.0002871 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 8.3 分散均一の検定 誤差項が説明変数と独立のときと無相関のときでは標準誤差の推定量が異なる. 正確にいうと, 条件付き分散が説明変数に依存するかどうかによって標準誤差の推定量が異なる. このことは分散均一と呼ばれている. 誤差項の分散が均一かどうかは検定可能である. 有名な検定方法としてBP (Breusch-Pagan) 検定というものがある. BP検定は帰無仮説が分散均一で, 対立仮説が分散が説明変数と線形関係になっている場合の検定である. 残差の自乗を被説明変数として回帰分析をおこない, その決定係数に観測数をかけたものが検定統計量となる. bpt &lt;- lm(I(resid(fm1)^2)~w*x,data=df) (bpt &lt;- nrow(df)*summary(bpt)$r.squared) ## [1] 3.194558 1-pchisq(bpt,df=3) ## [1] 0.3625899 ここでの例ではP値が5%を超えているので帰無仮説を棄却できないので, 分散均一を仮定してよいことが示唆されている. R では以下のように実施すればよい. bptest(fm1) ## ## studentized Breusch-Pagan test ## ## data: fm1 ## BP = 0.70498, df = 2, p-value = 0.7029 これまでのBPテストは誤差項の分散が説明変数の線形関係あることを暗黙に仮定している. 非線形性を考慮するために説明変数の二次項を導入した分散不均一性の検定をホワイト検定という. 説明変数が複数ある場合ホワイト検定は煩雑になるため, 被説明変数の予測値を使って計算することがある. そのときホワイトテストは以下で実施する. wht &lt;- lm(I(resid(fm1)^2)~fitted(fm1)+I(fitted(fm1)^2),data=df) (wht &lt;- nrow(df)*summary(wht)$r.squared) ## [1] 1.834542 1-pchisq(wht,df=2) ## [1] 0.3996081 ホワイト検定でも分散均一が示唆されている. もしくは以下を実行する. bptest(fm1,~fitted(fm1)+I(fitted(fm1)^2)) ## ## studentized Breusch-Pagan test ## ## data: fm1 ## BP = 1.8345, df = 2, p-value = 0.3996 このように分散均一性は検定することが可能であるが, そもそも分散均一が疑われる場合は, ロバスト分散で推定するので十分であるため最近の実証分析ではこの検定は実施されない. 正確にいえば, 不偏推定量のとめには条件付き期待値が説明変数に依存しないことが必要である. また線形推定量のなかで最小の分散になるためには 条件付き分散が説明変数に依存しないことが必要である. ↩︎ 正確には観測される変数に4次のモーメントが存在するという仮定が必要となる. この仮定の直感的な意味は異常値が存在しないことである.↩︎ "],
["09-ivreg.html", "9 操作変数法 9.1 データ 9.2 操作変数 9.3 2段階最小二乗法 9.4 特定化検定 9.5 ロバスト分散", " 9 操作変数法 9.1 データ library(AER) library(wooldridge) data(&quot;mroz&quot;, package=&quot;wooldridge&quot;) df &lt;- subset(mroz, inlf==1) 9.2 操作変数 これまで回帰モデルで一致推定量を得るためには次の仮定が必要であった. 母集団が線形モデル 標本が無作為抽出 誤差項が平均ゼロで説明変数と無相関 説明変数に多重共線性が存在しない 3つ目の説明変数が必ずしも成立しない場合の推定方法を紹介する. そのために, 外生変数と内生変数と操作変数の3つの概念を導入する. 説明変数を外生変数と内生変数に分ける. 誤差項と相関が無い説明変数を 外生変数 といい, 誤差項と相関がある説明変数を 内生変数 という. 操作変数 とは, 説明変数に含まれず, 説明変数と相関をもち, 誤差項と相関をもたない変数のことである. なお操作変数の個数は内生変数の個数より多いと仮定する. R においては次のコマンドを実行すればよい. ここで被説明変数は log(wage), 内生変数は educ, 操作変数は fatheduc である. fm &lt;- ivreg(log(wage)~educ|fatheduc, data=df) coef(fm) ## (Intercept) educ ## 0.44110339 0.05917348 傾きの推定値は以下でも実行可能である. with(df, cov(log(wage),fatheduc)/cov(educ,fatheduc)) ## [1] 0.05917348 9.3 2段階最小二乗法 説明変数が複数あり, 操作変数の数が内生変数の数以上のとき, 係数の一致推定量を得るには二段階最小自乗法を用いる. 二段階最小二乗法は次の手順で実行される: それぞれの内生変数を外生変数と操作変数に回帰させて, その予測値を得る. 被説明変数を外生変数と内生変数の予測値に回帰させて, その係数を得る. この係数が一致推定量になるための条件は以下である. 母集団が線形モデル 標本が無作為抽出 誤差項が平均ゼロで操作変数と外生変数に対して独立. 操作変数は内生変数と相関をもつ. 外生変数と内生変数の予測値に多重共線性が存在しない` R においては次のコマンドを実行すればよい. ここで被説明変数は log(wage), 内生変数は educ, 外生変数は expr, I(expr^2), 操作変数は motheduc, fatheduc である. fm &lt;- ivreg(log(wage)~educ+exper+I(exper^2)| exper+I(exper^2)+motheduc+fatheduc, data=df) summary(fm) ## ## Call: ## ivreg(formula = log(wage) ~ educ + exper + I(exper^2) | exper + ## I(exper^2) + motheduc + fatheduc, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -3.0986 -0.3196 0.0551 0.3689 2.3493 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.0481003 0.4003281 0.120 0.90442 ## educ 0.0613966 0.0314367 1.953 0.05147 . ## exper 0.0441704 0.0134325 3.288 0.00109 ** ## I(exper^2) -0.0008990 0.0004017 -2.238 0.02574 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.6747 on 424 degrees of freedom ## Multiple R-Squared: 0.1357, Adjusted R-squared: 0.1296 ## Wald test: 8.141 on 3 and 424 DF, p-value: 2.787e-05 実際の二段階最小二乗法でも確認できる. ただし標準誤差の値が異なっている. なぜなら残差は内生変数および外生変数から算出させる必要があるが, 以下のやりかただと内生変数の予測値および外生変数から算出するためである. ols1 &lt;- lm(educ~exper+I(exper^2)+motheduc+fatheduc, data = df) ols2 &lt;- lm(log(wage)~fitted(ols1)+exper+I(exper^2), data = df) summary(ols2) ## ## Call: ## lm(formula = log(wage) ~ fitted(ols1) + exper + I(exper^2), data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -3.1631 -0.3539 0.0326 0.3818 2.3727 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.0481003 0.4197565 0.115 0.90882 ## fitted(ols1) 0.0613966 0.0329624 1.863 0.06321 . ## exper 0.0441704 0.0140844 3.136 0.00183 ** ## I(exper^2) -0.0008990 0.0004212 -2.134 0.03338 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.7075 on 424 degrees of freedom ## Multiple R-squared: 0.04978, Adjusted R-squared: 0.04306 ## F-statistic: 7.405 on 3 and 424 DF, p-value: 7.615e-05 9.3.1 複数制約の検定 帰無仮説が複数制約のワルド検定は以下のように実施する. 例えば, 2つの外生変数の係数がゼロのときの仮説検定をRで実行するには以下を実施する. fm0 &lt;- ivreg(log(wage)~educ|motheduc+fatheduc,data=df) waldtest(fm0,fm) ## Wald test ## ## Model 1: log(wage) ~ educ | motheduc + fatheduc ## Model 2: log(wage) ~ educ + exper + I(exper^2) | exper + I(exper^2) + ## motheduc + fatheduc ## Res.Df Df Chisq Pr(&gt;Chisq) ## 1 426 ## 2 424 2 19.639 5.439e-05 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 LM検定は以下のように実施すればよい. lmt &lt;- lm(resid(fm0)~educ + exper + I(exper^2) ,data=df) (lmt &lt;- nrow(df)*summary(lmt)$r.squared) ## [1] 33.97987 1-pchisq(lmt,df=3) ## [1] 2.000665e-07 9.4 特定化検定 またいくつかの特定化検定も以下のコマンドで実施できる. summary(fm, diagnostics = TRUE) ## ## Call: ## ivreg(formula = log(wage) ~ educ + exper + I(exper^2) | exper + ## I(exper^2) + motheduc + fatheduc, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -3.0986 -0.3196 0.0551 0.3689 2.3493 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.0481003 0.4003281 0.120 0.90442 ## educ 0.0613966 0.0314367 1.953 0.05147 . ## exper 0.0441704 0.0134325 3.288 0.00109 ** ## I(exper^2) -0.0008990 0.0004017 -2.238 0.02574 * ## ## Diagnostic tests: ## df1 df2 statistic p-value ## Weak instruments 2 423 55.400 &lt;2e-16 *** ## Wu-Hausman 1 423 2.793 0.0954 . ## Sargan 1 NA 0.378 0.5386 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.6747 on 424 degrees of freedom ## Multiple R-Squared: 0.1357, Adjusted R-squared: 0.1296 ## Wald test: 8.141 on 3 and 424 DF, p-value: 2.787e-05 9.4.1 Weak instruments 操作変数が内生変数と弱い相関関係しかない場合, 弱操作変数という. それぞれの内生変数に対して, 帰無仮説を内生変数を外生変数のみ回帰させたモデルとし, 対立仮説を内生変数を外生変数および操作変数のみ回帰させたモデルとし, F検定を実施する. ols0 &lt;- lm(educ ~ exper + I(exper^2), data = df) anova(ols0, ols1) ## Analysis of Variance Table ## ## Model 1: educ ~ exper + I(exper^2) ## Model 2: educ ~ exper + I(exper^2) + motheduc + fatheduc ## Res.Df RSS Df Sum of Sq F Pr(&gt;F) ## 1 425 2219.2 ## 2 423 1758.6 2 460.64 55.4 &lt; 2.2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 9.4.2 Wu-Hausman 検定 Wu-Hausman 検定は 帰無仮説が誤差項と説明変数が無相関, 対立仮説が誤差項と説明変数が相関ありの検定をおこなう. 帰無仮説のもと, OLSも2SLSも一致推定量である. よって検定統計量のP値が十分小さいなら, 帰無仮説は棄却して, より効率的な最小二乗法を実施する. そうでなければ操作変数法を選択する. 具体的には以下のF検定を実施する. それぞれの内生変数を外生変数に回帰したときの残差を得る. (resid(ols1)) 被説明変数を説明変数に回帰する (ols3) 被説明変数を説明変数および先程の残差に回帰する (ols4) これらの残差の係数はゼロであるという帰無仮説のもとF検定を実施する. ols3 &lt;- lm(log(wage) ~ educ + exper + I(exper^2), data = df) ols4 &lt;- update(ols3, . ~ . + resid(ols1)) anova(ols3,ols4) ## Analysis of Variance Table ## ## Model 1: log(wage) ~ educ + exper + I(exper^2) ## Model 2: log(wage) ~ educ + exper + I(exper^2) + resid(ols1) ## Res.Df RSS Df Sum of Sq F Pr(&gt;F) ## 1 424 188.31 ## 2 423 187.07 1 1.235 2.7926 0.09544 . ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 9.4.3 Sargan 検定 Sargan 検定は 誤差項が操作変数 (および外生変数) と相関しているかどうかを検定する. 帰無仮説が相関が無い場合で, 対立仮説は相関がある場合である. LM検定を実施する. 二段階最小二乗法を実施したときの残差を得る. (resid(fm)) 残差を外生変数および操作変数に回帰する. 回帰の決定係数に観測数を乗じたLM統計量をえる. 検定統計量は, 帰無仮説のもと, 操作変数の数から内生変数の数を差し引いた自由度のカイ二乗分布にしたがう. jt &lt;- lm(resid(fm)~exper+I(exper^2)+motheduc+fatheduc,data=df) (jt &lt;- nrow(df)*summary(jt)$r.squared) ## [1] 0.3780714 1-pchisq(jt,df=1) ## [1] 0.5386372 9.5 ロバスト分散 以上の分析は, 誤差項が操作変数と独立の場合の分析である. 独立でない場合, 推定量の分散が変わりうる. そうした分散をロバスト分散という. ロバスト分散にもとづく, 推定結果は次のコマンドで実施する. summary(fm, vcov = vcovHC, df = Inf) ## ## Call: ## ivreg(formula = log(wage) ~ educ + exper + I(exper^2) | exper + ## I(exper^2) + motheduc + fatheduc, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -3.0986 -0.3196 0.0551 0.3689 2.3493 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 0.0481003 0.4337795 0.111 0.91171 ## educ 0.0613966 0.0336597 1.824 0.06815 . ## exper 0.0441704 0.0157661 2.802 0.00508 ** ## I(exper^2) -0.0008990 0.0004391 -2.047 0.04062 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.6747 on Inf degrees of freedom ## Multiple R-Squared: 0.1357, Adjusted R-squared: 0.1296 ## Wald test: 18.11 on 3 DF, p-value: 0.0004168 また次のコマンドで係数結果のみ出力可能である. coeftest(fm, vcov=vcovHC) ## ## t test of coefficients: ## ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.04810030 0.43377952 0.1109 0.911759 ## educ 0.06139663 0.03365975 1.8240 0.068850 . ## exper 0.04417039 0.01576605 2.8016 0.005318 ** ## I(exper^2) -0.00089897 0.00043908 -2.0474 0.041233 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ロバスト分散のもとでの複数制約の検定は以下を実施する. waldtest(fm0,fm, vcov=vcovHC) ## Wald test ## ## Model 1: log(wage) ~ educ | motheduc + fatheduc ## Model 2: log(wage) ~ educ + exper + I(exper^2) | exper + I(exper^2) + ## motheduc + fatheduc ## Res.Df Df Chisq Pr(&gt;Chisq) ## 1 426 ## 2 424 2 14.582 0.0006816 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 9.5.1 分散不均一の検定 誤差項が操作変数と独立なら条件付き分散は操作変数に無関係で均一である. これを利用して分散均一を帰無仮説に, 分散不均一を対立仮説にしたBP検定が実行可能である. ただ通常のコマンド bptest では正しく実行できないので注意が必要である. bpt &lt;- lm(I(resid(fm)^2)~exper + I(exper^2) + motheduc + fatheduc,data=df) (bpt &lt;- nrow(df)*summary(bpt)$r.squared) ## [1] 12.41758 1-pchisq(bpt,df=4) ## [1] 0.01450172 "],
["10-panel.html", "10 パネル分析 10.1 データ 10.2 プーリングOLS 10.3 固定効果モデル (平均差分法) 10.4 固定効果モデル (一階差分法) 10.5 変量効果モデル 10.6 クラスターロバスト分散", " 10 パネル分析 10.1 データ library(AER) library(plm) data(&quot;Grunfeld&quot;, package = &quot;plm&quot;) head(Grunfeld) ## firm year inv value capital ## 1 1 1935 317.6 3078.5 2.8 ## 2 1 1936 391.8 4661.7 52.6 ## 3 1 1937 410.6 5387.1 156.9 ## 4 1 1938 257.7 2792.2 209.2 ## 5 1 1939 330.8 4313.2 203.4 ## 6 1 1940 461.2 4643.9 207.2 pdata &lt;- pdata.frame(Grunfeld, index = c(&quot;firm&quot;, &quot;year&quot;)) pdim(pdata) ## Balanced Panel: n = 10, T = 20, N = 200 10.2 プーリングOLS \\[ inv_{it} = \\beta_0 + \\beta_1 value_{it} + \\beta_2 capital_{it} + u_{it} \\] 誤差項 \\(u_{it}\\) は \\(i\\) についても \\(t\\) についても独立同一分布と仮定する. さらに誤差項は説明変数と独立である. この推計は以下のようにする. gp &lt;- plm(inv ~ value + capital, data = pdata, model = &quot;pooling&quot;) summary(gp) ## Pooling Model ## ## Call: ## plm(formula = inv ~ value + capital, data = pdata, model = &quot;pooling&quot;) ## ## Balanced Panel: n = 10, T = 20, N = 200 ## ## Residuals: ## Min. 1st Qu. Median 3rd Qu. Max. ## -291.6757 -30.0137 5.3033 34.8293 369.4464 ## ## Coefficients: ## Estimate Std. Error t-value Pr(&gt;|t|) ## (Intercept) -42.7143694 9.5116760 -4.4907 1.207e-05 *** ## value 0.1155622 0.0058357 19.8026 &lt; 2.2e-16 *** ## capital 0.2306785 0.0254758 9.0548 &lt; 2.2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Total Sum of Squares: 9359900 ## Residual Sum of Squares: 1755900 ## R-Squared: 0.81241 ## Adj. R-Squared: 0.8105 ## F-statistic: 426.576 on 2 and 197 DF, p-value: &lt; 2.22e-16 これは以下の回帰分析と同じである. summary(lm(inv ~ value + capital, data = pdata)) ## ## Call: ## lm(formula = inv ~ value + capital, data = pdata) ## ## Residuals: ## Min 1Q Median 3Q Max ## -291.68 -30.01 5.30 34.83 369.45 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -42.714369 9.511676 -4.491 1.21e-05 *** ## value 0.115562 0.005836 19.803 &lt; 2e-16 *** ## capital 0.230678 0.025476 9.055 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 94.41 on 197 degrees of freedom ## Multiple R-squared: 0.8124, Adjusted R-squared: 0.8105 ## F-statistic: 426.6 on 2 and 197 DF, p-value: &lt; 2.2e-16 10.3 固定効果モデル (平均差分法) 次のモデルを考える. \\[ inv_{it} = \\beta_1 value_{it} + \\beta_2 capital_{it} +\\alpha_i + u_{it} \\] この \\(\\alpha_i\\) は固定効果と呼ばれている. \\(\\alpha_i\\) は時間 \\(t\\) に対して一定である. \\(\\alpha_i\\) は誤差項と相関があるもしれない. それぞれの時間平均をとれば以下になる. \\[ \\bar{inv}_{i} = \\beta_1 \\bar{value}_{i} + \\beta_2 \\bar{capital}_{i} +\\alpha_i + \\bar{u}_{i} \\] そして，それぞれの観測値を時間平均で差し引けば以下のように \\(\\alpha_i\\) は消去される. \\[ inv_{it}-\\overline{inv}_{i} = \\beta_1 (value_{it}-\\overline{value}_{i}) + \\beta_2 (capital_{it}-\\overline{capital}_{i}) + \\bar{u}_{i} -\\bar{u}_{i} \\] このように変換して回帰分析すれば \\(\\alpha_i\\) は誤差項と相関があっても一致推定量である. この推計は以下のようにする. gi &lt;- plm(inv ~ value + capital, data = pdata, model = &quot;within&quot;) summary(gi) ## Oneway (individual) effect Within Model ## ## Call: ## plm(formula = inv ~ value + capital, data = pdata, model = &quot;within&quot;) ## ## Balanced Panel: n = 10, T = 20, N = 200 ## ## Residuals: ## Min. 1st Qu. Median 3rd Qu. Max. ## -184.00857 -17.64316 0.56337 19.19222 250.70974 ## ## Coefficients: ## Estimate Std. Error t-value Pr(&gt;|t|) ## value 0.110124 0.011857 9.2879 &lt; 2.2e-16 *** ## capital 0.310065 0.017355 17.8666 &lt; 2.2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Total Sum of Squares: 2244400 ## Residual Sum of Squares: 523480 ## R-Squared: 0.76676 ## Adj. R-Squared: 0.75311 ## F-statistic: 309.014 on 2 and 188 DF, p-value: &lt; 2.22e-16 固定効果は以下のコマンドで確かめられる. fixef(gi) ## 1 2 3 4 5 6 7 8 ## -70.2967 101.9058 -235.5718 -27.8093 -114.6168 -23.1613 -66.5535 -57.5457 ## 9 10 ## -87.2223 -6.5678 これは以下の回帰分析と同じである. summary(lm(inv ~ value + capital+0+factor(firm), data = pdata)) ## ## Call: ## lm(formula = inv ~ value + capital + 0 + factor(firm), data = pdata) ## ## Residuals: ## Min 1Q Median 3Q Max ## -184.009 -17.643 0.563 19.192 250.710 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## value 0.11012 0.01186 9.288 &lt; 2e-16 *** ## capital 0.31007 0.01735 17.867 &lt; 2e-16 *** ## factor(firm)1 -70.29672 49.70796 -1.414 0.1590 ## factor(firm)2 101.90581 24.93832 4.086 6.49e-05 *** ## factor(firm)3 -235.57184 24.43162 -9.642 &lt; 2e-16 *** ## factor(firm)4 -27.80929 14.07775 -1.975 0.0497 * ## factor(firm)5 -114.61681 14.16543 -8.091 7.14e-14 *** ## factor(firm)6 -23.16130 12.66874 -1.828 0.0691 . ## factor(firm)7 -66.55347 12.84297 -5.182 5.63e-07 *** ## factor(firm)8 -57.54566 13.99315 -4.112 5.85e-05 *** ## factor(firm)9 -87.22227 12.89189 -6.766 1.63e-10 *** ## factor(firm)10 -6.56784 11.82689 -0.555 0.5793 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 52.77 on 188 degrees of freedom ## Multiple R-squared: 0.9616, Adjusted R-squared: 0.9591 ## F-statistic: 392 on 12 and 188 DF, p-value: &lt; 2.2e-16 決定係数が大きく異なっていることに注意されたい. 10.3.1 時間効果 次のモデルを考える. \\[ inv_{it} = \\beta_1 value_{it} + \\beta_2 capital_{it}+ \\gamma_t +\\alpha_i + u_{it} \\] この \\(\\gamma_t\\) は時間効果と呼ばれている. この推計は以下のようにする. gi2 &lt;- plm(inv ~ value + capital, data = pdata, effect=&quot;twoways&quot;,model = &quot;within&quot;) summary(gi2) ## Twoways effects Within Model ## ## Call: ## plm(formula = inv ~ value + capital, data = pdata, effect = &quot;twoways&quot;, ## model = &quot;within&quot;) ## ## Balanced Panel: n = 10, T = 20, N = 200 ## ## Residuals: ## Min. 1st Qu. Median 3rd Qu. Max. ## -162.6094 -19.4710 -1.2669 19.1277 211.8420 ## ## Coefficients: ## Estimate Std. Error t-value Pr(&gt;|t|) ## value 0.117716 0.013751 8.5604 6.653e-15 *** ## capital 0.357916 0.022719 15.7540 &lt; 2.2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Total Sum of Squares: 1615600 ## Residual Sum of Squares: 452150 ## R-Squared: 0.72015 ## Adj. R-Squared: 0.67047 ## F-statistic: 217.442 on 2 and 169 DF, p-value: &lt; 2.22e-16 それぞれの効果は以下になる. fixef(gi2, effect = &quot;individual&quot;) ## 1 2 3 4 5 6 7 8 ## -134.2277 72.8265 -269.4585 -38.8739 -139.6663 -31.3391 -82.7611 -66.7372 ## 9 10 ## -104.0102 -7.3906 fixef(gi2, effect = &quot;time&quot;) ## 1935 1936 1937 1938 1939 1940 1941 1942 ## -32.836 -52.034 -73.526 -72.063 -102.307 -77.071 -51.641 -53.976 ## 1943 1944 1945 1946 1947 1948 1949 1950 ## -75.814 -75.935 -88.519 -64.006 -72.229 -76.553 -106.331 -108.732 ## 1951 1952 1953 1954 ## -95.317 -97.469 -100.554 -126.363 これは以下の回帰分析と同じである. lm(inv ~ value + capital+0+factor(firm)+factor(year), data = pdata) ## ## Call: ## lm(formula = inv ~ value + capital + 0 + factor(firm) + factor(year), ## data = pdata) ## ## Coefficients: ## value capital factor(firm)1 factor(firm)2 ## 0.1177 0.3579 -86.9002 120.1540 ## factor(firm)3 factor(firm)4 factor(firm)5 factor(firm)6 ## -222.1310 8.4536 -92.3388 15.9884 ## factor(firm)7 factor(firm)8 factor(firm)9 factor(firm)10 ## -35.4336 -19.4097 -56.6827 39.9369 ## factor(year)1936 factor(year)1937 factor(year)1938 factor(year)1939 ## -19.1974 -40.6900 -39.2264 -69.4703 ## factor(year)1940 factor(year)1941 factor(year)1942 factor(year)1943 ## -44.2351 -18.8045 -21.1398 -42.9776 ## factor(year)1944 factor(year)1945 factor(year)1946 factor(year)1947 ## -43.0988 -55.6830 -31.1693 -39.3922 ## factor(year)1948 factor(year)1949 factor(year)1950 factor(year)1951 ## -43.7165 -73.4951 -75.8961 -62.4809 ## factor(year)1952 factor(year)1953 factor(year)1954 ## -64.6323 -67.7180 -93.5262 決定係数が大きく異なっていることに注意されたい. 時間効果が有効かどうかは以下の検定を実施する. pFtest(gi2, gi) ## ## F test for twoways effects ## ## data: inv ~ value + capital ## F = 1.4032, df1 = 19, df2 = 169, p-value = 0.1309 ## alternative hypothesis: significant effects 10.3.2 固定効果VSプーリングOLS 帰無仮説が固定効果, 対立仮説が固定効果モデルの検定は以下のコマンドを実行すればよい. pFtest(gi,gp) ## ## F test for individual effects ## ## data: inv ~ value + capital ## F = 49.177, df1 = 9, df2 = 188, p-value &lt; 2.2e-16 ## alternative hypothesis: significant effects 時間効果をもつ固定効果モデルの場合は, 帰無仮説仮説に応じて変化する. もし帰無仮説が時間効果を持たないプーリングOLSモデルなら, 以下を実行する. pFtest(gi2, gp) ## ## F test for twoways effects ## ## data: inv ~ value + capital ## F = 17.403, df1 = 28, df2 = 169, p-value &lt; 2.2e-16 ## alternative hypothesis: significant effects もし帰無仮説が時間効果をもつモデルなら, 以下を実行する. 次のようにする. gpt &lt;- update(gp, . ~ . +factor(year)) pFtest(gi2,gpt) ## ## F test for twoways effects ## ## data: inv ~ value + capital ## F = 52.362, df1 = 9, df2 = 169, p-value &lt; 2.2e-16 ## alternative hypothesis: significant effects 10.4 固定効果モデル (一階差分法) 次のモデルを考える. \\[ inv_{it} = \\beta_1 value_{it} + \\beta_2 capital_{it} +\\alpha_i + u_{it} \\] この \\(\\alpha_i\\) は固定効果と呼ばれている. \\(\\alpha_i\\) は時間 \\(t\\) に対して一定である. \\(\\alpha_i\\) は誤差項と相関があるもしれない. それぞれの階差をとれば \\(\\alpha_i\\) は消去できる. \\[ \\Delta inv_{it} = \\beta_1 \\Delta value_{it} + \\beta_2 \\Delta capital_{it} + \\Delta u_{it} \\] このように変換して回帰分析すれば \\(\\alpha_i\\) は誤差項と相関があっても一致推定量である. この推計は以下のようにする. gf &lt;- plm(inv ~ value + capital, data = pdata, model = &quot;fd&quot;) summary(gf) ## Oneway (individual) effect First-Difference Model ## ## Call: ## plm(formula = inv ~ value + capital, data = pdata, model = &quot;fd&quot;) ## ## Balanced Panel: n = 10, T = 20, N = 200 ## Observations used in estimation: 190 ## ## Residuals: ## Min. 1st Qu. Median 3rd Qu. Max. ## -200.889558 -13.889063 0.016677 9.504223 195.634938 ## ## Coefficients: ## Estimate Std. Error t-value Pr(&gt;|t|) ## (Intercept) -1.8188902 3.5655931 -0.5101 0.6106 ## value 0.0897625 0.0083636 10.7325 &lt; 2.2e-16 *** ## capital 0.2917667 0.0537516 5.4281 1.752e-07 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Total Sum of Squares: 584410 ## Residual Sum of Squares: 345460 ## R-Squared: 0.40888 ## Adj. R-Squared: 0.40256 ## F-statistic: 64.6736 on 2 and 187 DF, p-value: &lt; 2.22e-16 これは以下の回帰分析と同じである. plm(diff(inv) ~ diff(value) + diff(capital) + 0, data = pdata) ## ## Model Formula: diff(inv) ~ diff(value) + diff(capital) + 0 ## ## Coefficients: ## diff(value) diff(capital) ## 0.086792 0.229800 10.4.1 時間効果 次のモデルを考える. \\[ inv_{it} = \\beta_1 value_{it} + \\beta_2 capital_{it}+ \\gamma_t +\\alpha_i + u_{it} \\] この \\(\\gamma_t\\) は時間効果と呼ばれている. この推計は以下のようになる. gft &lt;- plm(inv ~ value + capital+factor(year), data = pdata, model = &quot;fd&quot;) summary(gft) ## Oneway (individual) effect First-Difference Model ## ## Call: ## plm(formula = inv ~ value + capital + factor(year), data = pdata, ## model = &quot;fd&quot;) ## ## Balanced Panel: n = 10, T = 20, N = 200 ## Observations used in estimation: 190 ## ## Residuals: ## Min. 1st Qu. Median 3rd Qu. Max. ## -179.69353 -18.68501 0.49555 14.27860 179.03692 ## ## Coefficients: (1 dropped because of singularities) ## Estimate Std. Error t-value Pr(&gt;|t|) ## (Intercept) -2.7430195 3.5347896 -0.7760 0.43883 ## value 0.0875445 0.0095107 9.2048 &lt; 2.2e-16 *** ## capital 0.3246777 0.0571472 5.6814 5.727e-08 *** ## factor(year)1936 -4.8322777 13.2135453 -0.3657 0.71504 ## factor(year)1937 -14.4004908 18.4170837 -0.7819 0.43536 ## factor(year)1938 -24.2207187 20.9457341 -1.1564 0.24917 ## factor(year)1939 -44.1520635 23.5322498 -1.8762 0.06235 . ## factor(year)1940 -14.4426136 25.5422525 -0.5654 0.57252 ## factor(year)1941 12.9397204 26.9832784 0.4795 0.63217 ## factor(year)1942 7.9959944 28.0318389 0.2852 0.77580 ## factor(year)1943 -7.3241116 28.8474764 -0.2539 0.79989 ## factor(year)1944 -3.7724911 29.5616521 -0.1276 0.89861 ## factor(year)1945 -9.9835165 29.8949163 -0.3340 0.73883 ## factor(year)1946 19.6800057 29.8626303 0.6590 0.51078 ## factor(year)1947 8.3198315 28.7201463 0.2897 0.77241 ## factor(year)1948 7.1895769 27.6816598 0.2597 0.79539 ## factor(year)1949 -18.0502263 26.2872404 -0.6867 0.49324 ## factor(year)1950 -15.2430694 24.6257917 -0.6190 0.53676 ## factor(year)1951 8.6202900 22.2126192 0.3881 0.69844 ## factor(year)1952 12.5730202 18.5499269 0.6778 0.49883 ## factor(year)1953 21.6023354 13.1250286 1.6459 0.10165 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Total Sum of Squares: 584410 ## Residual Sum of Squares: 293000 ## R-Squared: 0.49864 ## Adj. R-Squared: 0.4393 ## F-statistic: 8.40405 on 20 and 169 DF, p-value: &lt; 2.22e-16 これが時間効果が有意であるかどうかは, 以下を実施すればよい. pFtest(gft,gf) ## ## F test for individual effects ## ## data: inv ~ value + capital + factor(year) ## F = 1.6809, df1 = 18, df2 = 169, p-value = 0.04693 ## alternative hypothesis: significant effects 10.4.2 平均差分法と一階差分法 平均差分法と一階差分法は誤差項の仮定をどのようにおくかによって変わってくる. 誤差項の階差をとることによって時間を通じて無相関になるなら一階差分法が望ましいであろう. しかしながら, 固定効果, 時間効果の値がきちんと計算して, それが経済学的解釈が可能なら, 平均差分法が望ましい. さらに他のプーリングOLSの仮定と変量効果モデルとの比較の意味でも平均差分法がよく使われる. なお時間が2期間のパネルデータのとき, 平均差分法も一階差分法も計算値は同じである. たとえば \\(t=2\\)のときの変数 \\(x_{it}\\) の平均差分値は \\[ x_{2t}-\\bar{x}_i=x_{2t}-\\frac{x_{i1}+x_{i2}}{2}=\\frac{x_{i2}-x_{i1}}{2} \\] となる. 10.5 変量効果モデル 次のモデルを考える. \\[ inv_{it} = \\beta_1 value_{it} + \\beta_2 capital_{it} +\\alpha_i + u_{it} \\] この \\(\\alpha_i\\) は変量効果と呼ばれている. \\(\\alpha_i\\) は時間 \\(t\\) について一定であるが, \\(i\\) について独立同一分布の確率変数にしたがう. さらに \\(\\alpha_i\\) は説明変数と無相関であることが必要である. このため固定効果モデルと違い, 欠落変数バイアスを除去することができない. しかしながら, \\(i\\) についてのダミー変数を付け加えることができる. 変量効果モデルは次のコマンドで実施する. gr &lt;- plm(inv ~ value + capital, data = pdata, model = &quot;random&quot;) summary(gr) ## Oneway (individual) effect Random Effect Model ## (Swamy-Arora&#39;s transformation) ## ## Call: ## plm(formula = inv ~ value + capital, data = pdata, model = &quot;random&quot;) ## ## Balanced Panel: n = 10, T = 20, N = 200 ## ## Effects: ## var std.dev share ## idiosyncratic 2784.46 52.77 0.282 ## individual 7089.80 84.20 0.718 ## theta: 0.8612 ## ## Residuals: ## Min. 1st Qu. Median 3rd Qu. Max. ## -177.6063 -19.7350 4.6851 19.5105 252.8743 ## ## Coefficients: ## Estimate Std. Error z-value Pr(&gt;|z|) ## (Intercept) -57.834415 28.898935 -2.0013 0.04536 * ## value 0.109781 0.010493 10.4627 &lt; 2e-16 *** ## capital 0.308113 0.017180 17.9339 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Total Sum of Squares: 2381400 ## Residual Sum of Squares: 548900 ## R-Squared: 0.7695 ## Adj. R-Squared: 0.76716 ## Chisq: 657.674 on 2 DF, p-value: &lt; 2.22e-16 変量効果は以下のコマンドで確かめられる. ranef(gr) ## 1 2 3 4 5 6 ## -9.5242955 157.8910235 -172.8958044 29.9119801 -54.6790089 34.3461316 ## 7 8 9 10 ## -7.8977584 0.6726376 -28.1393497 50.3144442 10.5.1 時間効果 変量効果モデルの時間効果は二種類ある. 時間効果が確率変数である場合は次のコマンドを実施する. gr2 &lt;- plm(inv ~ value + capital, data = pdata, effect= &quot;twoways&quot;,model = &quot;random&quot;) summary(gr2) ## Twoways effects Random Effect Model ## (Swamy-Arora&#39;s transformation) ## ## Call: ## plm(formula = inv ~ value + capital, data = pdata, effect = &quot;twoways&quot;, ## model = &quot;random&quot;) ## ## Balanced Panel: n = 10, T = 20, N = 200 ## ## Effects: ## var std.dev share ## idiosyncratic 2675.43 51.72 0.274 ## individual 7095.25 84.23 0.726 ## time 0.00 0.00 0.000 ## theta: 0.864 (id) 0 (time) 2.776e-17 (total) ## ## Residuals: ## Min. 1st Qu. Median 3rd Qu. Max. ## -177.1700 -19.7576 4.6048 19.4676 252.7596 ## ## Coefficients: ## Estimate Std. Error z-value Pr(&gt;|z|) ## (Intercept) -57.865377 29.393359 -1.9687 0.04899 * ## value 0.109790 0.010528 10.4285 &lt; 2e-16 *** ## capital 0.308190 0.017171 17.9483 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Total Sum of Squares: 2376000 ## Residual Sum of Squares: 547910 ## R-Squared: 0.7694 ## Adj. R-Squared: 0.76706 ## Chisq: 657.295 on 2 DF, p-value: &lt; 2.22e-16 時間効果が固定されている場合は次のコマンドを実施する. grt &lt;- update(gr, .~. + factor(year)) summary(grt) ## Oneway (individual) effect Random Effect Model ## (Swamy-Arora&#39;s transformation) ## ## Call: ## plm(formula = inv ~ value + capital + factor(year), data = pdata, ## model = &quot;random&quot;) ## ## Balanced Panel: n = 10, T = 20, N = 200 ## ## Effects: ## var std.dev share ## idiosyncratic 2675.43 51.72 0.274 ## individual 7095.25 84.23 0.726 ## theta: 0.864 ## ## Residuals: ## Min. 1st Qu. Median 3rd Qu. Max. ## -160.759401 -19.805349 -0.028228 19.194961 214.295364 ## ## Coefficients: ## Estimate Std. Error z-value Pr(&gt;|z|) ## (Intercept) -29.828275 32.380484 -0.9212 0.3569561 ## value 0.113779 0.011759 9.6763 &lt; 2.2e-16 *** ## capital 0.354336 0.022594 15.6826 &lt; 2.2e-16 *** ## factor(year)1936 -17.690058 23.612087 -0.7492 0.4537397 ## factor(year)1937 -38.006448 24.356323 -1.5604 0.1186572 ## factor(year)1938 -38.400547 23.303431 -1.6478 0.0993836 . ## factor(year)1939 -67.669031 23.605147 -2.8667 0.0041477 ** ## factor(year)1940 -42.210436 23.716150 -1.7798 0.0751057 . ## factor(year)1941 -16.896674 23.640596 -0.7147 0.4747751 ## factor(year)1942 -19.950610 23.442180 -0.8511 0.3947382 ## factor(year)1943 -41.303361 23.564907 -1.7527 0.0796452 . ## factor(year)1944 -41.301975 23.603031 -1.7499 0.0801427 . ## factor(year)1945 -53.418089 23.807547 -2.2437 0.0248487 * ## factor(year)1946 -28.601243 23.973397 -1.1930 0.2328534 ## factor(year)1947 -37.647517 23.832869 -1.5796 0.1141878 ## factor(year)1948 -41.944013 24.029174 -1.7455 0.0808900 . ## factor(year)1949 -71.515032 24.236975 -2.9507 0.0031710 ** ## factor(year)1950 -73.609655 24.379280 -3.0194 0.0025332 ** ## factor(year)1951 -59.205876 24.754226 -2.3917 0.0167683 * ## factor(year)1952 -60.963457 25.209460 -2.4183 0.0155942 * ## factor(year)1953 -62.886188 26.252610 -2.3954 0.0166011 * ## factor(year)1954 -88.564196 26.819791 -3.3022 0.0009593 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Total Sum of Squares: 2376000 ## Residual Sum of Squares: 479720 ## R-Squared: 0.7981 ## Adj. R-Squared: 0.77428 ## Chisq: 703.627 on 21 DF, p-value: &lt; 2.22e-16 固定された時間効果が有意かどうかは次の検定を実施すれば良い. pFtest(grt,gr) ## ## F test for individual effects ## ## data: inv ~ value + capital + factor(year) ## F = 1.3511, df1 = 19, df2 = 178, p-value = 0.1572 ## alternative hypothesis: significant effects 10.5.2 ハウスマン検定 帰無仮説が変量効果モデル, 対立仮説が固定効果モデルの検定はハウスマン検定を実施する. ハウスマン検定は以下で実施する. phtest(gi,gr) ## ## Hausman Test ## ## data: inv ~ value + capital ## chisq = 2.3304, df = 2, p-value = 0.3119 ## alternative hypothesis: one model is inconsistent 時間効果が確率変数である変量モデルの場合以下を実行すればよい. phtest(gi2,gr2) ## ## Hausman Test ## ## data: inv ~ value + capital ## chisq = 13.46, df = 2, p-value = 0.001194 ## alternative hypothesis: one model is inconsistent 時間効果が確率変数でない変量モデルの場合以下を実行すればよい. phtest(gi2,grt) ## ## Hausman Test ## ## data: inv ~ value + capital ## chisq = 6.5733, df = 2, p-value = 0.03738 ## alternative hypothesis: one model is inconsistent どちらを採用するかによって結果が変わってしまうので注意されたい. 10.6 クラスターロバスト分散 固定効果モデルにおいて, 分散不均一が疑われる場合, ではクラスターロバスト分散を用いる. 時間効果がない場合は以下の様にする. coeftest(gi,vcov=vcovHC(gi,type=&quot;sss&quot;)) ## ## t test of coefficients: ## ## Estimate Std. Error t value Pr(&gt;|t|) ## value 0.110124 0.015156 7.2660 9.596e-12 *** ## capital 0.310065 0.052618 5.8927 1.726e-08 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 分散不均一が疑われる場合, クラスターロバスト分散を用いる. 時間効果がある場合は以下の様にする. coeftest(gi2,vcov=vcovHC(gi2,type=&quot;sss&quot;)) ## ## t test of coefficients: ## ## Estimate Std. Error t value Pr(&gt;|t|) ## value 0.117716 0.010263 11.4697 &lt; 2.2e-16 *** ## capital 0.357916 0.045367 7.8893 3.62e-13 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 STATA の計算結果に合わせるには次のように実施する必要がある. git &lt;- update(gi, .~. + factor(year)) coeftest(git,vcov=vcovHC(git,type=&quot;sss&quot;)) ## ## t test of coefficients: ## ## Estimate Std. Error t value Pr(&gt;|t|) ## value 0.117716 0.010794 10.9055 &lt; 2.2e-16 *** ## capital 0.357916 0.047715 7.5012 3.424e-12 *** ## factor(year)1936 -19.197405 20.640669 -0.9301 0.3536580 ## factor(year)1937 -40.690009 33.190087 -1.2260 0.2219160 ## factor(year)1938 -39.226404 15.692472 -2.4997 0.0133837 * ## factor(year)1939 -69.470288 26.923231 -2.5803 0.0107211 * ## factor(year)1940 -44.235085 17.323706 -2.5534 0.0115505 * ## factor(year)1941 -18.804463 17.797543 -1.0566 0.2922130 ## factor(year)1942 -21.139792 14.125147 -1.4966 0.1363608 ## factor(year)1943 -42.977623 12.509017 -3.4357 0.0007437 *** ## factor(year)1944 -43.098772 10.965103 -3.9305 0.0001234 *** ## factor(year)1945 -55.683040 15.159383 -3.6732 0.0003212 *** ## factor(year)1946 -31.169284 20.858408 -1.4943 0.1369549 ## factor(year)1947 -39.392242 26.363118 -1.4942 0.1369835 ## factor(year)1948 -43.716514 38.769856 -1.1276 0.2610913 ## factor(year)1949 -73.495099 38.147491 -1.9266 0.0557069 . ## factor(year)1950 -75.896112 36.695524 -2.0683 0.0401383 * ## factor(year)1951 -62.480912 49.279892 -1.2679 0.2065854 ## factor(year)1952 -64.632341 51.417852 -1.2570 0.2104874 ## factor(year)1953 -67.717966 43.622288 -1.5524 0.1224442 ## factor(year)1954 -93.526221 31.637576 -2.9562 0.0035603 ** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 どちらを採用するかによって結果が変わってしまうので注意されたい. 10.6.1 分散不均一の検定 固定効果モデルにおいて, 分散不均一かどうかを検定するには, 時間効果がない場合, 以下のようにすればよい. bptest(inv ~ value + capital + factor(firm), data=pdata) ## ## studentized Breusch-Pagan test ## ## data: inv ~ value + capital + factor(firm) ## BP = 85.836, df = 11, p-value = 1.086e-13 時間効果がある場合, 以下のようにすればよい. bptest(inv ~ value + capital + factor(firm) + factor(year),data=pdata) ## ## studentized Breusch-Pagan test ## ## data: inv ~ value + capital + factor(firm) + factor(year) ## BP = 97.357, df = 30, p-value = 4.833e-09 "]
]
