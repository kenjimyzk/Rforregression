[
["index.html", "R と RStudio はじめに 0.1 R とは 0.2 R のインストール 0.3 R の設定 0.4 R の使い方", " R と RStudio 宮﨑憲治 2017-11-30 はじめに 0.1 R とは Rは統計・データ解析・統計グラフ作成のためのオープンソースソフトである. https://ja.wikipedia.org/wiki/R%E8%A8%80%E8%AA%9E 0.2 R のインストール Rをインストールするには https://cran.r-project.org/ にいき, 該当機種のファイルをダウンロードする. ダウンロードしたあとに実行すればインストールされる. Windows の場合, 32bit か 64bit を選択する. 最近のパソコンの CPU は 64bit と考えられるが, どちらかわからなければ 32bit にしておけばよい. Ubuntu なら ppa を使って導入してもよい. sudo add-apt-repository ppa:marutter/rrutter sudo apt-get update sudo apt-get install r-base r-base-dev 0.3 R の設定 設定ファイル .Rprofile をホームディレクトリに作成すれば, 設定を変更できる. ホームディレクトリはユーザー名が kenji のとき, Windows なら通常 C:\\Users\\kenji である. バックスラッシュ \\ は \\(\\yen\\) と読み替えて頂きたい. 最初は .Rprofile を特に作成しなくても大丈夫である. 0.4 R の使い方 Windows だとコマンドプロンプトから R と入力して立ち上げるか, R のアイコンをダブルクリックすると, Rコンソールと言われる画面が現れる. コマンドプロンプトからだと最初の表示が文字化けしている可能性があるが, その後の起動に問題ないはずである. アイコンがなければ, Winキーを押した後, rgui と入力すれば起動できる. Mac や Ubuntu だとターミナルから R と入力して起動できる. 立ち上げた後, コンソールから そこにコマンドを入力すると, その結果が直後に出力される. 終了には q() とする. 作業スペースを保存するかと聞かれたなら, No を意味する n を選択する. コマンド入力中, 最後の括弧を付け忘れたり, 正しく実行ができないときがある. たとえば, rnorm(5 としてEnterキーを押せば, 次の行に + とでてくる. ここでは正しく ) を付けて再度Enterキーを押せば正しく実行されるが, ときにはどれを入力すれば正しく実行されるかわからない一方で, 単にEnterを押すだけだと, 再度入力を求められることがある. そうしたとときは通常左上にあるエスケープキー (ESC) を押せば途中入力がキャンセルされる. R はRコンソールから対話式にコマンドを入力していく方法と, 拡張子 R のスクリプトファイルを実行していくやり方がある. 実行履歴を記録するためにスクリプトファイルを作成していくやり方を推奨する. スクリプトファイル project.R を Rコンソールから実行するには, source(&quot;project.R&quot;) とすればよい. R外部のコマンドプロンプトから実行するには Rscript project.R とすればよい. 起動できないときには, 環境変数の PATH にRの実行ファイルの場所が登録されていない可能性がある. また外部ファイルを導入する際やファイルを外部出力する際には, 現在の作業ディレクトリに気をつけなければならない. 現在の作業ディレクトリの場所はRコンソールから getwd() とすれば, 確認できる. Windows だと通常の表記と異なっていることに注意されたい. 作業ディレクトリの指定は以下のようにする. setwd(PATH) Windows のとき指定の仕方に注意が必要である. たとえば作業ディレクトリが C:\\Users\\kenji\\work\\project のとき, setwd(&quot;C:/Users/kenji/work/project&quot;) となる. バックスラッシュ \\ (\\(\\yen\\)) を スラッシュ / に変更しなければならない. "],
["01-base.html", "1 基本 1.1 電卓としての R 1.2 関数電卓としてのR 1.3 R の型 1.4 変数 1.5 パッケージ", " 1 基本 R の基本として以下の2つのサイトでオンラインで学習することをオススメする. ただし英語である. http://tryr.codeschool.com/ https://www.datacamp.com/courses/free-introduction-to-r また以下の日本語版のチートシートが有用である. https://www.rstudio.com/wp-content/uploads/2016/10/r-cheat-sheet-ja.pdf R についての動画はまず以下を見ていただきたい. http://dotinstall.com/lessons/basic_r 日本語で合計40分くらいで13分割して配信している. 他にも Youtube にいけば他にも多数動画がある. 1.1 電卓としての R R は電卓してとして使える. 数値を扱う算術演算子として以下のものが代表的である. 演算子 説明 例 + 足し算 5 + 2 = 7 - 引き算 5 - 2 = 3 * 掛け算 5 * 2 = 10 / 割り算 5 / 2 = 2.5 ^, ** べき算 5 ^ 2 = 25, 5 ** 2 = 25 %% 割り算の余り 5 %% 2 = 1 %/% 割り算の切り下げ 5 %/% 2 = 2 5 + 2 ## [1] 7 5 - 2 ## [1] 3 5 * 2 ## [1] 10 5 / 2 ## [1] 2.5 5 ^ 2 ## [1] 25 5 ** 2 ## [1] 25 5 %% 2 ## [1] 1 5 %/% 2 ## [1] 2 1.2 関数電卓としてのR R は関数として使える. たとえば以下の関数がある. 関数 説明 sqrt() 平方根 \\(\\sqrt{\\cdot}\\) exp() 指数 log() 対数 factorial() 順列 choose() 組み合わせ abs() 絶対値 round() 四捨五入 floor() 切り下げ ceiling() 切り上げ sqrt(10) ## [1] 3.162278 exp(10) ## [1] 22026.47 log(10) ## [1] 2.302585 factorial(4) ## [1] 24 choose(4,2) ## [1] 6 abs(-10) ## [1] 10 round(3.5) ## [1] 4 floor(3.5) ## [1] 3 ceiling(3.5) ## [1] 4 関数の括弧に入る数値を引数という. 組み合せを計算する関数 choose の引数は2つある. 複数の引数は , で区切る. 引数の順序は指定すれば変更可能である. choose(4, 2) ## [1] 6 choose(n=4, k=2) ## [1] 6 choose(k=2, n=4) ## [1] 6 また幾つかの引数は入力しなくても. デフォルトで設定してあることがある. それぞれの関数のヘルプを確認されたい. 関数のヘルプはコマンド choose の場合 help(choose) ?choose で調べることができる. 1.3 R の型 Rにおいて値は型 (type) をもち, 型として数値 (numeric) と文字列 (character) と論理値 (logical) など1がある. 多くの言語と違い, あらかじめ宣言する必要なく, 自動的に決定される. 数値には整数 (integer) と, 実数をコンピュータ的に扱っている倍数精度小数 (double) など2がある. 整数か倍数精度小数かは自動的に振り分けられるが, 明示的に数字の後に L をつけて整数を指定することができる. 文字は &quot; (ダブルクオーテーション) もしくは ' (シングルクォーテーション) で区切られる. TRUE もしくは FALSE を取る値を論理値 (logical) という. 省略して T と F とあわらせることもできるが混乱するので個人的に推奨しない. 値の型は関数 typeof() で確認できる. typeof(3) ## [1] &quot;double&quot; typeof(3L) ## [1] &quot;integer&quot; typeof(&quot;3&quot;) ## [1] &quot;character&quot; typeof(TRUE) ## [1] &quot;logical&quot; typeof(FALSE) ## [1] &quot;logical&quot; typeof(T) ## [1] &quot;logical&quot; typeof(F) ## [1] &quot;logical&quot; 特殊な値として, 無限大を意味する Inf, 非数を意味する NaN, 欠損値を意味する NA , 空を意味する NULL がある. Inf と Nan の型は数値として分類され, NA の型は論理値として分類される. また NULL は NULL という特別な型である. 1/0 ## [1] Inf typeof(1/0) ## [1] &quot;double&quot; 0/0 ## [1] NaN typeof(0/0) ## [1] &quot;double&quot; typeof(NA) ## [1] &quot;logical&quot; typeof(NULL) ## [1] &quot;NULL&quot; 1.4 変数 値は変数 (variable) に代入することによって再利用が可能になる. Rでは代入のことを付値 (assign) といい, 以下のように実行される. x &lt;- 4 4 -&gt; x x = 4 assign(&quot;x&quot;,4) 多くのプログラム言語では3番目のやり方をだけであるが, R では最初のやり方を推奨している.3 代入した値を確認するには単にその変数を入力すればよい. 代入と同時に確認するには丸括弧をつけるとよい. x ## [1] 4 (x&lt;-3) ## [1] 3 付値される変数として, 記号と数字からはじまらなければ, ほぼ自由に作れる. アルファベットについて大文字と小文字が区別されることに注意されたい. また日本語も変数に使えるが, 機種によって文字コードが違うため, 避けて使うほうが望ましい. 扱える変数は if などいくつか4はエラーになるが, pi のようにすでに組み込まれている変数も変更して指定することができる. pi ## [1] 3.141593 pi &lt;- 3 pi ## [1] 3 関数 objects() を使うことで，現在どんなオブジェクトがあるかを調べられる． R は変数や関数を全てオブジェクトとして扱う言語である. また，前に定義したオブジェクトを消す場合 rm() を用いる． すでに組み込まれた変数を上書きした pi を削除するともとの変数が復活する. rm(pi) pi ## [1] 3.141593 さらに，全てのオブジェクトを消す場合は rm(list=ls(all=TRUE)) とすればよい． 1.5 パッケージ R においてパッケージを導入することによって, 機能を拡張させることができる. パッケージ pkg を導入するため一度だけ以下を実行する. install.packages(&quot;pkg&quot;, dependencies = =TRUE) とする. オプション dependencies = TRUE 依存するパッケージを同時に導入してくれる. パッケージ pkg が導入していれば, そのコマンド cmd を実行するには pkg::cmd とパッケージとコマンドの間に :: とする. もしくは library(pkg) もしくは require(pkg) 予め入力しておけば, 最初の pkg:: を省略することができる. なお複数のパッケージで同じ名前のコマンドがある場合, あとで library もしくは require としたパッケージの方が優先させるので注意されたい. なお library と require に使い方にほとんど違いがないが, require だと以下のように存在しなければインストールするように設定できる. if (!require(lattice)){ install.packages(&quot;lattice&quot;, dependencies = TRUE) require(lattice) } ただ私は昔からの癖で library を使っている. 他にも日付 (Date) やバイナリ (raw) がある.↩ 他にも複素数 (complex) がある.↩ 例えば以下を参照されたい: http://adv-r.had.co.nz/Style.html↩ break, else, FALSE, for, function, if in Inf, NA, NaN, next NULL, repeat, TRUE, while など↩ "],
["02-rstudio.html", "2 RStudio 2.1 RStudio とは 2.2 RStudio のインストール 2.3 RStudio の設定 2.4 RStudio の使い方", " 2 RStudio 2.1 RStudio とは RStudio は R の統合開発環境 (IDE, Integrated Development Enviroment) の一つである. オープンソース版が存在する. https://ja.wikipedia.org/wiki/R-Studio 2.2 RStudio のインストール オープンソース版のRStudio のインストールは https://www.rstudio.com/products/rstudio/download/ にいき, 該当機種のファイルをダウンロードする. ダウンロードしたあとに実行すればインストールされる. Ubuntu ならサーバー版を導入するとよい. https://www.rstudio.com/products/rstudio/download-server/ 2.3 RStudio の設定 メニューバーの [Tools] から [Global Options…] を選択することで設定を変更できる. [General] で以下のように [Restore .RData …] のチェックを外していいて, その下を Never にしている. これは, 立ち上げたきに環境をクリーンし, 終了時に, データの保存を聞かれないようにするためである. 次に, [Code] の タブ [Saving] で. [Default text encoding] を UTF-8 とする. Windows 以外だとOSのシステムフォントが同じなので問題ない. しかし Windows は SJIS を拡張した CP932 なので, 注意が必要である. Windows のRは UTF-8 を選択してもR自身はCP932処理している. ただ, 他のOSとの併用の場合, UTF-8 にしたほうがよいだろう. またHTMLファイルは UTF-8 でのファイルが前提になりつつあるので, HTML として出力を考えているなら, UTF-8 としたほうが無難である. またインターネットで公開されている日本語のRファイルは Windows の使用が前提となっているため, 文字コードが CP932 であることが多い. Windows 以外を使っている場合, 一時的に文字コードを SJIS を選択する必要がある. あと, R Markdown で 真ん中あたりの [Show output preview in:] を View Pane に変更する 2.4 RStudio の使い方 RStudio の使い方として日本語版のチートシートがある. https://github.com/rstudio/cheatsheets/raw/master/translations/japanese/rstudio-IDE-cheatsheet_ja.pdf RStudio プロジェクト単位で複数のソースコードを管理するのことが推奨される. そうするとプロジェクトごとに作業ディレクトリが設定される. プロジェクトはメニューバー の [File] から [New Project] を選択する. そうすると新たに新たにディレクトリを作成するか, 既存のディレクトリを採用するかなどが選べる. また, バージョン管理ソフトを導入していればそこから取り入れることも可能となる. プロジェクトを立ち上げると左にコンソールペイン (Console Pane) が, 右側に上下に二分割されたペインが現れる. この配置は メニューバーの [Tools] から [Project Options -&gt; Pane Layout] を選べば変更可能である. コンソールペインにコマンドを入力するとその結果が直下に返される. 何か入力した後に, Ctrl + l (Cmd + l) を押すと, 画面が更新される. 上下の矢印キーで過去に実行したコマンドを選択できる. メニューバー の [File] から [New File -&gt; RScript] を選択するか, Ctrl + Shift + n (Cmd + Shift + n) と入力するか, メニューバー下の一番左の白紙のアイコンをクリックすると, Rのスクリプトファイルが新規に作られる. スクリプフォファイルを開くと左側のコンソール画面の上にソースペインが登場する. ここにソースコードを書く. ソースペインで何かコマンドを書いていきながら, ソースコードの該当行で Ctrl + Enter (Cmd + Return) と入力するか, ソースペインの上側の右に並んでいるアイコンのうち, 左側のRunと書かれたアイコンをクリックすると, 該当行がコンソール画面で実行される. 複数行選択した後に, メニューバー の [Code] から [Run Selected line(s)] を選ぶか, Ctrl + Shift + Enter (Cmd + Shift + Enter) と入力すると複数行をまとめて実行させることも可能である. メニューバー の [File] から [Save] を選択するか, Ctrl + s (Cmd + s) と入力するか, メニューバー下の左から3番目のフロッピーディスクアイコンをクリック すると, スクリプトファイルを保存することができる. またメニューバー の [File] から [Open] を選択するか, Ctrl + o (Cmd + o) と入力するか, メニューバー下の左から2番めのフォルダを開くアイコンをクリックすると, 既存のスクリプトファイルを開くことができる. 右上のペインには Environment と History のタブがある. Environment は現在使っているオブジェクトが表示される. 最初は空白である. 変数に数値を代入 (R の言い方ではオブジェクトに付値) することによって, 値が付け加わっている. History はこれまでの履歴が記録される. 履歴の一部ををエディトペインかコンソールペインに挿入することができる. 右下のペインには Files, Plots, Packages, Help, Viewer のタブがある. Files ペインはWindowsではエクスプローラーのようなもので, Mac はFinder のようなもので, ファイル管理をおこなう. ファイル管理として新たなフォルダを作成したり, ファイルを削除したり, ファイル名を変更したりする. Plots ペインはコンソール画面で作図をコマンドの実行したら, 表示されるペインである. そこで作成した図をコマンドを使わずに保存したりすることができる. Packages ペインは現在Rに導入されているパッケージリストが表示される. そこに無いパッケージはメニューバーの [Tools] から [Install Packages…] を選択して実行すればよい. すでにあるパッケージは, パッケージ名の左側のボックスをチェックすれば, ライブライリ名を付けずにコマンドを実行させることができる. Help ペインはその名の通り, ヘルプ画面が表示される. コンソールペインから help (コマンド) もしくは ?コマンド と入力するとそのコマンドのヘルプがこのペインに表示される. R ではソースペインやコンソールペインで, コマンド入力していると, コマンドの後補があらわてくる. [TAB] でコマンドを補完できる. さらにそのコマンドでどのような引数が使われるのかも示される. さらに [TAB] を押せば, 引数を選べるだけでなく, 簡単なコマンドの説明がある. そのときに [F1] を押せば, より詳細なヘルプが立ち上がる. また Packages パインから該当パッケージをクリックするとそのパッケージのコマンド一覧が Help ペインに表示される. 最後のViewer ペインは R Markdown で作成したファイルを HTMLで出力したときに表示されるペインである. 最初の設定だと別のウィンドウ画面として結果が表示される. このペインに出力されるためには [Tools -&gt; R Markdown] にいき, 真ん中あたりの [Show output preview in:] を View Pane に変更する必要がある. その上でソースペインから [Ctrl + Shift + k] とするか, ソースペインの左側のアイコン群の一番右側のノートのアイコンをクリックすると, 確認画面が現れるので HTML を押す. そうするとそのコードがすべて実行されて, 実行結果が作図も含めてHTMLファイルに出力される. もしくはメニューバーの [File] から [Knit Document…] としを選択するとよい. これは knitr と rmarkdown いわれるパッケージを利用したもので, Rのコードを埋め込んだマークダウンファイルを作成し, そこからHTMLファイルを作成する. 他にも word ファイル や pdf ファイル生成することも適切に設定していれば可能である. ソースコードだけでなく, マークダウンファイルに R コマンドを埋め込んだ Rmd ファイルを作成することができる それは新規作成でRスクリプトでなく, R Notebook や R Markdown を選択すればよい. "],
["03-vector.html", "3 ベクトル 3.1 ベクトル 3.2 算術演算子 3.3 論理演算子 3.4 比較演算子 3.5 要素 3.6 関数 3.7 規則的なベクトル 3.8 乱数ベクトル", " 3 ベクトル 3.1 ベクトル Rでは同じ型の値を集めたものをベクトルという. ベクトルは c() を用いて構成する. (num&lt;-c(2,3,7,9)) ## [1] 2 3 7 9 (chr &lt;- c(&quot;cat&quot;,&quot;dog&quot;,&quot;cow&quot;)) ## [1] &quot;cat&quot; &quot;dog&quot; &quot;cow&quot; ベクトルには長さという属性 (attribute) が付く. length(num) ## [1] 4 length(chr) ## [1] 3 ベクトルはオブジェクトの基本であり, 一つの値は長さが1のベクトルと考える. 型が同じでない場合, 強制的に同じ型に変換される. 文字列が含まれればすべて文字列になる. 数値と論理値の場合は論理値の TRUE が1に FALSE が0に変換される. (x&lt;- c(1,4)) ## [1] 1 4 typeof(x) ## [1] &quot;double&quot; (y &lt;- c(2,FALSE,&quot;4&quot;)) ## [1] &quot;2&quot; &quot;FALSE&quot; &quot;4&quot; typeof(y) ## [1] &quot;character&quot; (z &lt;- c(2,FALSE)) ## [1] 2 0 typeof(z) ## [1] &quot;double&quot; 3.2 算術演算子 四則演算などの算術演算子はその対象を数値ベクトルに拡張できる. ベクトルの算術演算子はその要素ごと行う. a&lt;-c(2,3,3,3) b&lt;-c(3,3,5,7) a+b ## [1] 5 6 8 10 a-b ## [1] -1 0 -2 -4 a*b ## [1] 6 9 15 21 a/b ## [1] 0.6666667 1.0000000 0.6000000 0.4285714 a^b ## [1] 8 27 243 2187 片方が値, 同じ長さのベクトルとして演算が実行される. a+2 ## [1] 4 5 5 5 a-2 ## [1] 0 1 1 1 a*2 ## [1] 4 6 6 6 a/2 ## [1] 1.0 1.5 1.5 1.5 a^2 ## [1] 4 9 9 9 一般に長さが違う場合, 短いほうが繰り返される. c&lt;-c(1,2) a+c ## [1] 3 5 4 5 a-c ## [1] 1 1 2 1 a*c ## [1] 2 6 3 6 a/c ## [1] 2.0 1.5 3.0 1.5 a^c ## [1] 2 9 3 9 なお 短いほうが長い方の約数でないと警告がでる. 3.3 論理演算子 論理値に対して演算をおこなって論理値を返す論理演算子というものがある. Rには, 論理演算子として, 否定 (!), または (|), かつ (&amp;) がある. 論理演算子もベクトルごとに評価できる. logic1 &lt;- c(TRUE, FALSE, FALSE) logic2 &lt;- c(TRUE, TRUE, FALSE) !logic1 ## [1] FALSE TRUE TRUE logic1 | logic2 ## [1] TRUE TRUE FALSE logic1 &amp; logic2 ## [1] TRUE FALSE FALSE ベクトルのうちすべての要素が TRUE かどうかを評価する all や 少なくとも一つの要素が TRUE かどうかを評価する any というのがある. , any(logic1) ## [1] TRUE all(logic1) ## [1] FALSE 3.4 比較演算子 2つの値を比較してして論理値を返す比較演算子というものがある. Rには, 比較演算子として, 等しいか ==, どちらかが大きいか &gt;, &lt; がある. それぞれのベクトルの要素ごとに評価できる. vec1 &lt;- 1:4 vec2 &lt;- c(2,1,3,4) vec1 == vec2 ## [1] FALSE FALSE TRUE TRUE vec1 &gt; vec2 ## [1] FALSE TRUE FALSE FALSE vec1 &lt; vec2 ## [1] TRUE FALSE FALSE FALSE 他にも等しくない !=, 以上および以下 &gt;=, &lt;= がある. vec1 != vec2 # !(vec1==vec2) ## [1] TRUE TRUE FALSE FALSE vec1 &gt;= vec2 # (vec1 &gt; vec2 | vec1 == vec2) ## [1] FALSE TRUE TRUE TRUE vec1 &lt;= vec2 # (vec1 &lt; vec2 | vec1 == vec2) ## [1] TRUE FALSE TRUE TRUE 片方が値, 同じ長さのベクトルとして演算が実行される. vec1 &gt; 2 ## [1] FALSE FALSE TRUE TRUE 3.5 要素 ベクトルの要素はカギカッコで取り出す. num &lt;- c(2,3,7,9) num[3] ## [1] 7 取り出すだけななく付値することもできる. num[3] &lt;- 500 num ## [1] 2 3 500 9 マイナスをつけるとその要素以外を取り出す. num[-3] ## [1] 2 3 9 複数取り出すこともできる. num[c(1,4)] ## [1] 2 9 他にも論理値ベクトルを使って取り出すことができる. idx &lt;- c(TRUE,FALSE,TRUE,TRUE) num[idx] ## [1] 2 500 9 さらに比較演算子と組み合わせることができる. (num &gt; 4) ## [1] FALSE FALSE TRUE TRUE num[num &gt; 4] ## [1] 500 9 また : をもちいて連続したベクトルが作れるので, それを利用してベクトルを抜き出すことができる. 2:4 ## [1] 2 3 4 num[2:4] ## [1] 3 500 9 またベクトルには名前の属性をつけて構成することがでる. vec &lt;- c(x= 3, y =3, z = 4) また次のようにしてもよい. names(num) &lt;- letters[1:4] いずれに名前の属性をつけると次のようにしてアクセスが可能である. vec[&quot;x&quot;] ## x ## 3 num[&quot;d&quot;] ## d ## 9 3.6 関数 引数がベクトルの関数がいくつかある. これによってベクトルの和や積が簡単に扱える. x&lt;-c(1,2,3,4,5) sum(x) ## [1] 15 cumsum(x) ## [1] 1 3 6 10 15 prod(x) ## [1] 120 cumprod(x) ## [1] 1 2 6 24 120 平均, 中央値, 分散, 標準偏差などの統計関数も扱える. x &lt;- c(x,10) mean(x) ## [1] 4.166667 median(x) ## [1] 3.5 var(x) ## [1] 10.16667 sd(x) ## [1] 3.188521 ベクトルを並べ替えたり 最小値や最大値しめしたり, それが何番目の要素になるのかをしめすことができる. x &lt;- c(3,3,5,0) sort(x) ## [1] 0 3 3 5 sort(x,decreasing = TRUE) ## [1] 5 3 3 0 min(x) ## [1] 0 max(x) ## [1] 5 which.min(x) ## [1] 4 which.max(x) ## [1] 3 またベクトルに NA が含まれるき, 関数 mean などではデフォルトで結果が, NA になる. それを避けるには na.rm=TRUE というオプションを付ける必要がある. x &lt;- c(4,2,NA,3) mean(x) ## [1] NA mean(x, na.rm = TRUE) ## [1] 3 3.7 規則的なベクトル 1:5 のような規則的なベクトルを柔軟に作成するのに seq を用いるとよい. 1:5 ## [1] 1 2 3 4 5 seq(1, 5) ## [1] 1 2 3 4 5 seq(1, 5, by = 2) ## [1] 1 3 5 seq(1, 5, length.out = 4) ## [1] 1.000000 2.333333 3.666667 5.000000 繰り返しを作成することができる rep も覚えておくと便利である. rep(1, 5) ## [1] 1 1 1 1 1 rep(c(1, 2), times = 3) ## [1] 1 2 1 2 1 2 rep(c(1, 2), each = 3) ## [1] 1 1 1 2 2 2 またアルファベットの文字列もあらかじめ組み込まれている. letters ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; ## [18] &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; LETTERS ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; ## [18] &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; LETTERS[1:2] ## [1] &quot;A&quot; &quot;B&quot; 3.8 乱数ベクトル ベクトルを出鱈目に並べ直すには関数 sample を使う set.seed(10) sample(1:5) ## [1] 3 2 4 5 1 最初の行の関数 set.seed は他の環境でも再現可能性にするための設定である. さて, この乱数は一旦出力された値は二度とでない非復元抽出である. 復元抽出にするには sample(1:5, replace=TRUE) ## [1] 2 2 2 4 3 とオプション replace=TRUE をつける. いくつ取り出すかをオプション size で決められる. sample(LETTERS[1:2], size=10, replace=TRUE) ## [1] &quot;B&quot; &quot;B&quot; &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; 非復元抽出の場合, 取りうる値より大きくできないことに注意されたい. さらに確率を prob で変えることができる. sample(LETTERS[1:2], prob=c(0.8,0.2),size=10,replace=TRUE) ## [1] &quot;B&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; 独立な一様分布にしたがう長さ size のベクトルは runif(size) によって, 正規分布にしたがうベクトルは rnorm(size) で出力される. size &lt;- 8 runif(size) ## [1] 0.53559704 0.09308813 0.16980304 0.89983245 0.42263761 0.74774647 ## [7] 0.82265258 0.95465365 rnorm(size) ## [1] 0.4829785 -0.5963106 -2.1852868 -0.6748659 -2.1190612 -1.2651980 ## [7] -0.3736616 -0.6875554 "],
["04-dataframe.html", "4 データ構造 4.1 ベクトル 4.2 リスト 4.3 因子ベクトル 4.4 行列 4.5 データフレイム", " 4 データ構造 4.1 ベクトル Rでは同じ型の値を集めたものをベクトルという. ベクトルは c() を用いて構成する. (num&lt;-c(2,3,7,9)) ## [1] 2 3 7 9 (chr &lt;- c(&quot;cat&quot;,&quot;dog&quot;,&quot;cow&quot;)) ## [1] &quot;cat&quot; &quot;dog&quot; &quot;cow&quot; ベクトルには長さという属性 (attribute) が付く. length(num) ## [1] 4 length(chr) ## [1] 3 ベクトルはオブジェクトの基本であり, 一つの値は長さが1のベクトルと考える. 型が同じでない場合, 強制的に同じ型に変換される. 文字列が含まれればすべて文字列になる. 数値と論理値の場合は論理値の TRUE が1に FALSE が0に変換される. (x&lt;- c(1,4)) ## [1] 1 4 typeof(x) ## [1] &quot;double&quot; (y &lt;- c(2,FALSE,&quot;4&quot;)) ## [1] &quot;2&quot; &quot;FALSE&quot; &quot;4&quot; typeof(y) ## [1] &quot;character&quot; (z &lt;- c(2,FALSE)) ## [1] 2 0 typeof(z) ## [1] &quot;double&quot; 4.1.1 ベクトルのアクセス ベクトルの要素はカギカッコに整数値を代入することで 取り出すせることができる. たとえば3番目のベクトルの要素を取り出すには以下とする. num &lt;- c(2,3,7,9) num[3] ## [1] 7 また名前の属性をつけてベクトルを構成することがでる. vec &lt;- c(x= 3, y =3, z = 4) vec ## x y z ## 3 3 4 names(vec) ## [1] &quot;x&quot; &quot;y&quot; &quot;z&quot; すでにあるリストの場合, 次のようにしてもよい. names(num) &lt;- letters[1:4] num ## a b c d ## 2 3 7 9 いずれに名前の属性をつけると次のようにしてアクセスが可能である. vec[&quot;x&quot;] ## x ## 3 num[&quot;d&quot;] ## d ## 9 4.2 リスト ベクトルなどを集めたものをリストという. ベクトル型の違うベクトルを関数 list で集める. リストの属性には長さがある. (lst &lt;- list(&quot;a&quot;,c(3,3,2))) ## [[1]] ## [1] &quot;a&quot; ## ## [[2]] ## [1] 3 3 2 typeof(lst) ## [1] &quot;list&quot; length(lst) ## [1] 2 関数 class によってリストがであることが確認でき, str で属性を詳しく調べることができる. class(lst) ## [1] &quot;list&quot; str(lst) ## List of 2 ## $ : chr &quot;a&quot; ## $ : num [1:3] 3 3 2 リストとベクトルの違いとして, リスト自体もリストとして含められることがある. typeof(list(&quot;b&quot;,lst)) ## [1] &quot;list&quot; リストベクトルに変換するには unlist を用いる. それぞれの型が違う場合, 同じ型に強制変換される. lst&lt;-list(1:3,2:6) lst ## [[1]] ## [1] 1 2 3 ## ## [[2]] ## [1] 2 3 4 5 6 unlist(lst) ## [1] 1 2 3 2 3 4 5 6 unlist(list(&quot;a&quot;,1:4)) ## [1] &quot;a&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; 4.2.1 リストのアクセス リストの取りだすには, ベクトルのようにかぎかっこで数値を入力する. 以下は一番目のリストを表示している. lst[1] ## [[1]] ## [1] 1 2 3 また名前の属性をもてば, その名前を入力することで取り出すことができる. たと次のようにして名前の属性をつけたリストを作る. (lst &lt;- list(name=&quot;a&quot;,num=c(3,3,2))) ## $name ## [1] &quot;a&quot; ## ## $num ## [1] 3 3 2 names(lst) ## [1] &quot;name&quot; &quot;num&quot; その上で以下のようにすれば2番目の要素が取り出せる. lst[&quot;num&quot;] ## $num ## [1] 3 3 2 いずれにせよ取り出したののもリストになることに注意されたい. typeof(lst[1]) ## [1] &quot;list&quot; typeof(lst[&quot;num&quot;]) ## [1] &quot;list&quot; ベクトルとして取り出すには次のようにする. lst[[2]] ## [1] 3 3 2 typeof(lst[[2]]) ## [1] &quot;double&quot; 名前の属性がついていれば以下のようにもできる. lst[[&quot;num&quot;]] ## [1] 3 3 2 lst$num ## [1] 3 3 2 リストのなかのあるベクトルの平均値を求めるには次のようにする. ## mean(lst[[2]]) ## mean(lst[[&quot;num&quot;]]) mean(lst$num) ## [1] 2.666667 もしくは以下とする. with(lst, mean(num)) ## [1] 2.666667 なおリストの要素を消すには以下のようにする. lst$num &lt;- NULL lst ## $name ## [1] &quot;a&quot; 4.3 因子ベクトル 4.3.1 factor 文字列ベクトルを引数にした関数 factorによって 因子 (factor) ベクトルを作成できる. (x &lt;- c(&quot;L&quot;,&quot;S&quot;,&quot;M&quot;,&quot;M&quot;,&quot;L&quot;)) ## [1] &quot;L&quot; &quot;S&quot; &quot;M&quot; &quot;M&quot; &quot;L&quot; (x.fac &lt;- factor(x)) ## [1] L S M M L ## Levels: L M S 因子ベクトルの実体は level という属性をもつ整数ベクトルである. typeof(x.fac) ## [1] &quot;integer&quot; length(x.fac) ## [1] 5 levels(x.fac) ## [1] &quot;L&quot; &quot;M&quot; &quot;S&quot; 関数 class によって因数ベクトルがであることが確認でき, str で属性を詳しく調べることができる. class(x.fac) ## [1] &quot;factor&quot; str(x.fac) ## Factor w/ 3 levels &quot;L&quot;,&quot;M&quot;,&quot;S&quot;: 1 3 2 2 1 また水準の表示順は自動的にアルファベット順になるが, それを変更するには次のようにする. (x.factor &lt;- factor(x,levels=c(&quot;S&quot;,&quot;M&quot;,&quot;L&quot;))) ## [1] L S M M L ## Levels: S M L この水準に順序構造を付与するには次のようにする. (x.order &lt;- ordered(x,levels=c(&quot;S&quot;,&quot;M&quot;,&quot;L&quot;))) ## [1] L S M M L ## Levels: S &lt; M &lt; L 4.3.2 cut また数値を区間ごとに区分した因子ベクトルも作成可能である. 0から10までの値を発生させる. x &lt;- runif(10,0,10) x ## [1] 7.8081872 3.5063431 1.0635085 1.8148186 8.4997836 0.7380885 2.9245283 ## [8] 6.0106348 8.5437458 8.4669064 5等分するには以下のようにする. cut(x, breaks=5) ## [1] (6.98,8.55] (2.3,3.86] (0.73,2.3] (0.73,2.3] (6.98,8.55] ## [6] (0.73,2.3] (2.3,3.86] (5.42,6.98] (6.98,8.55] (6.98,8.55] ## Levels: (0.73,2.3] (2.3,3.86] (3.86,5.42] (5.42,6.98] (6.98,8.55] これは登場したデータの最大値と最小値の幅を5等分している. 区間を指定するには以下のようにベクトルで指定する. cut(x,breaks=c(0,2,4,6,8,10)) ## [1] (6,8] (2,4] (0,2] (0,2] (8,10] (0,2] (2,4] (6,8] (8,10] (8,10] ## Levels: (0,2] (2,4] (4,6] (6,8] (8,10] 0より大きく2以下, 2より大きく4以下,… となっている. 0も含めるのなら include.lowest=TRUE というオプションをつける. cut(x, breaks=seq(0,10,2),include.lowest=TRUE) ## [1] (6,8] (2,4] [0,2] [0,2] (8,10] [0,2] (2,4] (6,8] (8,10] (8,10] ## Levels: [0,2] (2,4] (4,6] (6,8] (8,10] またこれを0以上2未満, 2以上4未満, … とするにはオプション right=FALSE をつける. cut(x, breaks=seq(0,10,2),right=FALSE,include.lowest=TRUE) ## [1] [6,8) [2,4) [0,2) [0,2) [8,10] [0,2) [2,4) [6,8) [8,10] [8,10] ## Levels: [0,2) [2,4) [4,6) [6,8) [8,10] このとき, include.lowest=TRUE は最大値を含めることを意味する. また因子の名称はオプション labels で変更可能である. cut(x, breaks=seq(0,10,2),right=FALSE,include.lowest=TRUE, labels =c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;)) ## [1] D B A A E A B D E E ## Levels: A B C D E 4.4 行列 ベクトルに縦と横の次元を付与することによって行列 (matrix) を作ることができる. mat &lt;- matrix(1:10, nrow=2,ncol=5) mat ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 またオプション byrow=TRUE で横から行列を作成できる. matrix(1:10, nrow=2,ncol=5,byrow = TRUE) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 2 3 4 5 ## [2,] 6 7 8 9 10 この行列の実体は dim という属性を持つ数値ベクトルである. typeof(mat) ## [1] &quot;integer&quot; length(mat) ## [1] 10 dim(mat) ## [1] 2 5 他にもそれぞれの要素の次元は以下で得ることができる. nrow(mat) ## [1] 2 ncol(mat) ## [1] 5 関数 class によって因数ベクトルがであることが確認でき, str で属性を詳しく調べることができる. class(mat) ## [1] &quot;matrix&quot; str(mat) ## int [1:2, 1:5] 1 2 3 4 5 6 7 8 9 10 4.4.1 行列の演算 縦での結合は rbind を用いる mata&lt;-matrix(1:5,nrow=1,ncol=5) rbind(mat,mata) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 ## [3,] 1 2 3 4 5 横での結合は cbind を用いる matb&lt;-matrix(1:4,nrow=2,ncol=2) cbind(mat,matb) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] ## [1,] 1 3 5 7 9 1 3 ## [2,] 2 4 6 8 10 2 4 転置行列は以下のようにすればよい. t(mat) ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 ## [3,] 5 6 ## [4,] 7 8 ## [5,] 9 10 通常の * は要素ごとの掛け算になる. 数学で用いられる行列同士の掛け算は %*% を実施する. matb %*% mat ## [,1] [,2] [,3] [,4] [,5] ## [1,] 7 15 23 31 39 ## [2,] 10 22 34 46 58 行列のことが一致させる必要がある. また列ごとの合計, 行ごとの合計は以下を実施する. colSums(mat) ## [1] 3 7 11 15 19 rowSums(mat) ## [1] 25 30 返り値はベクトルになる. 行列のすべての要素を足すには sum でよい. sum(mat) ## [1] 55 また列ごとの平均, 行ごとの平均は以下を実施する. colMeans(mat) ## [1] 1.5 3.5 5.5 7.5 9.5 rowMeans(mat) ## [1] 5 6 4.4.2 行列のアクセス 行列からベクトルの取り出し以下のようにｓる. mat[2,] ## [1] 2 4 6 8 10 ベクトルのまま取り出されてしまう. オプション drop=FALSE をつけると行列のまま取り出すことができる. mat[, 3, drop=FALSE] ## [,1] ## [1,] 5 ## [2,] 6 2つ同時に取り出すにときは特にオプションをしていしなくても行列として取り出せる. mat[,2:3] ## [,1] [,2] ## [1,] 3 5 ## [2,] 4 6 要素の取り出し mat[2,3] ## [1] 6 行列に名前を付けることができる. rownames(mat) &lt;- letters[1:2] colnames(mat) &lt;- 1:5 mat ## 1 2 3 4 5 ## a 1 3 5 7 9 ## b 2 4 6 8 10 これによって以下のようにしてもアクセス可能である. mat[&quot;a&quot;,&quot;3&quot;] ## [1] 5 なお名前は次のようにしてあとから作成することができる. dimnames(mat) &lt;- list(LETTERS[1:2],2:6) mat ## 2 3 4 5 6 ## A 1 3 5 7 9 ## B 2 4 6 8 10 4.5 データフレイム 同じ長さのベクトルを組み合わせたリストをデータフレイム (dataframe) という. データフレイムは次のようにして作られる. df &lt;- data.frame(x = rnorm(10), y = letters[1:10]) データフレイムは大規模なことが多いので最初の数行だけをみるためには head をもちいる. head(df) ## x y ## 1 0.4909434 a ## 2 0.2997482 b ## 3 0.1148063 c ## 4 0.6495021 d ## 5 0.4104383 e ## 6 -0.2029007 f データの簡単な統計表は summary を使うとよい. summary(df) ## x y ## Min. :-1.7127 a :1 ## 1st Qu.:-0.4716 b :1 ## Median : 0.2073 c :1 ## Mean :-0.1410 d :1 ## 3rd Qu.: 0.4708 e :1 ## Max. : 0.6495 f :1 ## (Other):4 よりプログラム言語としてのデータ構造を調べるには str を使えばよい. str(df) ## &#39;data.frame&#39;: 10 obs. of 2 variables: ## $ x: num 0.491 0.3 0.115 0.65 0.41 ... ## $ y: Factor w/ 10 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,..: 1 2 3 4 5 6 7 8 9 10 データフレイムはリストである. typeof(df) ## [1] &quot;list&quot; class(df) ## [1] &quot;data.frame&quot; リストのように長さと名前をもつ. length(df) ## [1] 2 names(df) ## [1] &quot;x&quot; &quot;y&quot; 行列と同じ次元をもつ. dim(df) ## [1] 10 2 ncol(df) ## [1] 2 nrow(df) ## [1] 10 ncol(df) は length(df) と同じである. 行列と同じ名前をもつ. dimnames(df) ## [[1]] ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; ## ## [[2]] ## [1] &quot;x&quot; &quot;y&quot; colnames(df) ## [1] &quot;x&quot; &quot;y&quot; rownames(df) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; colnames(df) は names(df) と同じである. 4.5.1 データフレイムの演算 データフレイムは行列でもあるので, 注意があるが 行列での演算がほとんどそのまま利用できる. rbind(df, c(3,&quot;a&quot;)) ## x y ## 1 0.490943395352449 a ## 2 0.299748202447566 b ## 3 0.114806257178259 c ## 4 0.649502102245656 d ## 5 0.410438313763549 e ## 6 -0.202900740808802 f ## 7 -0.561130102631628 g ## 8 -1.71274235640486 h ## 9 0.576120041175913 i ## 10 -1.47439114685888 j ## 11 3 a cbind(df,z=runif(10)) ## x y z ## 1 0.4909434 a 0.9934267 ## 2 0.2997482 b 0.4026853 ## 3 0.1148063 c 0.6448435 ## 4 0.6495021 d 0.5137529 ## 5 0.4104383 e 0.4018903 ## 6 -0.2029007 f 0.4960983 ## 7 -0.5611301 g 0.5584948 ## 8 -1.7127424 h 0.1320130 ## 9 0.5761200 i 0.5540853 ## 10 -1.4743911 j 0.9480326 転置行列は行列として出力可能である. 以下のようにデータフレイムに因子ベクトルが含まれていたら全て文字列になる. t(df) ## [,1] [,2] [,3] [,4] [,5] ## x &quot; 0.4909434&quot; &quot; 0.2997482&quot; &quot; 0.1148063&quot; &quot; 0.6495021&quot; &quot; 0.4104383&quot; ## y &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; ## [,6] [,7] [,8] [,9] [,10] ## x &quot;-0.2029007&quot; &quot;-0.5611301&quot; &quot;-1.7127424&quot; &quot; 0.5761200&quot; &quot;-1.4743911&quot; ## y &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; データフレイムの構成ベクトルがすべて論理値もしくは数値のとき, 同じ行数と列数のデータフレイムの要素ごとの四則演算は可能である. ただし, 通常の行列演算を実施するには, 行列に変換しなければならない. また データフレイムの構成ベクトルがすべて論理値もしくは数値のとき, 列ごとの合計, 行ごとの合計が可能である. dff&lt;-data.frame(a=1:5,b=c(TRUE, TRUE, TRUE, FALSE,FALSE)) colSums(dff) ## a b ## 15 3 rowSums(dff) ## [1] 2 3 4 4 5 返り値はベクトルになる. 行列のすべての要素を足すには sum でよい. sum(dff) ## [1] 18 また列ごとの平均, 行ごとの平均は以下を実施する. colMeans(dff) ## a b ## 3.0 0.6 rowMeans(dff) ## [1] 1.0 1.5 2.0 2.0 2.5 4.5.2 データフレイムのアクセス データのアクセスとして, ベクトルのように一つのカギカッコで取り出すと以下のようになる. df[&quot;x&quot;] ## x ## 1 0.4909434 ## 2 0.2997482 ## 3 0.1148063 ## 4 0.6495021 ## 5 0.4104383 ## 6 -0.2029007 ## 7 -0.5611301 ## 8 -1.7127424 ## 9 0.5761200 ## 10 -1.4743911 他にも df[1] でもよいが, いずれにせよデータフレイムとして取り出されてしまう. ベクトルとして取り出すには以下を実施する. df$x ## [1] 0.4909434 0.2997482 0.1148063 0.6495021 0.4104383 -0.2029007 ## [7] -0.5611301 -1.7127424 0.5761200 -1.4743911 他にも df[[&quot;x&quot;]], df[[1]], df[,&quot;x&quot;], df[,1] でもよい. ある変数 $x$ の5番目の要素を取り出して別の値100`を代入するには以下のようにする. df$x[5] &lt;- 100 他にも df[[&quot;x&quot;]][5], df[[1]][5], df[5,&quot;x&quot;], df[5,1] でもよい. データフレイムのある変数の平均値を求めるには次のようにする. mean(df$x) ## [1] 9.817996 もしくは以下とする. with(df, mean(x)) ## [1] 9.817996 他にも attach(df) を使うやり方もあるが, 現在では推奨されない. なおリストの要素を消すには以下のようにする. df$x &lt;- NULL "],
["05-datainput.html", "5 データ入力 5.1 はじめに 5.2 csv ファイル 5.3 EXCEL ファイル 5.4 STATA 5.5 R に入っているデータ 5.6 インターネットからデータ入力 5.7 その他のデータ入力", " 5 データ入力 library(tidyverse) 5.1 はじめに R においてデータ分析をおこなうには データ入力する必要がある. データについてがR やパッケージに入っている場合があるが, 多くは外部ファイルを取り込むことになる. 読み込まれたデータはRではデータフレイム (dataframe) となる. データフレイムは同じ長さのベクトルを組み合わせたリストのことである. 例えばデータフレイムは次のようにして作られる. df &lt;- data.frame(x = rnorm(10), y = letters[1:10]) str(df) ## &#39;data.frame&#39;: 10 obs. of 2 variables: ## $ x: num 0.803 -1.216 1.558 -0.624 0.287 ... ## $ y: Factor w/ 10 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,..: 1 2 3 4 5 6 7 8 9 10 ただデータフレイムは自動的に文字列が因子ベクトルに変換されてしまう. これを避けるには次のように stringsAsFactors= FALSE をつける. df &lt;- data.frame(x = rnorm(10), y = letters[1:10], stringsAsFactors= FALSE) str(df) ## &#39;data.frame&#39;: 10 obs. of 2 variables: ## $ x: num 0.2372 0.5898 0.4955 0.0862 1.3473 ... ## $ y: chr &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ... もしくはライブラリ dplyr にある data_frame を用いれば, そのようなオプションを付けることなくデータフレイムを拡張したクラスを作ることができる. library(dplyr) df &lt;- data_frame(x = rnorm(10), y = letters[1:10]) str(df) ## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 10 obs. of 2 variables: ## $ x: num 0.0125 0.3094 -0.9547 0.7937 1.2184 ... ## $ y: chr &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ... 以降, それぞれのファイル形式ごとにファイル入力について説明する. いずれのファイル形式にせよ, 外部ファイルから入力するさいには 現在のワークングディレクトリとファイルの場所をきちんと把握しておかなければならない. 現在のワーキングディレクトリは以下のコマンドで確認できる. getwd() またワーキングディレクトリを変更するには setwd を実行する. 例えば, 現在のワーキングディレクトリの位置が C:\\Users\\kenji\\work\\project にあり, データ data.csv が C:\\Users\\kenji\\work\\project\\data にある場合, df &lt;- read.table(&quot;work/data.csv&quot;, header=TRUE, sep = &quot;,&quot;) とするか, ワーキングディレクトリを変更しなければならない. setwd(&quot;C:/Users/kenji/work/project/data&quot;) df &lt;- read.table(&quot;data.csv&quot;, header=TRUE, sep = &quot;,&quot;) また RStudio はメニューバーの File から Import Dataset からインタラクティブに外部ファイルが入力可能である. いったんこれで入力したとしても, history ペインでどのようなコマンドを実行したかを確認して, 次回も実行できるよう記録しておくとよい. 5.2 csv ファイル csv ファイルの csv とは comma separated variable の略で, その名の通りコンマでわけられた変数が以下のようなテキストファイルである. var1, var2, var3 3, 4,&quot;text&quot; 4, 4, &quot;text&quot; ... 最初の一行は変数名を含まれていることが多いけれど, ない場合もあり事前に確認が必要である. R 以外の計算機で作成した結果を csv で保存しておけば, それを R に取り込むことができる. csv ファイルをRに取り込むには関数 raed.table を使うのが基本である. df &lt;- read.table(&quot;data.csv&quot;, header=TRUE, sep = &quot;,&quot;) こうすればオブジェクト df にデータフレイムとして導入される. 関数 read.csv を使えば, 以上のオプションを付ける必要がない. df &lt;- read.table(&quot;data.csv&quot;) 外部からファイルを取り込んだ場合, 文字列は自動的に因子ベクトルに変換されてしまう. これを避けるには次のようにオプションをつける必要がある. df &lt;- read.table(&quot;data.csv&quot;, stringsAsFactors= FALSE) ファイルを書き込むときには次のようにする. write.csv(df,&quot;data.csv&quot;, row.names = FALSE) このオプションはファイルの一列目に rownames が書き込まれるのを避けるための設定である. もしくはライブラリ readr を導入する. ファイルの読み込みは以下となる. library(readr) df &lt;- read_csv(&quot;data.csv&quot;) 特にオプションをつけなくても, 文字列は自動的に因子ベクトルに変換されない. ファイルの書き込みは以下となる. write_csv(df,&quot;data.csv&quot;) 特にオプションをつけなくても, rownames は書き込まない. 日本語が含まれるcsvファイルについては注意が必要である. これについては次の節で触れることにする. 5.3 EXCEL ファイル EXCELはビジネスにおいてデファクトスタンダードになっているスプレッドシートソフトウェアである. R は EXCEL のデータを扱うことができる. 最近のEXCELデータの拡張子は xlsx である. これを導入するにはライブラリ readxl を使えばよい. library(readxl) df &lt;- read_excel(&quot;data.xlsx&quot;,1) ファイルdata.xls の一枚目のシートを意味する. 直接シート名を指定することができる. read_excel(&quot;data.xlsx&quot;,&quot;Revenues&quot;) こちらは「Revenues」という名前のシートを意味する. EXCELから入力するときには, 一行目を変数名にして, 列ごとに変数を揃えておかなければならない. 最終行に合計などがあれば, それも変数として入力してしまうので, 注意が必要である. またEXCELからcsvファイルに変換して, ファイルを読み込ませる方法がある. これは2点ほど注意が必要である. まず EXCEL で桁をしめすコンマのまま保存すると文字列として保存されてしまう. そうしたファイルを read.csv で読み込む数値でなく⽂字列として読み込まれてしまう . それを避けるには , 桁を示すコンマを無しに直して保存しなければならない. なお read_csv をもちいるなら数値として読み込んでくれる また変数名をアルファベットのみにしておいたほうがトラブルが少ない . 日本語が含まれている場合に , EXCEL 上 で csv 形式に変換して保存したときにシフト JIS で保存されてしまう . Linux や Mac では文字コードをUTF-8 にしているので そのままの読み込みだと⽇本語が⽂字化けになる . Windows でも RStudio を導入したときに最初に文字コードを UTF-8 に設定していたのなら同じように文字化けになる. それを防ぐためには , read.csv を用いるときは df &lt;- read.csv(&quot;data.csv&quot;, stringAsFactors=FALSE, fileEncoding=&quot;SJIS&quot;) として, read_csv を用いるときは df &lt;- read_csv(&quot;data.csv&quot;, locale=locale(encoding = &quot;SJIS&quot;)) とする必要がある. 私の使った印象だとライブラリ readxl は賢く日本語を扱ってくれっるので, 日本語が含まれている場合, csv に変換せず, そのまま入力したほうがよい. 5.4 STATA Stata は多くの経済学者が実証分析に用いている統計パッケージである. R は Stata のデータを扱うことができる. Stata のデータは拡張子 dta で保存されている. これを導入するにはライブラリ foreign を用いる. library(foreign) df &lt;- read.dta(&quot;data.dta&quot;) ただ, 最新の Stata には対応していない. 最新の Stata に対応するにはライブラリ haven を導入する. library(haven) df &lt;- read_dta(&quot;data.dta&quot;) 他にも SAS や SPSS などの統計パッケージのデータも取り込むことができる. 5.5 R に入っているデータ R およびパッケージにはいくつかのデータがはいっている. どのようなデータが利用可能かは以下のコマンドで調べることができる. data() それがどのような変数が含まれているのかを調べるには, help を使えばよい. help(cars) パッケージのデータは関数 data をつかって利用可能になる. library(AER) ## 要求されたパッケージ car をロード中です ## ## 次のパッケージを付け加えます: &#39;car&#39; ## 以下のオブジェクトは &#39;package:dplyr&#39; からマスクされています: ## ## recode ## 以下のオブジェクトは &#39;package:purrr&#39; からマスクされています: ## ## some ## 要求されたパッケージ lmtest をロード中です ## 要求されたパッケージ zoo をロード中です ## ## 次のパッケージを付け加えます: &#39;zoo&#39; ## 以下のオブジェクトは &#39;package:base&#39; からマスクされています: ## ## as.Date, as.Date.numeric ## 要求されたパッケージ sandwich をロード中です ## 要求されたパッケージ survival をロード中です data(CPS1985) summary(CPS1985) ## wage education experience age ## Min. : 1.000 Min. : 2.00 Min. : 0.00 Min. :18.00 ## 1st Qu.: 5.250 1st Qu.:12.00 1st Qu.: 8.00 1st Qu.:28.00 ## Median : 7.780 Median :12.00 Median :15.00 Median :35.00 ## Mean : 9.024 Mean :13.02 Mean :17.82 Mean :36.83 ## 3rd Qu.:11.250 3rd Qu.:15.00 3rd Qu.:26.00 3rd Qu.:44.00 ## Max. :44.500 Max. :18.00 Max. :55.00 Max. :64.00 ## ethnicity region gender occupation ## cauc :440 south:156 male :289 worker :156 ## hispanic: 27 other:378 female:245 technical :105 ## other : 67 services : 83 ## office : 97 ## sales : 38 ## management: 55 ## sector union married ## manufacturing: 99 no :438 no :184 ## construction : 24 yes: 96 yes:350 ## other :411 ## ## ## 5.6 インターネットからデータ入力 またWebスクレイピングをしてインターネットのサイトから直接入手できる. 幾つかのデータベースでは api が公開されて, それにもとづいてパッケージが作成されている. Yahoo! Finance (quantmod) Yahoo! Finance Japan (RFinanceYJ) World Development Indicators (WDI) Eurostat (eurostat) e-stat (estatap) また直接, インターネットのファイルをダウンロードすることもできる. library(haven) URL &lt;- &quot;http://fmwww.bc.edu/ec-p/data/wooldridge/attend.dta&quot; df &lt;-read_dta(URL) もし一旦ファイルとして保存しておくなら以下のように実施する. if(!file.exists(&quot;mroz.dta&quot;)) download.file(URL, &quot;mroz.dta&quot;,method=&quot;curl&quot;) library(haven) df &lt;- read_dta(&quot;mroz.dta&quot;) 5.7 その他のデータ入力 Rのバイナルファイルとして保存していれば, それを読み込むことができる. ただ私はほとんど利用したことがない. 他にもリレーショナルデータベースにアクセスして, データを入手できる. これも私はほとんど利用したことがない. "],
["06-datawrangling.html", "6 整然データ 6.1 データ整形 6.2 データ結合 6.3 tidyr 6.4 実践例", " 6 整然データ http://r4ds.had.co.nz/tidy-data.html データが整然 (tidy) であるとは次の条件を満たすデータのことである. 個々の変数 (variable) が1つの列 (column) である 個々の観測 (observation) が1つの行 (row) である 個々の値 (value) が1つのセル (cell) である これをこのようなデータを使って, データを整形する方法, またはそうしたデータにする方法を紹介する. ここでは以下のライブラリに全面に依存する. library(tidyverse) 特に dplyr と tidyr を用いる. 6.1 データ整形 データセット mtcars を取り扱う. この最初の6つを見るには以下を実施する. mtcars %&gt;% head() ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 ここで %&gt;% はパイプ処理といって, head(mtcars) と同じ効果をもたらす. 括弧が重複する場合, こちらのほうがわかりやすい. ライブラリ dplyr でデータフレイムの処理が簡単になる. select で変数を選択できる. mtcars %&gt;% select(mpg, disp) %&gt;% head() ## mpg disp ## Mazda RX4 21.0 160 ## Mazda RX4 Wag 21.0 160 ## Datsun 710 22.8 108 ## Hornet 4 Drive 21.4 258 ## Hornet Sportabout 18.7 360 ## Valiant 18.1 225 filter により条件に応じた抽出ができる. mtcars %&gt;% select(mpg, disp) %&gt;% filter(disp &gt; 300) %&gt;% head() ## mpg disp ## 1 18.7 360 ## 2 14.3 360 ## 3 10.4 472 ## 4 10.4 460 ## 5 14.7 440 ## 6 15.5 318 rename により変数名を変更することができる. 日本語でも一応対応している. mtcars %&gt;% select(mpg, disp) %&gt;% rename(速度 =mpg, 距離 =disp) %&gt;% head() ## 速度 距離 ## Mazda RX4 21.0 160 ## Mazda RX4 Wag 21.0 160 ## Datsun 710 22.8 108 ## Hornet 4 Drive 21.4 258 ## Hornet Sportabout 18.7 360 ## Valiant 18.1 225 arrange により順序を変更できる. mtcars %&gt;% select(mpg, disp) %&gt;% arrange(mpg) %&gt;% head() ## mpg disp ## 1 10.4 472 ## 2 10.4 460 ## 3 13.3 350 ## 4 14.3 360 ## 5 14.7 440 ## 6 15.0 301 逆順には以下のようにすればよい. mtcars %&gt;% select(mpg, disp) %&gt;% arrange(desc(mpg)) %&gt;% head() ## mpg disp ## 1 33.9 71.1 ## 2 32.4 78.7 ## 3 30.4 75.7 ## 4 30.4 95.1 ## 5 27.3 79.0 ## 6 26.0 120.3 新しい変数を作成するには以下のように mutate を用いる. mtcars %&gt;% select(mpg) %&gt;% mutate(gpm = 1/mpg) %&gt;% head() ## mpg gpm ## 1 21.0 0.04761905 ## 2 21.0 0.04761905 ## 3 22.8 0.04385965 ## 4 21.4 0.04672897 ## 5 18.7 0.05347594 ## 6 18.1 0.05524862 以下は20より大きいとTRUE, そうでないと FALSE をとる変数を作成している. mtcars %&gt;% select(mpg) %&gt;% mutate(binarympg = ifelse(mpg&gt;20,TRUE,FALSE)) %&gt;% head() ## mpg binarympg ## 1 21.0 TRUE ## 2 21.0 TRUE ## 3 22.8 TRUE ## 4 21.4 TRUE ## 5 18.7 FALSE ## 6 18.1 FALSE summarize により変数の基本統計表を作成できる. mtcars %&gt;% summarize(avg = mean(mpg), sd =sd(mpg)) ## avg sd ## 1 20.09062 6.026948 group_by と summarize を組み合わせてグループごとの基本統計量も作成できる. mtcars %&gt;% group_by(cyl) %&gt;% summarize(n = n(), avg = mean(mpg), sd =sd(mpg)) ## # A tibble: 3 x 4 ## cyl n avg sd ## &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 4 11 26.66364 4.509828 ## 2 6 7 19.74286 1.453567 ## 3 8 14 15.10000 2.560048 6.2 データ結合 dplyr 2つのデータフレイムを結合する便利なコマンドがある. 列の追加は bind_rows を用いる. df1 &lt;- data_frame(X=1:2, Y=1:2) df2 &lt;- data_frame(X=4, Y=4) bind_rows(df1,df2) ## # A tibble: 3 x 2 ## X Y ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 ## 2 2 2 ## 3 4 4 行の追加は bind_rows を用いる. df3 &lt;- data_frame(Z=5:6) bind_cols(df1,df3) ## # A tibble: 2 x 3 ## X Y Z ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 1 5 ## 2 2 2 6 2つのデータフレイムで共通部分を用いて結合させるには4つのやり方がある. dfx &lt;- data_frame(id=c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;), X=1:3) dfy &lt;- data_frame(id=c(&quot;A&quot;,&quot;B&quot;,&quot;D&quot;), Y=c(TRUE,FALSE,TRUE)) 左側の dfx がすべて残るように結合するには, left_join を実行する. left_join(dfx,dfy,by=&quot;id&quot;) ## # A tibble: 3 x 3 ## id X Y ## &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; ## 1 A 1 TRUE ## 2 B 2 FALSE ## 3 C 3 NA 右側の dfx がすべて残るように結合するには, right_join を実行する. right_join(dfx,dfy,by=&quot;id&quot;) ## # A tibble: 3 x 3 ## id X Y ## &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; ## 1 A 1 TRUE ## 2 B 2 FALSE ## 3 D NA TRUE 両方がすべて残るように結合するには, full_join を実行する. full_join(dfx,dfy,by=&quot;id&quot;) ## # A tibble: 4 x 3 ## id X Y ## &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; ## 1 A 1 TRUE ## 2 B 2 FALSE ## 3 C 3 NA ## 4 D NA TRUE 両方にある行のみ残して結合するには, inner_join を実行する. inner_join(dfx,dfy,by=&quot;id&quot;) ## # A tibble: 2 x 3 ## id X Y ## &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; ## 1 A 1 TRUE ## 2 B 2 FALSE 6.3 tidyr 以下のデータセットを考える. df &lt;- data_frame( time = 2010:2014, X = rnorm(5, 0, 1), Y = rnorm(5, 0, 2), Z = rnorm(5, 0, 4) ) df ## # A tibble: 5 x 4 ## time X Y Z ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2010 -1.1663725 -2.3264072 -3.274189 ## 2 2011 0.5590662 0.3215016 5.583281 ## 3 2012 -0.6994227 -1.9827920 -1.440248 ## 4 2013 -0.7978011 -0.9029791 -3.199637 ## 5 2014 -1.8402849 0.2109742 4.992003 それぞれの変数名をキーとして, 値を示した表は gather で作れる. df_gather &lt;- df %&gt;% gather(key,value,-time) df_gather ## # A tibble: 15 x 3 ## time key value ## &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2010 X -1.1663725 ## 2 2011 X 0.5590662 ## 3 2012 X -0.6994227 ## 4 2013 X -0.7978011 ## 5 2014 X -1.8402849 ## 6 2010 Y -2.3264072 ## 7 2011 Y 0.3215016 ## 8 2012 Y -1.9827920 ## 9 2013 Y -0.9029791 ## 10 2014 Y 0.2109742 ## 11 2010 Z -3.2741887 ## 12 2011 Z 5.5832811 ## 13 2012 Z -1.4402481 ## 14 2013 Z -3.1996371 ## 15 2014 Z 4.9920027 spread でもとに戻ることができる. df_gather %&gt;% spread(key, value) ## # A tibble: 5 x 4 ## time X Y Z ## * &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2010 -1.1663725 -2.3264072 -3.274189 ## 2 2011 0.5590662 0.3215016 5.583281 ## 3 2012 -0.6994227 -1.9827920 -1.440248 ## 4 2013 -0.7978011 -0.9029791 -3.199637 ## 5 2014 -1.8402849 0.2109742 4.992003 spread で time にすると別の形で展開できる. df_spread &lt;- df_gather %&gt;% spread(time, value) df_spread ## # A tibble: 3 x 6 ## key `2010` `2011` `2012` `2013` `2014` ## * &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 X -1.166372 0.5590662 -0.6994227 -0.7978011 -1.8402849 ## 2 Y -2.326407 0.3215016 -1.9827920 -0.9029791 0.2109742 ## 3 Z -3.274189 5.5832811 -1.4402481 -3.1996371 4.9920027 以下のようにすればもとに戻る. df_spread %&gt;% gather(time,value,-key) ## # A tibble: 15 x 3 ## key time value ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 X 2010 -1.1663725 ## 2 Y 2010 -2.3264072 ## 3 Z 2010 -3.2741887 ## 4 X 2011 0.5590662 ## 5 Y 2011 0.3215016 ## 6 Z 2011 5.5832811 ## 7 X 2012 -0.6994227 ## 8 Y 2012 -1.9827920 ## 9 Z 2012 -1.4402481 ## 10 X 2013 -0.7978011 ## 11 Y 2013 -0.9029791 ## 12 Z 2013 -3.1996371 ## 13 X 2014 -1.8402849 ## 14 Y 2014 0.2109742 ## 15 Z 2014 4.9920027 gather をうまく使えば変数ごとの基本統計量の表を作ることができる. cars %&gt;% gather(variable,value) %&gt;% group_by(variable) %&gt;% summarize(nobs = n(), avg = mean(value), sd =sd(value)) ## # A tibble: 2 x 4 ## variable nobs avg sd ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 dist 50 42.98 25.769377 ## 2 speed 50 15.40 5.287644 日本語だと次のようにすればよい. tab &lt;- cars %&gt;% rename(距離=dist,速度=speed ) %&gt;% gather(変数,value) %&gt;% group_by(変数) %&gt;% summarize(観測数 = n(), 平均 = mean(value), 標準偏差 =sd(value)) head(tab) ## # A tibble: 2 x 4 ## 変数 観測数 平均 標準偏差 ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 距離 50 42.98 25.769377 ## 2 速度 50 15.40 5.287644 6.4 実践例 tidyr を用いた別の例をみてみよう. 横軸を年としたデータセット df がある. df &lt;- data_frame(name=letters, &quot;2010&quot;=rnorm(26),&quot;2011&quot;=rnorm(26),&quot;2012&quot;=rnorm(26)) head(df) ## # A tibble: 6 x 4 ## name `2010` `2011` `2012` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 a 1.75947958 0.4589661 1.1075842 ## 2 b 0.04042277 -1.9300608 -0.6121461 ## 3 c -0.25671188 0.3000853 0.7872280 ## 4 d 0.32796828 0.4447490 -0.2946484 ## 5 e -0.64667103 -2.2683908 2.1765848 ## 6 f 0.40862751 -0.8678921 -1.3369653 data.frame でないことに注意されたい. また, 年ごとのデータセット df_2010, df_2011, df_2012 が3つある. df_2010 &lt;- data_frame(name=letters,runif=runif(26)) df_2011 &lt;- data_frame(name=letters,runif=runif(26)) df_2012 &lt;- data_frame(name=letters,runif=runif(26)) これら4つのデータセットを1つにまとめよう. まずデータ df についてであるが, gather をつかう. df_rnorm &lt;- df %&gt;% gather(time,rnorm,-name) %&gt;% mutate(time=as.numeric(time)) head(df_rnorm) ## # A tibble: 6 x 3 ## name time rnorm ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 a 2010 1.75947958 ## 2 b 2010 0.04042277 ## 3 c 2010 -0.25671188 ## 4 d 2010 0.32796828 ## 5 e 2010 -0.64667103 ## 6 f 2010 0.40862751 時間の変数を数値に変換している. データセット df_2010, df_2011, df_2012 をつなげる. df_runif &lt;- bind_rows(df_2010,df_2011,df_2012) %&gt;% bind_cols(time=rep(2010:2012,each=26)) head(df_runif) ## # A tibble: 6 x 3 ## name runif time ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 a 0.6989922 2010 ## 2 b 0.6356242 2010 ## 3 c 0.8707251 2010 ## 4 d 0.6223686 2010 ## 5 e 0.5562858 2010 ## 6 f 0.6686594 2010 それぞれの年の変数を付け加えている. これを full_join を用いてつなげる. df_full &lt;- full_join(df_rnorm,df_runif,by=c(&quot;name&quot;,&quot;time&quot;)) head(df_full) ## # A tibble: 6 x 4 ## name time rnorm runif ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 a 2010 1.75947958 0.6989922 ## 2 b 2010 0.04042277 0.6356242 ## 3 c 2010 -0.25671188 0.8707251 ## 4 d 2010 0.32796828 0.6223686 ## 5 e 2010 -0.64667103 0.5562858 ## 6 f 2010 0.40862751 0.6686594 "],
["07-regression.html", "7 回帰分析 7.1 単回帰モデル 7.2 重回帰モデル 7.3 正規性の仮定について 7.4 誤差項と説明変数が独立の仮定について 7.5 分散均一の検定", " 7 回帰分析 library(AER) 仮想的に以下のようにデータを生成する. N &lt;- 100 x&lt;-runif(N) w&lt;-sample(c(&quot;H&quot;,&quot;T&quot;),N,replace=TRUE) y &lt;- 10 + 2*x + ifelse(w==&quot;H&quot;,1,0) + rnorm(N) df &lt;- data.frame(w,x,y) plot(y~x) 7.1 単回帰モデル 次の単回帰モデルを考えてる. \\[ y = \\alpha + \\beta x + u \\] ここで \\(x\\) は説明変数で, \\(y\\) は被説明変数である. \\(u\\) は誤差項である. パラメータとして \\(\\alpha\\) は切片パラメータ, \\(\\beta\\) は傾きパラメータである. 次の仮定を置いている. \\((x_i,y_i)\\) は独立同一分布にしたがう. \\(E[u_i]=0\\) である. \\(u_i\\) と \\(x_i\\) は独立である. \\(u_i\\) は正規分布にしたがう. このとき最小二乗推定量は一致で, 不偏であり, 正規分布にしたがう. 一致とは推定量が観測値を増やすことによって真のパラメータに (確率) 収束することある. 不偏とは推定量の期待値が真のパラメータになることである. また他の線形不偏推定量のなかで最も分散が小さいことも知られている. R で回帰分析を実施するには lm を実施する. fm &lt;- lm(y ~ x, data=df) fm 自体はリストであり, 以下の要素がある. typeof(fm) ## [1] &quot;list&quot; names(fm) ## [1] &quot;coefficients&quot; &quot;residuals&quot; &quot;effects&quot; &quot;rank&quot; ## [5] &quot;fitted.values&quot; &quot;assign&quot; &quot;qr&quot; &quot;df.residual&quot; ## [9] &quot;xlevels&quot; &quot;call&quot; &quot;terms&quot; &quot;model&quot; 係数は次のコマンドを実施する. coef(fm) ## (Intercept) x ## 10.345546 2.364066 # coefficients(fm) 作図すると以下のようになる. plot(y~x,data=df) abline(fm) 残差は次のコマンドを実施する. head(resid(fm)) ## 1 2 3 4 5 6 ## 1.1424960 -0.4684232 1.3122064 1.1490120 0.3764364 -0.3188611 # residuals(fm) # with(fm, residuals) 予測値は次のコマンドを実施する. head(fitted(fm)) ## 1 2 3 4 5 6 ## 10.55528 12.61964 11.51179 10.44108 11.55596 11.95910 # fitted.values(fm) # with(fm, fitted.values) 残差自乗和は次のコマンドを実施する. deviance(fm) ## [1] 96.9633 sum(resid(fm)^2) ## [1] 96.9633 7.1.1 ティー検定 その結果を見るには summary を実施する. summary(fm) ## ## Call: ## lm(formula = y ~ x, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -2.16950 -0.65322 -0.09147 0.57712 2.66772 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 10.3455 0.1981 52.217 &lt; 2e-16 *** ## x 2.3641 0.3503 6.749 1.05e-09 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.9947 on 98 degrees of freedom ## Multiple R-squared: 0.3173, Adjusted R-squared: 0.3103 ## F-statistic: 45.55 on 1 and 98 DF, p-value: 1.054e-09 これをみれば各変数の係数がゼロのティー検定の結果が示されている. 他にも, 残差標準誤差, 決定係数, 修正済み決定係数, 全ての係数がゼロであるエフ検定の結果も示されている. summary(fm) もリストであり, それぞれの要素は以下である. typeof(summary(fm)) ## [1] &quot;list&quot; names(summary(fm)) ## [1] &quot;call&quot; &quot;terms&quot; &quot;residuals&quot; &quot;coefficients&quot; ## [5] &quot;aliased&quot; &quot;sigma&quot; &quot;df&quot; &quot;r.squared&quot; ## [9] &quot;adj.r.squared&quot; &quot;fstatistic&quot; &quot;cov.unscaled&quot; 単なる fm と同じ名前もあるが, 中身が違っている場合もある. 例えば residuals は同じであるが, 係数はより情報が加わっている. coef(summary(fm)) ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 10.345546 0.1981274 52.216628 2.432747e-73 ## x 2.364066 0.3502913 6.748858 1.054247e-09 # coefficients(summary(fm)) 残差の標準誤差は次のようにして得られる. sqrt(deviance(fm)/df.residual(fm)) ## [1] 0.9946967 with(summary(fm),sigma) ## [1] 0.9946967 決定係数は次のようにして計算する. 1-deviance(fm)/with(df, sum((y-mean(y))^2)) ## [1] 0.3172972 with(summary(fm),r.squared) ## [1] 0.3172972 調整済み決定係数は次のようにして計算する. 1-(deviance(fm)/df.residual(fm))/with(df, sum((y-mean(y))^2/(nrow(df)-1))) ## [1] 0.3103308 with(summary(fm),adj.r.squared) ## [1] 0.3103308 7.1.2 対数変換 次のモデルを考える. \\[ y = \\alpha + \\beta \\log(x) + u \\] 対数変換をおこなう場合, log を用いるとよい. fm &lt;- lm(y~log(x),data=df) summary(fm) ## ## Call: ## lm(formula = y ~ log(x), data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -2.59676 -0.68508 0.02221 0.73029 3.07824 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 11.95200 0.14950 79.948 &lt; 2e-16 *** ## log(x) 0.41874 0.09435 4.438 2.38e-05 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 1.099 on 98 degrees of freedom ## Multiple R-squared: 0.1674, Adjusted R-squared: 0.1589 ## F-statistic: 19.7 on 1 and 98 DF, p-value: 2.378e-05 作図すると以下のようになる. plot(y~log(x),data=df) abline(fm) 被説明変数が対数の場合も同様である. fm &lt;- lm(log(y)~x,data=df) summary(fm) ## ## Call: ## lm(formula = log(y) ~ x, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.216118 -0.060248 -0.003935 0.052931 0.213212 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 2.33623 0.01733 134.78 &lt; 2e-16 *** ## x 0.20626 0.03065 6.73 1.15e-09 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.08702 on 98 degrees of freedom ## Multiple R-squared: 0.3161, Adjusted R-squared: 0.3091 ## F-statistic: 45.29 on 1 and 98 DF, p-value: 1.151e-09 作図すると以下のようになる. plot(log(y)~x,data=df) abline(fm) 7.1.3 切片なし回帰モデル 次のモデルを考える. \\[ y = \\beta x + u \\] 切片なしモデルを推定したい場合は次のように -1 とする. fm &lt;- lm(y~x-1,data=df) summary(fm) ## ## Call: ## lm(formula = y ~ x - 1, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -5.580 -0.748 2.790 6.109 12.195 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## x 18.1829 0.9394 19.36 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 5.313 on 99 degrees of freedom ## Multiple R-squared: 0.791, Adjusted R-squared: 0.7889 ## F-statistic: 374.7 on 1 and 99 DF, p-value: &lt; 2.2e-16 もしくは +0 を加える. fm &lt;- lm(y~x+0,data=df) summary(fm) ## ## Call: ## lm(formula = y ~ x + 0, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -5.580 -0.748 2.790 6.109 12.195 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## x 18.1829 0.9394 19.36 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 5.313 on 99 degrees of freedom ## Multiple R-squared: 0.791, Adjusted R-squared: 0.7889 ## F-statistic: 374.7 on 1 and 99 DF, p-value: &lt; 2.2e-16 7.2 重回帰モデル 説明変数として \\(w\\) を加えたモデルを考える. \\[ y = \\alpha + \\beta x +\\gamma w+ u \\] 暗黙に次の仮定を置いている. \\((w_i, x_i,y_i)\\) は独立同一分布にしたがう. 誤差項の期待値はゼロである. \\(E[u_i]=0\\) である. 誤差項 \\(u_i\\) は説明変数 \\((x_i, w_i)\\) に対して独立である. 誤差項 \\(u_i\\) は正規分布にしたがう. 説明変数間に多重共線性は存在しない. つまり \\(x_i\\) は \\(w_i\\) の一次変換で表せない. 説明変数を加えたいときには + と変数名を使うことができる. fm &lt;- lm(y~x+w,data=df) summary(fm) ## ## Call: ## lm(formula = y ~ x + w, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -2.25713 -0.59389 -0.04157 0.60645 2.19005 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 10.7201 0.1997 53.685 &lt; 2e-16 *** ## x 2.5667 0.3237 7.929 3.80e-12 *** ## wT -0.8311 0.1857 -4.476 2.08e-05 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.9102 on 97 degrees of freedom ## Multiple R-squared: 0.4342, Adjusted R-squared: 0.4225 ## F-statistic: 37.21 on 2 and 97 DF, p-value: 1.013e-12 R の特徴は因子もとくに変換することなくダミー変数として扱える. 7.2.1 自乗項 説明変数として自乗項を加えたモデルを考える. \\[ y = \\alpha + \\beta x + \\gamma x^2 + u \\] R では単に自乗するのでなく I(x^2) としなければならない. fm &lt;- lm(y~x+I(x^2),data=df) summary(fm) ## ## Call: ## lm(formula = y ~ x + I(x^2), data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -2.14669 -0.74007 -0.07062 0.59000 2.73369 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 10.4770 0.2847 36.801 &lt;2e-16 *** ## x 1.5581 1.2985 1.200 0.233 ## I(x^2) 0.8215 1.2742 0.645 0.521 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.9977 on 97 degrees of freedom ## Multiple R-squared: 0.3202, Adjusted R-squared: 0.3062 ## F-statistic: 22.85 on 2 and 97 DF, p-value: 7.416e-09 7.2.2 交差項 説明変数として交差項を加えたモデルを考える. \\[ y = \\alpha + \\beta x + \\gamma w + \\delta xw + u \\] 説明変数 x と wの自乗項は自乗項は x:w である. fm&lt;-lm(y~x+w+x:w,data=df) summary(fm) ## ## Call: ## lm(formula = y ~ x + w + x:w, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -2.25232 -0.60417 -0.06445 0.59180 2.21250 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 10.8726 0.2664 40.812 &lt; 2e-16 *** ## x 2.2229 0.5125 4.337 3.57e-05 *** ## wT -1.1036 0.3655 -3.020 0.00324 ** ## x:wT 0.5731 0.6617 0.866 0.38858 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.9114 on 96 degrees of freedom ## Multiple R-squared: 0.4385, Adjusted R-squared: 0.421 ## F-statistic: 24.99 on 3 and 96 DF, p-value: 4.9e-12 もしくは以下のように * を使って簡便的に表せる. fm &lt;- lm(y~x*w,data=df) summary(fm) ## ## Call: ## lm(formula = y ~ x * w, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -2.25232 -0.60417 -0.06445 0.59180 2.21250 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 10.8726 0.2664 40.812 &lt; 2e-16 *** ## x 2.2229 0.5125 4.337 3.57e-05 *** ## wT -1.1036 0.3655 -3.020 0.00324 ** ## x:wT 0.5731 0.6617 0.866 0.38858 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.9114 on 96 degrees of freedom ## Multiple R-squared: 0.4385, Adjusted R-squared: 0.421 ## F-statistic: 24.99 on 3 and 96 DF, p-value: 4.9e-12 7.2.3 エフ検定 今, 帰無仮説が \\[ y = \\alpha + \\beta x + u \\] で, 対立仮説が \\[ y = \\alpha + \\beta x + \\gamma w + \\delta xw + u \\] となる検定を実施したい. これは複数の係数がゼロであるエフ検定である. 対立仮説の残差自乗和を \\(SSR\\) とし, その自由度を \\(df\\) とする. 自由度は観測数から説明変数の数を減じた数である. 帰無仮説の残差自乗和を \\(SSR_0\\) とし, 制約の数を \\(q\\) とする. 制約の数は帰無仮説の自由度から帰無仮説の自由度を差し引いた数である. このとき, 以下のF値は帰無仮説が正しいもと自由度 \\(df\\) と \\(q\\) のF分布にしたがう. \\[ \\frac{(SSR_0-SSR)/q}{SSR/df} \\] R でF値は次のようにして算出する. fm0 &lt;- lm(y~x,data=df) fm1 &lt;- lm(y~x*w,data=df) dof &lt;- fm1$df q &lt;- fm0$df-dof SSR0 &lt;- deviance(fm0) SSR &lt;- deviance(fm1) (F &lt;- ((SSR0-SSR)/q)/(SSR/dof)) ## [1] 10.36557 この時のP値は以下である. 1-pf(F,df1=q,df2=dof) ## [1] 8.395668e-05 これらの手順はコマンド anova を用いれば簡単に実現できる. anova(fm0,fm1) ## Analysis of Variance Table ## ## Model 1: y ~ x ## Model 2: y ~ x * w ## Res.Df RSS Df Sum of Sq F Pr(&gt;F) ## 1 98 96.963 ## 2 96 79.743 2 17.22 10.366 8.396e-05 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 順番を変えても, 検定統計量自体に変更はない. anova(fm1,fm0) ## Analysis of Variance Table ## ## Model 1: y ~ x * w ## Model 2: y ~ x ## Res.Df RSS Df Sum of Sq F Pr(&gt;F) ## 1 96 79.743 ## 2 98 96.963 -2 -17.22 10.366 8.396e-05 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 7.3 正規性の仮定について 単回帰において以下の仮定を置いていた. \\((x_i,y_i)\\) は独立同一分布にしたがう. \\(E[u_i]=0\\) である. \\(u_i\\) と \\(x_i\\) は独立である. \\(u_i\\) は正規分布にしたがう. 十分な観測値が得られるばあい, \\(u_i\\) が正規分布にしたがっていないくても, 中心極限定理定理より, 最小二乗法推定量は正規分布に近似できる. ここの係数ゼロのティー検定について, ライブラリ AER を導入して coeftest を用いればよい. coeftest(fm0,df=Inf) ## ## z test of coefficients: ## ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 10.34555 0.19813 52.2166 &lt; 2.2e-16 *** ## x 2.36407 0.35029 6.7489 1.49e-11 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ただ十分なデータのもとではティー値のままでもよい. 同様に複数制約の場合, エフ検定統計量に制約の数を乗じた統計量が 自由度が制約数のカイ二乗分布にしたがうことが知られている. これをR で実施するには waldtest を用いればよい. waldtest(fm0,fm1,test=&quot;Chisq&quot;) ## Wald test ## ## Model 1: y ~ x ## Model 2: y ~ x * w ## Res.Df Df Chisq Pr(&gt;Chisq) ## 1 98 ## 2 96 2 20.731 3.15e-05 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 エフ検定も十分なデータのもとではそのままでよいであろう. オプション test を付けなければエフ検定を実施する. waldtest(fm0,fm1) ## Wald test ## ## Model 1: y ~ x ## Model 2: y ~ x * w ## Res.Df Df F Pr(&gt;F) ## 1 98 ## 2 96 2 10.366 8.396e-05 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 これは anova と同じである. anova(fm0,fm1) ## Analysis of Variance Table ## ## Model 1: y ~ x ## Model 2: y ~ x * w ## Res.Df RSS Df Sum of Sq F Pr(&gt;F) ## 1 98 96.963 ## 2 96 79.743 2 17.22 10.366 8.396e-05 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 複数制約の検定としてLM検定というのもある. 制約付きの回帰分析を実行し, その残差を制約なしのモデルの説明変数に回帰する. その決定係数に観測数を掛けた統計量が自由どが制約の数のカイ二乗分布にしたがうことが知られている. lmt &lt;- lm(I(resid(fm1))~w*x,data=df) (lmt &lt;- nrow(df)*summary(lmt)$r.squared) ## [1] 4.525349e-30 1-pchisq(lmt,df=1) ## [1] 1 7.4 誤差項と説明変数が独立の仮定について また \\(u_i\\) と \\(x_i\\) は独立でなく, \\(u_i\\) と \\(x_i\\) が無相関という弱い条件のもとでも, 一致推定量であることが知られている. ただ不偏推定量は保証できない. また 線形推定量のなかで最小の分散とも言えない.5 また独立のときの標準誤差の推定量が一致推定量でない. ただし, 別の分散のもとで正規分布に近似できることがしられている.6 つまり, 説明変数と誤差項が無相関であるが, 独立とまでは言い切れない場合, 最小二乗推定量を実行した際, 別の方法で分散を推定する必要がある. この別の分散をロバスト分散という. R でロバスト分散を推定するにはパッケージ AER を導入するのが簡単である. は次のコマンド coeftest を実行すればよい. coeftest(fm1,vcov=vcovHC) ## ## t test of coefficients: ## ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 10.87259 0.25346 42.8971 &lt; 2.2e-16 *** ## x 2.22288 0.51679 4.3013 4.084e-05 *** ## wT -1.10358 0.31869 -3.4628 0.0008 *** ## x:wT 0.57309 0.61097 0.9380 0.3506 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 先の値と標準誤差が違っていることが確認できるであろう. ただこの値は STATA と少し異なっている. STATA と同じにするには coeftest(fm1,vcov=vcovHC(fm1,type=&quot;HC1&quot;)) ## ## t test of coefficients: ## ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 10.87259 0.24254 44.8287 &lt; 2.2e-16 *** ## x 2.22288 0.48912 4.5446 1.603e-05 *** ## wT -1.10358 0.30804 -3.5826 0.0005364 *** ## x:wT 0.57309 0.58367 0.9819 0.3286299 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 としなければならない. またティー分布でなく正規分布とすることもできる. coeftest(fm0,vcov=vcovHC,df=Inf) ## ## z test of coefficients: ## ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 10.34555 0.19163 53.9880 &lt; 2.2e-16 *** ## x 2.36407 0.33033 7.1566 8.269e-13 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 複数の係数についての検定は waldtest を実行すればよい. waldtest(fm0,fm1,vcov=vcovHC) ## Wald test ## ## Model 1: y ~ x ## Model 2: y ~ x * w ## Res.Df Df F Pr(&gt;F) ## 1 98 ## 2 96 2 10.466 7.731e-05 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 先の結果はエフ検定であるが, カイ二乗検定を実施するには以下を実施すればよい. waldtest(fm0,fm1,vcov=vcovHC, test=&quot;Chisq&quot;) ## Wald test ## ## Model 1: y ~ x ## Model 2: y ~ x * w ## Res.Df Df Chisq Pr(&gt;Chisq) ## 1 98 ## 2 96 2 20.932 2.849e-05 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 7.5 分散均一の検定 誤差項が説明変数と独立のときと無相関のときでは標準誤差の推定量が異なる. 正確にいうと, 条件付き分散が説明変数に依存するかどうかによって標準誤差の推定量が異なる. このことは分散均一と呼ばれている. 誤差項の分散が均一かどうかは検定可能である. 有名な検定方法としてBP (Breusch-Pagan) 検定というものがある. BP検定は帰無仮説が分散均一で, 対立仮説が分散が説明変数と線形関係になっている場合の検定である. 残差の自乗を被説明変数として回帰分析をおこない, その決定係数に観測数をかけたものが検定統計量となる. bpt &lt;- lm(I(resid(fm1)^2)~w*x,data=df) (bpt &lt;- nrow(df)*summary(bpt)$r.squared) ## [1] 4.135518 1-pchisq(bpt,df=3) ## [1] 0.2471976 ここでの例ではP値が5%を超えているので帰無仮説を棄却できないので, 分散均一を仮定してよいことが示唆されている. R では以下のように実施すればよい. bptest(fm1) ## ## studentized Breusch-Pagan test ## ## data: fm1 ## BP = 4.1355, df = 3, p-value = 0.2472 これまでのBPテストは誤差項の分散が説明変数の線形関係あることを暗黙に仮定している. 非線形性を考慮するために説明変数の二次項を導入した分散不均一性の検定をホワイト検定という. 説明変数が複数ある場合ホワイト検定は煩雑になるため, 被説明変数の予測値を使って計算することがある. そのときホワイトテストは以下で実施する. wht &lt;- lm(I(resid(fm1)^2)~fitted(fm1)+I(fitted(fm1)^2),data=df) (wht &lt;- nrow(df)*summary(wht)$r.squared) ## [1] 3.180459 1-pchisq(wht,df=2) ## [1] 0.2038788 ホワイト検定でも分散均一が示唆されている. もしくは以下を実行する. bptest(fm1,~fitted(fm1)+I(fitted(fm1)^2)) ## ## studentized Breusch-Pagan test ## ## data: fm1 ## BP = 3.1805, df = 2, p-value = 0.2039 このように分散均一性は検定することが可能であるが, そもそも分散均一が疑われる場合は, ロバスト分散で推定するので十分であるため最近の実証分析ではこの検定は実施されない. 正確にいえば, 不偏推定量のとめには条件付き期待値が説明変数に依存しないことが必要である. また線形推定量のなかで最小の分散になるためには 条件付き分散が説明変数に依存しないことが必要である.↩ 正確には観測される変数に4次のモーメントが存在するという仮定が必要となる. この仮定の直感的な意味は異常値が存在しないことである.↩ "],
["08-ivreg.html", "8 操作変数法 8.1 データ 8.2 操作変数 8.3 2段階最小二乗法 8.4 複数制約の検定 8.5 特定化検定 8.6 ロバスト分散 8.7 分散不均一の検定", " 8 操作変数法 8.1 データ library(AER) library(wooldridge) data(&quot;mroz&quot;, package=&quot;wooldridge&quot;) df &lt;- subset(mroz, inlf==1) 8.2 操作変数 これまで回帰モデルで一致推定量を得るためには次の仮定が必要であった. 母集団が線形モデル 標本が無作為抽出 誤差項が平均ゼロで説明変数と無相関 説明変数に多重共線性が存在しない 3つ目の説明変数が必ずしも成立しない場合の推定方法を紹介する. そのために, 外生変数と内生変数と操作変数の3つの概念を導入する. 説明変数を外生変数と内生変数に分ける. 誤差項と相関が無い説明変数を 外生変数 といい, 誤差項と相関がある説明変数を 内生変数 という. 操作変数 とは, 説明変数に含まれず, 説明変数と相関をもち, 誤差項と相関をもたない変数のことである. なお操作変数の個数は内生変数の個数より多いと仮定する. 8.3 2段階最小二乗法 操作変数をつかって, 係数の一致推定量を得るには二段階最小自乗法を用いる. 二段階最小二乗法は次の手順で実行される: それぞれの内生変数を外生変数と操作変数に回帰させて, その予測値を得る. 被説明変数を外生変数と内生変数の予測値に回帰させてその係数を得る. この係数が一致推定量になるための条件は以下である. 母集団が線形モデル 標本が無作為抽出 誤差項が平均ゼロで操作変数と外生変数に対して独立. 操作変数は内生変数と相関をもつ. 外生変数と内生変数の予測値に多重共線性が存在しない` R においては次のコマンドを実行すればよい. ここで被説明変数は log(wage), 内生変数は educ, 外生変数は expr, I(expr^2), 操作変数は motheduc, fatheduc である. fm &lt;- ivreg(log(wage)~educ+exper+I(exper^2)| exper+I(exper^2)+motheduc+fatheduc, data=df) summary(fm) ## ## Call: ## ivreg(formula = log(wage) ~ educ + exper + I(exper^2) | exper + ## I(exper^2) + motheduc + fatheduc, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -3.0986 -0.3196 0.0551 0.3689 2.3493 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.0481003 0.4003281 0.120 0.90442 ## educ 0.0613966 0.0314367 1.953 0.05147 . ## exper 0.0441704 0.0134325 3.288 0.00109 ** ## I(exper^2) -0.0008990 0.0004017 -2.238 0.02574 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.6747 on 424 degrees of freedom ## Multiple R-Squared: 0.1357, Adjusted R-squared: 0.1296 ## Wald test: 8.141 on 3 and 424 DF, p-value: 2.787e-05 実際の二段階最小二乗法でも確認できる. ただし標準誤差の値が異なっている. なぜなら残差は内生変数および外生変数から算出させる必要があるが, 以下のやりかただと内生変数の予測値および外生変数から算出するためである. ols1 &lt;- lm(educ~exper+I(exper^2)+motheduc+fatheduc, data = df) ols2 &lt;- lm(log(wage)~fitted(ols1)+exper+I(exper^2), data = df) summary(ols2) ## ## Call: ## lm(formula = log(wage) ~ fitted(ols1) + exper + I(exper^2), data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -3.1631 -0.3539 0.0326 0.3818 2.3727 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.0481003 0.4197565 0.115 0.90882 ## fitted(ols1) 0.0613966 0.0329624 1.863 0.06321 . ## exper 0.0441704 0.0140844 3.136 0.00183 ** ## I(exper^2) -0.0008990 0.0004212 -2.134 0.03338 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.7075 on 424 degrees of freedom ## Multiple R-squared: 0.04978, Adjusted R-squared: 0.04306 ## F-statistic: 7.405 on 3 and 424 DF, p-value: 7.615e-05 8.4 複数制約の検定 帰無仮説が複数制約のワルド検定は以下のように実施する. 例えば, 2つの外生変数の係数がゼロのときの仮説検定をRで実行するには以下を実施する. fm0 &lt;- ivreg(log(wage)~educ|motheduc+fatheduc,data=df) waldtest(fm0,fm) ## Wald test ## ## Model 1: log(wage) ~ educ | motheduc + fatheduc ## Model 2: log(wage) ~ educ + exper + I(exper^2) | exper + I(exper^2) + ## motheduc + fatheduc ## Res.Df Df Chisq Pr(&gt;Chisq) ## 1 426 ## 2 424 2 19.639 5.439e-05 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 LM検定は以下のように実施すればよい. lmt &lt;- lm(resid(fm0)~educ + exper + I(exper^2) ,data=df) (lmt &lt;- nrow(df)*summary(lmt)$r.squared) ## [1] 33.97987 1-pchisq(lmt,df=3) ## [1] 2.000665e-07 8.5 特定化検定 またいくつかの特定化検定も以下のコマンドで実施できる. summary(fm, diagnostics = TRUE) ## ## Call: ## ivreg(formula = log(wage) ~ educ + exper + I(exper^2) | exper + ## I(exper^2) + motheduc + fatheduc, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -3.0986 -0.3196 0.0551 0.3689 2.3493 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.0481003 0.4003281 0.120 0.90442 ## educ 0.0613966 0.0314367 1.953 0.05147 . ## exper 0.0441704 0.0134325 3.288 0.00109 ** ## I(exper^2) -0.0008990 0.0004017 -2.238 0.02574 * ## ## Diagnostic tests: ## df1 df2 statistic p-value ## Weak instruments 2 423 55.400 &lt;2e-16 *** ## Wu-Hausman 1 423 2.793 0.0954 . ## Sargan 1 NA 0.378 0.5386 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.6747 on 424 degrees of freedom ## Multiple R-Squared: 0.1357, Adjusted R-squared: 0.1296 ## Wald test: 8.141 on 3 and 424 DF, p-value: 2.787e-05 8.5.1 Weak instruments 操作変数が内生変数と弱い相関関係しかない場合, 弱操作変数という. それぞれの内生変数に対して, 帰無仮説を内生変数を外生変数のみ回帰させたモデルとし, 対立仮説を内生変数を外生変数および操作変数のみ回帰させたモデルとし, F検定を実施する. ols0 &lt;- lm(educ ~ exper + I(exper^2), data = df) anova(ols0, ols1) ## Analysis of Variance Table ## ## Model 1: educ ~ exper + I(exper^2) ## Model 2: educ ~ exper + I(exper^2) + motheduc + fatheduc ## Res.Df RSS Df Sum of Sq F Pr(&gt;F) ## 1 425 2219.2 ## 2 423 1758.6 2 460.64 55.4 &lt; 2.2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 8.5.2 Du-Hausman 検定 Du-Hausman 検定は 帰無仮説が誤差項と説明変数が無相関, 対立仮説が誤差項と説明変数が相関ありの検定をおこなう. 帰無仮説のもと, OLSも2SLSも一致推定量である. よって検定統計量のP値が十分小さいなら, 帰無仮説は棄却して, より効率的な最小二乗法を実施する. そうでなければ操作変数法を選択する. 具体的には以下のF検定を実施する. 1. それぞれの内生変数を外生変数に回帰したときの残差える. (residuals(ols1)) 2. 被説明変数を説明変数に回帰する (ols3) 3. 被説明変数を説明変数および先程の残差に回帰する (ols4) 4. これらの残差の係数はゼロであるという帰無仮説のもとF検定を実施する. ols3 &lt;- lm(log(wage) ~ educ + exper + I(exper^2), data = df) ols4 &lt;- update(ols3, . ~ . + residuals(ols1)) anova(ols3,ols4) ## Analysis of Variance Table ## ## Model 1: log(wage) ~ educ + exper + I(exper^2) ## Model 2: log(wage) ~ educ + exper + I(exper^2) + residuals(ols1) ## Res.Df RSS Df Sum of Sq F Pr(&gt;F) ## 1 424 188.31 ## 2 423 187.07 1 1.235 2.7926 0.09544 . ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 8.5.3 Sargan 検定 Sargan 検定は 誤差項が操作変数 (および外生変数) と相関しているかどうかを検定する. 帰無仮説が相関が無い場合で, 対立仮説は相関がある場合である. LM検定を実施する. 1. 二段階最小二乗法を実施したときの残差える. (resid(fm)) 2. 残差を外生変数および操作変数に回帰する. 3. 回帰の決定係数に観測数を乗じたLM統計量をえる. 4. 検定統計量は, 帰無仮説のもと, 操作変数の数から内生変数の数を差し引いた自由度のカイ二乗分布にしたがう. jt &lt;- lm(resid(fm)~exper+I(exper^2)+motheduc+fatheduc,data=df) (jt &lt;- nrow(df)*summary(jt)$r.squared) ## [1] 0.3780714 1-pchisq(jt,df=1) ## [1] 0.5386372 8.6 ロバスト分散 以上の分析は, 誤差項が操作変数と独立の場合の分析である. 独立でない場合, 推定量の分散が変わりうる. そうした分散をロバスト分散という. ロバスト分散は次のコマンドで実施する. summary(fm, vcov = sandwich, df = Inf) ## ## Call: ## ivreg(formula = log(wage) ~ educ + exper + I(exper^2) | exper + ## I(exper^2) + motheduc + fatheduc, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -3.0986 -0.3196 0.0551 0.3689 2.3493 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 0.0481003 0.4277846 0.112 0.91047 ## educ 0.0613966 0.0331824 1.850 0.06427 . ## exper 0.0441704 0.0154736 2.855 0.00431 ** ## I(exper^2) -0.0008990 0.0004281 -2.100 0.03572 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.6747 on Inf degrees of freedom ## Multiple R-Squared: 0.1357, Adjusted R-squared: 0.1296 ## Wald test: 18.61 on 3 DF, p-value: 0.0003291 また次のコマンドでも可能である. coeftest(fm, vcov=sandwich) ## ## t test of coefficients: ## ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.04810030 0.42778460 0.1124 0.910527 ## educ 0.06139663 0.03318243 1.8503 0.064969 . ## exper 0.04417039 0.01547356 2.8546 0.004521 ** ## I(exper^2) -0.00089897 0.00042807 -2.1001 0.036314 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ロバスト分散のもとでの複数制約の検定は以下を実施する. waldtest(fm0,fm, vcov=sandwich) ## Wald test ## ## Model 1: log(wage) ~ educ | motheduc + fatheduc ## Model 2: log(wage) ~ educ + exper + I(exper^2) | exper + I(exper^2) + ## motheduc + fatheduc ## Res.Df Df Chisq Pr(&gt;Chisq) ## 1 426 ## 2 424 2 15.018 0.0005483 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 8.7 分散不均一の検定 誤差項が操作変数と独立なら条件付き分散は操作変数に無関係で均一である. これを利用して分散均一を帰無仮説に, 分散不均一を対立仮説にしたBP検定が実行可能である. ただ通常のコマンド bptest では正しく実行できないので注意が必要である. bpt &lt;- lm(I(resid(fm)^2)~exper + I(exper^2) + motheduc + fatheduc,data=df) (bpt &lt;- nrow(df)*summary(bpt)$r.squared) ## [1] 12.41758 1-pchisq(bpt,df=4) ## [1] 0.01450172 "],
["09-panel.html", "9 パネル分析 9.1 データ 9.2 プーリングOLS 9.3 固定効果モデル 9.4 固定効果VSプーリングOLS 9.5 変量効果モデル 9.6 ハウスマン検定 9.7 分散不均一の検定", " 9 パネル分析 9.1 データ library(plm) ## 要求されたパッケージ Formula をロード中です data(&quot;Grunfeld&quot;, package=&quot;plm&quot;) head(Grunfeld) ## firm year inv value capital ## 1 1 1935 317.6 3078.5 2.8 ## 2 1 1936 391.8 4661.7 52.6 ## 3 1 1937 410.6 5387.1 156.9 ## 4 1 1938 257.7 2792.2 209.2 ## 5 1 1939 330.8 4313.2 203.4 ## 6 1 1940 461.2 4643.9 207.2 9.2 プーリングOLS \\[ inv_{it} = \\beta_0 + \\beta_1 value_{it} + \\beta_2 capital_{it} + u_{it} \\] 誤差項 \\(u_{it}\\) は \\(i\\) についても \\(t\\) についても独立同一分布と仮定する. さらに誤差項は説明変数と独立である. この推計は以下のようにする. gp &lt;- plm(inv ~ value + capital, data = Grunfeld, model = &quot;pooling&quot;) summary(gp) ## Pooling Model ## ## Call: ## plm(formula = inv ~ value + capital, data = Grunfeld, model = &quot;pooling&quot;) ## ## Balanced Panel: n = 10, T = 20, N = 200 ## ## Residuals: ## Min. 1st Qu. Median 3rd Qu. Max. ## -291.6757 -30.0137 5.3033 34.8293 369.4464 ## ## Coefficients: ## Estimate Std. Error t-value Pr(&gt;|t|) ## (Intercept) -42.7143694 9.5116760 -4.4907 1.207e-05 *** ## value 0.1155622 0.0058357 19.8026 &lt; 2.2e-16 *** ## capital 0.2306785 0.0254758 9.0548 &lt; 2.2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Total Sum of Squares: 9359900 ## Residual Sum of Squares: 1755900 ## R-Squared: 0.81241 ## Adj. R-Squared: 0.8105 ## F-statistic: 426.576 on 2 and 197 DF, p-value: &lt; 2.22e-16 これは以下の回帰分析と同じである. summary(lm(inv ~ value + capital, data = Grunfeld)) ## ## Call: ## lm(formula = inv ~ value + capital, data = Grunfeld) ## ## Residuals: ## Min 1Q Median 3Q Max ## -291.68 -30.01 5.30 34.83 369.45 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -42.714369 9.511676 -4.491 1.21e-05 *** ## value 0.115562 0.005836 19.803 &lt; 2e-16 *** ## capital 0.230678 0.025476 9.055 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 94.41 on 197 degrees of freedom ## Multiple R-squared: 0.8124, Adjusted R-squared: 0.8105 ## F-statistic: 426.6 on 2 and 197 DF, p-value: &lt; 2.2e-16 9.3 固定効果モデル 次のモデルを考える. \\[ inv_{it} = \\beta_1 value_{it} + \\beta_2 capital_{it} +\\alpha_i + u_{it} \\] この \\(\\alpha_i\\) は固定効果と呼ばれている. \\(\\alpha_i\\) は時間 \\(t\\) に対して一定である. \\(\\alpha_i\\) は誤差項と相関があるもしれない. この推計は以下のようにする. gi &lt;- plm(inv ~ value + capital, data = Grunfeld, model = &quot;within&quot;) summary(gi) ## Oneway (individual) effect Within Model ## ## Call: ## plm(formula = inv ~ value + capital, data = Grunfeld, model = &quot;within&quot;) ## ## Balanced Panel: n = 10, T = 20, N = 200 ## ## Residuals: ## Min. 1st Qu. Median 3rd Qu. Max. ## -184.00857 -17.64316 0.56337 19.19222 250.70974 ## ## Coefficients: ## Estimate Std. Error t-value Pr(&gt;|t|) ## value 0.110124 0.011857 9.2879 &lt; 2.2e-16 *** ## capital 0.310065 0.017355 17.8666 &lt; 2.2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Total Sum of Squares: 2244400 ## Residual Sum of Squares: 523480 ## R-Squared: 0.76676 ## Adj. R-Squared: 0.75311 ## F-statistic: 309.014 on 2 and 188 DF, p-value: &lt; 2.22e-16 固定効果は以下のコマンドで確かめられる. fixef(gi) ## 1 2 3 4 5 6 ## -70.296717 101.905814 -235.571841 -27.809295 -114.616813 -23.161295 ## 7 8 9 10 ## -66.553474 -57.545657 -87.222272 -6.567844 これは以下の回帰分析と同じである. summary(lm(inv ~ value + capital+0+factor(firm), data = Grunfeld)) ## ## Call: ## lm(formula = inv ~ value + capital + 0 + factor(firm), data = Grunfeld) ## ## Residuals: ## Min 1Q Median 3Q Max ## -184.009 -17.643 0.563 19.192 250.710 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## value 0.11012 0.01186 9.288 &lt; 2e-16 *** ## capital 0.31007 0.01735 17.867 &lt; 2e-16 *** ## factor(firm)1 -70.29672 49.70796 -1.414 0.1590 ## factor(firm)2 101.90581 24.93832 4.086 6.49e-05 *** ## factor(firm)3 -235.57184 24.43162 -9.642 &lt; 2e-16 *** ## factor(firm)4 -27.80929 14.07775 -1.975 0.0497 * ## factor(firm)5 -114.61681 14.16543 -8.091 7.14e-14 *** ## factor(firm)6 -23.16130 12.66874 -1.828 0.0691 . ## factor(firm)7 -66.55347 12.84297 -5.182 5.63e-07 *** ## factor(firm)8 -57.54566 13.99315 -4.112 5.85e-05 *** ## factor(firm)9 -87.22227 12.89189 -6.766 1.63e-10 *** ## factor(firm)10 -6.56784 11.82689 -0.555 0.5793 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 52.77 on 188 degrees of freedom ## Multiple R-squared: 0.9616, Adjusted R-squared: 0.9591 ## F-statistic: 392 on 12 and 188 DF, p-value: &lt; 2.2e-16 決定係数が大きく異なっていることに注意されたい. 次のモデルを考える. \\[ inv_{it} = \\beta_1 value_{it} + \\beta_2 capital_{it}+ \\gamma_t +\\alpha_i + u_{it} \\] この \\(\\gamma_t\\) は時間効果と呼ばれている. この推計は以下のようにする. gt &lt;- plm(inv ~ value + capital, data = Grunfeld, effect=&quot;twoways&quot;,model = &quot;within&quot;) summary(gt) ## Twoways effects Within Model ## ## Call: ## plm(formula = inv ~ value + capital, data = Grunfeld, effect = &quot;twoways&quot;, ## model = &quot;within&quot;) ## ## Balanced Panel: n = 10, T = 20, N = 200 ## ## Residuals: ## Min. 1st Qu. Median 3rd Qu. Max. ## -162.6094 -19.4710 -1.2669 19.1277 211.8420 ## ## Coefficients: ## Estimate Std. Error t-value Pr(&gt;|t|) ## value 0.117716 0.013751 8.5604 6.653e-15 *** ## capital 0.357916 0.022719 15.7540 &lt; 2.2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Total Sum of Squares: 1615600 ## Residual Sum of Squares: 452150 ## R-Squared: 0.72015 ## Adj. R-Squared: 0.67047 ## F-statistic: 217.442 on 2 and 169 DF, p-value: &lt; 2.22e-16 これは以下の回帰分析と同じである. summary(lm(inv ~ value + capital+0+factor(firm)+factor(year), data = Grunfeld)) ## ## Call: ## lm(formula = inv ~ value + capital + 0 + factor(firm) + factor(year), ## data = Grunfeld) ## ## Residuals: ## Min 1Q Median 3Q Max ## -162.609 -19.471 -1.267 19.128 211.842 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## value 0.11772 0.01375 8.560 6.65e-15 *** ## capital 0.35792 0.02272 15.754 &lt; 2e-16 *** ## factor(firm)1 -86.90023 56.04663 -1.550 0.122893 ## factor(firm)2 120.15401 29.16688 4.120 5.93e-05 *** ## factor(firm)3 -222.13103 28.59744 -7.768 7.37e-13 *** ## factor(firm)4 8.45361 20.41784 0.414 0.679377 ## factor(firm)5 -92.33883 20.91106 -4.416 1.79e-05 *** ## factor(firm)6 15.98841 19.88487 0.804 0.422498 ## factor(firm)7 -35.43362 20.17003 -1.757 0.080772 . ## factor(firm)8 -19.40972 20.49076 -0.947 0.344868 ## factor(firm)9 -56.68267 19.81211 -2.861 0.004756 ** ## factor(firm)10 39.93689 20.40337 1.957 0.051951 . ## factor(year)1936 -19.19741 23.67586 -0.811 0.418596 ## factor(year)1937 -40.69001 24.69541 -1.648 0.101277 ## factor(year)1938 -39.22640 23.23594 -1.688 0.093221 . ## factor(year)1939 -69.47029 23.65607 -2.937 0.003780 ** ## factor(year)1940 -44.23508 23.80979 -1.858 0.064930 . ## factor(year)1941 -18.80446 23.69400 -0.794 0.428519 ## factor(year)1942 -21.13979 23.38163 -0.904 0.367219 ## factor(year)1943 -42.97762 23.55287 -1.825 0.069808 . ## factor(year)1944 -43.09877 23.61020 -1.825 0.069701 . ## factor(year)1945 -55.68304 23.89562 -2.330 0.020974 * ## factor(year)1946 -31.16928 24.11598 -1.292 0.197957 ## factor(year)1947 -39.39224 23.78368 -1.656 0.099522 . ## factor(year)1948 -43.71651 23.96965 -1.824 0.069945 . ## factor(year)1949 -73.49510 24.18292 -3.039 0.002750 ** ## factor(year)1950 -75.89611 24.34553 -3.117 0.002144 ** ## factor(year)1951 -62.48091 24.86425 -2.513 0.012911 * ## factor(year)1952 -64.63234 25.34950 -2.550 0.011672 * ## factor(year)1953 -67.71797 26.61108 -2.545 0.011832 * ## factor(year)1954 -93.52622 27.10786 -3.450 0.000708 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 51.72 on 169 degrees of freedom ## Multiple R-squared: 0.9668, Adjusted R-squared: 0.9607 ## F-statistic: 158.8 on 31 and 169 DF, p-value: &lt; 2.2e-16 決定係数が大きく異なっていることに注意されたい. 時間効果が有効かどうかはワルド検定を実施する. git&lt;-update(gi,.~.+factor(year)) library(lmtest) ## 要求されたパッケージ zoo をロード中です ## ## 次のパッケージを付け加えます: &#39;zoo&#39; ## 以下のオブジェクトは &#39;package:base&#39; からマスクされています: ## ## as.Date, as.Date.numeric waldtest(gi,git) ## Wald test ## ## Model 1: inv ~ value + capital ## Model 2: inv ~ value + capital + factor(year) ## Res.Df Df Chisq Pr(&gt;Chisq) ## 1 188 ## 2 169 19 26.662 0.1128 9.4 固定効果VSプーリングOLS 帰無仮説が固定効果, 対立仮説が固定効果モデルの検定は以下のコマンドを実行すればよい. pFtest(gi,gp) ## ## F test for individual effects ## ## data: inv ~ value + capital ## F = 49.177, df1 = 9, df2 = 188, p-value &lt; 2.2e-16 ## alternative hypothesis: significant effects 時間効果モデルの場合は次のようにする. gpt &lt;- plm(inv ~ value + capital + factor(year), data = Grunfeld, model = &quot;pooling&quot;) pFtest(gt,gpt) ## ## F test for twoways effects ## ## data: inv ~ value + capital ## F = 52.362, df1 = 9, df2 = 169, p-value &lt; 2.2e-16 ## alternative hypothesis: significant effects 9.5 変量効果モデル 次のモデルを考える. \\[ inv_{it} = \\beta_1 value_{it} + \\beta_2 capital_{it} +\\alpha_i + u_{it} \\] この \\(\\alpha_i\\) は変量効果と呼ばれている. \\(\\alpha_i\\) は時間 \\(t\\) について一定であるが, \\(i\\) について独立同一分布の確率変数にしたがう. さらに \\(\\alpha_i\\) は説明変数と無相関であることが必要である. このため固定効果モデルと違い, 欠落変数バイアスを除去することができない. しかしながら, \\(i\\) についてのダミー変数を付け加えることができる. 変量効果モデルは次のコマンドで実施する. gr &lt;- plm(inv ~ value + capital, data = Grunfeld, model = &quot;random&quot;) summary(gr) ## Oneway (individual) effect Random Effect Model ## (Swamy-Arora&#39;s transformation) ## ## Call: ## plm(formula = inv ~ value + capital, data = Grunfeld, model = &quot;random&quot;) ## ## Balanced Panel: n = 10, T = 20, N = 200 ## ## Effects: ## var std.dev share ## idiosyncratic 2784.46 52.77 0.282 ## individual 7089.80 84.20 0.718 ## theta: 0.8612 ## ## Residuals: ## Min. 1st Qu. Median 3rd Qu. Max. ## -177.6063 -19.7350 4.6851 19.5105 252.8743 ## ## Coefficients: ## Estimate Std. Error t-value Pr(&gt;|t|) ## (Intercept) -57.834415 28.898935 -2.0013 0.04674 * ## value 0.109781 0.010493 10.4627 &lt; 2e-16 *** ## capital 0.308113 0.017180 17.9339 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Total Sum of Squares: 2381400 ## Residual Sum of Squares: 548900 ## R-Squared: 0.7695 ## Adj. R-Squared: 0.76716 ## F-statistic: 328.837 on 2 and 197 DF, p-value: &lt; 2.22e-16 時間効果のある変量モデルとは次のコマンドを実施する. grt &lt;- plm(inv ~ value + capital + factor(year), data = Grunfeld, model = &quot;random&quot;) summary(grt) ## Oneway (individual) effect Random Effect Model ## (Swamy-Arora&#39;s transformation) ## ## Call: ## plm(formula = inv ~ value + capital + factor(year), data = Grunfeld, ## model = &quot;random&quot;) ## ## Balanced Panel: n = 10, T = 20, N = 200 ## ## Effects: ## var std.dev share ## idiosyncratic 2675.43 51.72 0.274 ## individual 7095.25 84.23 0.726 ## theta: 0.864 ## ## Residuals: ## Min. 1st Qu. Median 3rd Qu. Max. ## -160.759401 -19.805349 -0.028228 19.194961 214.295364 ## ## Coefficients: ## Estimate Std. Error t-value Pr(&gt;|t|) ## (Intercept) -29.828275 32.380484 -0.9212 0.358203 ## value 0.113779 0.011759 9.6763 &lt; 2.2e-16 *** ## capital 0.354336 0.022594 15.6826 &lt; 2.2e-16 *** ## factor(year)1936 -17.690058 23.612087 -0.7492 0.454729 ## factor(year)1937 -38.006448 24.356323 -1.5604 0.120433 ## factor(year)1938 -38.400547 23.303431 -1.6478 0.101148 ## factor(year)1939 -67.669031 23.605147 -2.8667 0.004648 ** ## factor(year)1940 -42.210436 23.716150 -1.7798 0.076812 . ## factor(year)1941 -16.896674 23.640596 -0.7147 0.475711 ## factor(year)1942 -19.950610 23.442180 -0.8511 0.395882 ## factor(year)1943 -41.303361 23.564907 -1.7527 0.081367 . ## factor(year)1944 -41.301975 23.603031 -1.7499 0.081866 . ## factor(year)1945 -53.418089 23.807547 -2.2437 0.026081 * ## factor(year)1946 -28.601243 23.973397 -1.1930 0.234441 ## factor(year)1947 -37.647517 23.832869 -1.5796 0.115963 ## factor(year)1948 -41.944013 24.029174 -1.7455 0.082615 . ## factor(year)1949 -71.515032 24.236975 -2.9507 0.003598 ** ## factor(year)1950 -73.609655 24.379280 -3.0194 0.002906 ** ## factor(year)1951 -59.205876 24.754226 -2.3917 0.017810 * ## factor(year)1952 -60.963457 25.209460 -2.4183 0.016602 * ## factor(year)1953 -62.886188 26.252610 -2.3954 0.017638 * ## factor(year)1954 -88.564196 26.819791 -3.3022 0.001159 ** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Total Sum of Squares: 2376000 ## Residual Sum of Squares: 479720 ## R-Squared: 0.7981 ## Adj. R-Squared: 0.77428 ## F-statistic: 33.506 on 21 and 178 DF, p-value: &lt; 2.22e-16 時間効果が有意かどうかは次の検定を実施すれば良い. waldtest(gr,grt) ## Wald test ## ## Model 1: inv ~ value + capital ## Model 2: inv ~ value + capital + factor(year) ## Res.Df Df Chisq Pr(&gt;Chisq) ## 1 197 ## 2 178 19 25.303 0.1508 9.6 ハウスマン検定 帰無仮説が変量効果モデル, 対立仮説が固定効果モデルの検定はハウスマン検定を実施する. ハウスマン検定は以下で実施する. phtest(gi,gr) ## ## Hausman Test ## ## data: inv ~ value + capital ## chisq = 2.3304, df = 2, p-value = 0.3119 ## alternative hypothesis: one model is inconsistent 時間効果がある場合以下を実行すればよい. phtest(gt,grt) ## ## Hausman Test ## ## data: inv ~ value + capital ## chisq = 6.5733, df = 2, p-value = 0.03738 ## alternative hypothesis: one model is inconsistent 9.7 分散不均一の検定 分散不均一かどうかは時間効果がない場合, 以下のようにすればよい. bptest(inv ~ value + capital + factor(firm), data=Grunfeld) ## ## studentized Breusch-Pagan test ## ## data: inv ~ value + capital + factor(firm) ## BP = 85.836, df = 11, p-value = 1.086e-13 分散不均一が疑われる場合, クラスターロバスト分散を用いる. coeftest(gi,vcov=vcovHC(gi,type=&quot;sss&quot;)) ## ## t test of coefficients: ## ## Estimate Std. Error t value Pr(&gt;|t|) ## value 0.110124 0.015156 7.2660 9.596e-12 *** ## capital 0.310065 0.052618 5.8927 1.726e-08 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 分散不均一かどうかは時間効果がある場合, 以下のようにすればよい. bptest(inv ~ value + capital + factor(firm) + factor(year),data=Grunfeld) ## ## studentized Breusch-Pagan test ## ## data: inv ~ value + capital + factor(firm) + factor(year) ## BP = 97.357, df = 30, p-value = 4.833e-09 分散不均一が疑われる場合, クラスターロバスト分散を用いる. coeftest(gt,vcov=vcovHC(gt,type=&quot;sss&quot;)) ## ## t test of coefficients: ## ## Estimate Std. Error t value Pr(&gt;|t|) ## value 0.117716 0.010263 11.4697 &lt; 2.2e-16 *** ## capital 0.357916 0.045367 7.8893 3.62e-13 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 また次のようにしても求められる. coeftest(git,vcov=vcovHC(git,type=&quot;HC1&quot;,cluster = &quot;group&quot;)) ## ## t test of coefficients: ## ## Estimate Std. Error t value Pr(&gt;|t|) ## value 0.117716 0.010266 11.4667 &lt; 2.2e-16 *** ## capital 0.357916 0.045380 7.8872 3.665e-13 *** ## factor(year)1936 -19.197405 19.630596 -0.9779 0.3295053 ## factor(year)1937 -40.690009 31.565895 -1.2890 0.1991424 ## factor(year)1938 -39.226404 14.924544 -2.6283 0.0093713 ** ## factor(year)1939 -69.470288 25.605714 -2.7131 0.0073565 ** ## factor(year)1940 -44.235085 16.475952 -2.6848 0.0079797 ** ## factor(year)1941 -18.804463 16.926601 -1.1109 0.2681716 ## factor(year)1942 -21.139792 13.433918 -1.5736 0.1174471 ## factor(year)1943 -42.977623 11.896875 -3.6125 0.0003996 *** ## factor(year)1944 -43.098772 10.428514 -4.1328 5.630e-05 *** ## factor(year)1945 -55.683040 14.417542 -3.8622 0.0001598 *** ## factor(year)1946 -31.169284 19.837679 -1.5712 0.1180028 ## factor(year)1947 -39.392242 25.073011 -1.5711 0.1180294 ## factor(year)1948 -43.716514 36.872612 -1.1856 0.2374409 ## factor(year)1949 -73.495099 36.280703 -2.0257 0.0443649 * ## factor(year)1950 -75.896112 34.899790 -2.1747 0.0310435 * ## factor(year)1951 -62.480912 46.868328 -1.3331 0.1842881 ## factor(year)1952 -64.632341 48.901664 -1.3217 0.1880611 ## factor(year)1953 -67.717966 41.487585 -1.6322 0.1044895 ## factor(year)1954 -93.526221 30.089357 -3.1083 0.0022084 ** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 "],
["test.html", "9.8 R Markdown 9.9 Including Plots", " 9.8 R Markdown This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see http://rmarkdown.rstudio.com. When you click the Knit button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this: summary(cars) ## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00 9.9 Including Plots You can also embed plots, for example: Note that the echo = FALSE parameter was added to the code chunk to prevent printing of the R code that generated the plot. "]
]
