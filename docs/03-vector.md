---
title: "vector"
output: html_document
---

# ベクトル


## ベクトル
Rでは同じ型の値を集めたものをベクトルという.
ベクトルは `c()` を用いて構成する. 

```r
(num<-c(2,3,7,9))
## [1] 2 3 7 9
(chr <- c("cat","dog","cow"))
## [1] "cat" "dog" "cow"
```

ベクトルには長さという属性 (attribute) が付く.

```r
length(num)
## [1] 4
length(chr)
## [1] 3
```
ベクトルはオブジェクトの基本であり, 一つの値は長さが1のベクトルと考える.

型が同じでない場合, 強制的に同じ型に変換される.
文字列が含まれればすべて文字列になる.
数値と論理値の場合は論理値の `TRUE` が1に `FALSE` が0に変換される.


```r
(x<- c(1,4))
## [1] 1 4
typeof(x)
## [1] "double"
(y <- c(2,FALSE,"4"))
## [1] "2"     "FALSE" "4"
typeof(y)
## [1] "character"
(z <- c(2,FALSE))
## [1] 2 0
typeof(z)
## [1] "double"
```

## 算術演算子
四則演算などの算術演算子はその対象を数値ベクトルに拡張できる.
ベクトルの算術演算子はその要素ごと行う.

```r
a<-c(2,3,3,3)
b<-c(3,3,5,7)
a+b
## [1]  5  6  8 10
a-b
## [1] -1  0 -2 -4
a*b
## [1]  6  9 15 21
a/b
## [1] 0.6666667 1.0000000 0.6000000 0.4285714
a^b
## [1]    8   27  243 2187
```

片方が値, 同じ長さのベクトルとして演算が実行される.

```r
a+2
## [1] 4 5 5 5
a-2
## [1] 0 1 1 1
a*2
## [1] 4 6 6 6
a/2
## [1] 1.0 1.5 1.5 1.5
a^2
## [1] 4 9 9 9
```

一般に長さが違う場合, 短いほうが繰り返される.

```r
c<-c(1,2)
a+c
## [1] 3 5 4 5
a-c
## [1] 1 1 2 1
a*c
## [1] 2 6 3 6
a/c
## [1] 2.0 1.5 3.0 1.5
a^c
## [1] 2 9 3 9
```
なお 短いほうが長い方の約数でないと警告がでる.

## 論理演算子
論理値に対して演算をおこなって論理値を返す論理演算子というものがある.
Rには, 論理演算子として, 否定 (`!`), または (`|`), かつ (`&`) がある.
論理演算子もベクトルごとに評価できる.


```r
logic1 <- c(TRUE, FALSE, FALSE)
logic2 <- c(TRUE, TRUE, FALSE)
!logic1
## [1] FALSE  TRUE  TRUE
logic1 | logic2
## [1]  TRUE  TRUE FALSE
logic1 & logic2
## [1]  TRUE FALSE FALSE
```

ベクトルのうちすべての要素が `TRUE` かどうかを評価する `all` や
少なくとも一つの要素が `TRUE` かどうかを評価する `any` というのがある.
,

```r
any(logic1)
## [1] TRUE
all(logic1)
## [1] FALSE
```


## 比較演算子
2つの値を比較してして論理値を返す比較演算子というものがある.
Rには, 比較演算子として, 等しいか `==`, どちらかが大きいか `>`,  `<` がある.
それぞれのベクトルの要素ごとに評価できる.

```r
vec1 <- 1:4
vec2 <- c(2,1,3,4)
vec1 == vec2
## [1] FALSE FALSE  TRUE  TRUE
vec1 > vec2
## [1] FALSE  TRUE FALSE FALSE
vec1 < vec2
## [1]  TRUE FALSE FALSE FALSE
```

他にも等しくない `!=`, 以上および以下 `>=`, `<=` がある.

```r
vec1 != vec2 # !(vec1==vec2)
## [1]  TRUE  TRUE FALSE FALSE
vec1 >= vec2 # (vec1 > vec2 | vec1 == vec2)
## [1] FALSE  TRUE  TRUE  TRUE
vec1 <= vec2 # (vec1 < vec2 | vec1 == vec2)
## [1]  TRUE FALSE  TRUE  TRUE
```

片方が値, 同じ長さのベクトルとして演算が実行される.

```r
vec1 > 2
## [1] FALSE FALSE  TRUE  TRUE
```

## 要素
ベクトルの要素はカギカッコで取り出す.

```r
num <- c(2,3,7,9)
num[3]
## [1] 7
```

取り出すだけななく付値することもできる.

```r
num[3] <- 500
num
## [1]   2   3 500   9
```

マイナスをつけるとその要素以外を取り出す.

```r
num[-3]
## [1] 2 3 9
```

複数取り出すこともできる.

```r
num[c(1,4)]
## [1] 2 9
```

他にも論理値ベクトルを使って取り出すことができる.

```r
idx <- c(TRUE,FALSE,TRUE,TRUE)
num[idx]
## [1]   2 500   9
```

さらに比較演算子と組み合わせることができる.

```r
(num > 4)
## [1] FALSE FALSE  TRUE  TRUE
num[num > 4]
## [1] 500   9
```

また `:` をもちいて連続したベクトルが作れるので, それを利用してベクトルを抜き出すことができる.

```r
2:4
## [1] 2 3 4
num[2:4]
## [1]   3 500   9
```

またベクトルには名前の属性をつけて構成することがでる.

```r
vec <- c(x= 3, y =3, z = 4)
```
また次のようにしてもよい.

```r
names(num) <- letters[1:4]
```

いずれに名前の属性をつけると次のようにしてアクセスが可能である.

```r
vec["x"]
## x 
## 3
num["d"]
## d 
## 9
```




## 関数
引数がベクトルの関数がいくつかある. 
これによってベクトルの和や積が簡単に扱える.

```r
x<-c(1,2,3,4,5)
sum(x)
## [1] 15
cumsum(x)
## [1]  1  3  6 10 15
prod(x)
## [1] 120
cumprod(x)
## [1]   1   2   6  24 120
```

平均, 中央値, 分散, 標準偏差などの統計関数も扱える.

```r
x <- c(x,10)
mean(x)
## [1] 4.166667
median(x)
## [1] 3.5
var(x)
## [1] 10.16667
sd(x)
## [1] 3.188521
```

ベクトルを並べ替えたり
最小値や最大値しめしたり, それが何番目の要素になるのかをしめすことができる.

```r
x <- c(3,3,5,0)
sort(x)
## [1] 0 3 3 5
sort(x,decreasing = TRUE)
## [1] 5 3 3 0
min(x)
## [1] 0
max(x)
## [1] 5
which.min(x)
## [1] 4
which.max(x)
## [1] 3
```

またベクトルに `NA` が含まれるき, 関数 `mean` などではデフォルトで結果が, `NA` になる.
それを避けるには `na.rm=TRUE` というオプションを付ける必要がある.


```r
x <- c(4,2,NA,3)
mean(x)
## [1] NA
mean(x, na.rm = TRUE)
## [1] 3
```

## 規則的なベクトル
`1:5` のような規則的なベクトルを柔軟に作成するのに `seq` を用いるとよい.

```r
1:5
## [1] 1 2 3 4 5
seq(1, 5)
## [1] 1 2 3 4 5
seq(1, 5, by = 2)
## [1] 1 3 5
seq(1, 5, length.out = 4)
## [1] 1.000000 2.333333 3.666667 5.000000
```

繰り返しを作成することができる `rep` も覚えておくと便利である.

```r
rep(1, 5)
## [1] 1 1 1 1 1
rep(c(1, 2), times = 3)
## [1] 1 2 1 2 1 2
rep(c(1, 2), each = 3)
## [1] 1 1 1 2 2 2
```

またアルファベットの文字列もあらかじめ組み込まれている.

```r
letters
##  [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q"
## [18] "r" "s" "t" "u" "v" "w" "x" "y" "z"
LETTERS
##  [1] "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P" "Q"
## [18] "R" "S" "T" "U" "V" "W" "X" "Y" "Z"
LETTERS[1:2]
## [1] "A" "B"
```

## 乱数ベクトル
ベクトルを出鱈目に並べ直すには関数 `sample` を使う

```r
set.seed(10)
sample(1:5)
## [1] 3 2 4 5 1
```
最初の行の関数 `set.seed` は他の環境でも再現可能性にするための設定である.


さて, この乱数は一旦出力された値は二度とでない非復元抽出である.
復元抽出にするには

```r
sample(1:5, replace=TRUE)
## [1] 2 2 2 4 3
```
とオプション `replace=TRUE` をつける.

いくつ取り出すかをオプション `size` で決められる.

```r
sample(LETTERS[1:2], size=10, replace=TRUE)
##  [1] "B" "B" "A" "B" "A" "A" "A" "A" "A" "B"
```
非復元抽出の場合, 取りうる値より大きくできないことに注意されたい.

さらに確率を `prob` で変えることができる. 

```r
sample(LETTERS[1:2], prob=c(0.8,0.2),size=10,replace=TRUE)
##  [1] "B" "A" "A" "A" "A" "A" "B" "A" "A" "A"
```

独立な一様分布にしたがう長さ `size` のベクトルは `runif(size)` によって, 正規分布にしたがうベクトルは `rnorm(size)` で出力される.

```r
size <- 8
runif(size)
## [1] 0.53559704 0.09308813 0.16980304 0.89983245 0.42263761 0.74774647
## [7] 0.82265258 0.95465365
rnorm(size)
## [1]  0.4829785 -0.5963106 -2.1852868 -0.6748659 -2.1190612 -1.2651980
## [7] -0.3736616 -0.6875554
```

