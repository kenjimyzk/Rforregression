---
output: html_document
---

# ベクトル
```{r}
#| label: setup
#| include: false
knitr::opts_chunk$set(echo = TRUE, collapse=TRUE)
```

## ベクトル
R では同じ型の値を集めたものをベクトルという。
ベクトルは `c()`（concatenate の略）を用いて構成する。既存のベクトルを渡すと、ひと続きのベクトルとして結合される点にも注意する。
```{r}
(num<-c(2,3,7,9))
(chr <- c("cat","dog","cow"))
```

ベクトルには長さという属性 (attribute) が付く。`length()` で要素数を取得できるほか、`str()` を使えばオブジェクトの構造をまとめて確認できる。
```{r}
length(num)
length(chr)
```
ベクトルはオブジェクトの基本単位であり、単一の値も長さ 1 のベクトルとみなせる。

型が混在している場合は、自動的に最も表現力の高い型へ変換される。強制変換の優先順位は、おおむね「論理値 → 数値 → 文字列」の順と覚えておくとよい。
文字列が 1 つでも含まれると、すべて文字列に変換される。
数値と論理値が混在している場合は、論理値が数値に強制変換され、`TRUE` は 1、`FALSE` は 0 になる。

```{r}
(x<- c(1,4))
typeof(x)
(y <- c(2,FALSE,"4"))
typeof(y)
(z <- c(2,FALSE))
typeof(z)
```

## 算術演算子
四則演算などの算術演算子は要素ごとに適用される。`^` は累乗、`%%` は剰余、`%/%` は整数除算（切り捨て）を表す。
```{r}
a<-c(2,3,3,3)
b<-c(3,3,5,7)
a+b
a-b
a*b
a/b
a^b
```

片方がスカラーであっても、同じ長さのベクトルに再利用されて演算される。
```{r}
a+2
a-2
a*2
a/2
a^2
```

長さが異なるベクトル同士を演算する場合、短い方のベクトルが自動的にリサイクルされて長さを揃える。
```{r}
c<-c(1,2)
a+c
a-c
a*c
a/c
a^c
```
ただし、短いベクトルの長さが長いベクトルの長さの約数でない場合は警告が表示される。

## 論理演算子
論理値を入力に取り、論理値を返す演算子を論理演算子という。
R では、否定 (`!`)、論理和 (`|`)、論理積 (`&`) などの演算子が用意されている。
これらの演算子も要素ごとに評価される。
`||` や `&&` といった二重記号の演算子は、最初の要素のみを評価する短絡演算子であり、条件分岐で判定回数を抑えたいときに使う。

```{r}
logic1 <- c(TRUE, FALSE, FALSE)
logic2 <- c(TRUE, TRUE, FALSE)
!logic1
logic1 | logic2
logic1 & logic2
```

`all()` はすべての要素が `TRUE` かどうか、`any()` は少なくとも 1 つが `TRUE` かどうかを判定する。

```{r}
any(logic1)
all(logic1)
```


## 比較演算子
2 つの値を比較して論理値を返す演算子を比較演算子という。
R では等しいかどうかを判定する `==`、大小を判定する `>` や `<` などが用意されている。
これらもベクトルの要素ごとに評価される。
```{r}
vec1 <- 1:4
vec2 <- c(2,1,3,4)
vec1 == vec2
vec1 > vec2
vec1 < vec2
```

不等号として `!=`（等しくない）、`>=`（以上）、`<=`（以下）も利用できる。
```{r}
vec1 != vec2 # !(vec1==vec2)
vec1 >= vec2 # (vec1 > vec2 | vec1 == vec2)
vec1 <= vec2 # (vec1 < vec2 | vec1 == vec2)
```

スカラーとベクトルを比較する場合は、スカラーが再利用されて要素ごとに評価される。
```{r}
vec1 > 2
```

`%in%` 演算子を使うと、左側のベクトル要素が右側のベクトルに含まれているかを判定できる。返り値は論理値のベクトルで、元の長さと同じになる。

```{r}
vec1 %in% 4:5
```

## 要素
ベクトルの要素は角括弧で取り出す。
```{r}
num <- c(2,3,7,9)
num[3]
```

取り出すだけでなく、新しい値を代入することもできる。
```{r}
num[3] <- 500
num
```

負のインデックスを指定すると、その位置の要素を除いたベクトルが得られる。
```{r}
num[-3]
```

複数の要素を同時に取り出すことも容易である。
```{r}
num[c(1,4)]
```

論理値ベクトルをインデックスとして使えば、条件に合致する要素のみを抽出できる。
```{r}
idx <- c(TRUE,FALSE,TRUE,TRUE)
num[idx]
```

比較演算子と組み合わせれば、条件式を直接インデックスに渡してフィルタリングできる。
```{r}
(num > 4)
num[num > 4]
```

`:` 演算子で連続した整数ベクトルを生成し、その範囲を指定して抜き出すこともできる。非整数のステップや逆順が必要な場合は `seq()` を利用すると柔軟に制御できる。
```{r}
2:4
num[2:4]
```

ベクトルには名前属性を付与できる。
```{r}
vec <- c(x= 3, y =3, z = 4)
```
別の方法として次のように設定できる。
```{r}
names(num) <- letters[1:4]
```

名前を付けると、文字列で要素を参照できる。
```{r}
vec["x"]
num["d"]
```
現在の名前一覧は `names()` で取得でき、不要になった場合は `names(num) <- NULL` のようにして削除する。




## 関数
ベクトルを引数に取る関数も多数用意されており、和や積などを簡単に計算できる。累積和（`cumsum()`）や累積積（`cumprod()`）は系列データの推移を追跡したいときに便利である。
```{r}
x<-c(1,2,3,4,5)
sum(x)
cumsum(x)
prod(x)
cumprod(x)
```

平均、中央値、分散、標準偏差といった統計量もワンライナーで求められる。
```{r}
x <- c(x,10)
mean(x)
median(x)
var(x)
sd(x)
```

ベクトルを並べ替えたり、最小値・最大値やその位置を取得したりする関数も充実している。
```{r}
x <- c(3,3,5,0)
sort(x)
sort(x,decreasing = TRUE)
min(x)
max(x)
which.min(x)
which.max(x)
```

欠損値 `NA` が含まれている場合、`mean()` など多くの集計関数は既定の挙動として `NA` を返す。
集計から欠損を除外したいときは、`na.rm = TRUE` を指定する。

```{r}
x <- c(4,2,NA,3)
mean(x)
mean(x, na.rm = TRUE)
```

## 規則的なベクトル
`1:5` のような規則的なベクトルを柔軟に作成するのに `seq` を用いるとよい。
```{r}
1:5
seq(1, 5)
seq(1, 5, by = 2)
seq(1, 5, length.out = 4)
```

繰り返しを作成することができる `rep` も覚えておくと便利である。
```{r}
rep(1, 5)
rep(c(1, 2), times = 3)
rep(c(1, 2), each = 3)
```

またアルファベットの文字列もあらかじめ組み込まれている。
```{r}
letters
LETTERS
LETTERS[1:2]
```

## 乱数ベクトル
ベクトルを無作為に並べ替えたり抽出したりするには `sample()` を使う。
```{r}
set.seed(10)
sample(1:5)
```
ここで `set.seed()` は乱数の種を固定し、別の環境でも同じ結果を再現できるようにするための設定である。

上記は一度選ばれた値を再度選ばない非復元抽出である。復元抽出にする場合は `replace = TRUE` を指定する。
```{r}
sample(1:5, replace = TRUE)
```
`size` 引数を指定すれば、取り出す要素数も制御できる。

```{r}
sample(LETTERS[1:2], size = 10, replace = TRUE)
```
非復元抽出では、`size` を母集合の長さより大きくすることはできない点に注意する。

さらに `prob` で各要素が選ばれる確率を指定できる（確率の合計は 1 になるようにする）。
```{r}
sample(LETTERS[1:2], prob = c(0.8, 0.2), size = 10, replace = TRUE)
```

独立な一様分布に従う長さ `size` のベクトルは `runif(size)`、平均と分散を指定した正規分布なら `rnorm(size, mean, sd)` で生成できる（既定値は平均 0、標準偏差 1）。
```{r}
size <- 8
runif(size)
rnorm(size)
```
