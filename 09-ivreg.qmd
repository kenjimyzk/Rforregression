---
output: html_document
editor_options: 
  markdown: 
    wrap: sentence
---

# 操作変数法

```{r}
#| label: setup
#| include: false
knitr::opts_chunk$set(echo = TRUE, collapse=TRUE)
```

## データ

```{r}
#| message: false
#| warning: false
library(AER)
library(wooldridge)
library(estimatr)
data("mroz", package="wooldridge")
df <- subset(mroz, inlf==1)
```

## 操作変数

これまで回帰モデルで一致推定量を得るためには次の仮定が必要であった。

1.  母集団が線形モデル
2.  標本が無作為抽出
3.  誤差項が平均ゼロで説明変数と無相関
4.  説明変数に多重共線性が存在しない

3つ目の仮定が必ずしも成立しない場合の推定方法を紹介する。

そのために、外生変数と内生変数と操作変数の3つの概念を導入する。
誤差項と相関が無い説明変数を **外生変数** といい、誤差項と相関がある説明変数を **内生変数** という。
**操作変数** とは、説明変数に含まれず、説明変数と相関をもち、誤差項と相関をもたない変数のことである。
なお操作変数の個数は内生変数の個数より多くなければならない。

R では `ivreg` 関数を用いて操作変数法を実行する。
この関数は `AER` パッケージに含まれており、基本的な書式は `ivreg(被説明変数 ~ 内生変数 | 操作変数, data=データフレーム)` である。
ここで被説明変数は `log(wage)`, 内生変数は `educ`, 操作変数は `fatheduc` である。

以下のコマンドで操作変数法を実行し、`coef()` 関数で推定された係数を取り出す。

```{r}
fm  <- ivreg(log(wage)~educ|fatheduc, data=df)
coef(fm)
```

傾きの推定値は操作変数推定量の公式を用いて直接計算することもできる。
具体的には、被説明変数と操作変数の共分散を内生変数と操作変数の共分散で割ることで得られる。
以下のコマンドで `cov()` 関数を用いて共分散を計算し、同じ推定値が得られることを確認する。

```{r}
with(df, cov(log(wage),fatheduc)/cov(educ,fatheduc))
```

## 2段階最小二乗法

複数の説明変数があり、操作変数の数が内生変数の数以上のとき、係数の一致推定量を得るには二段階最小二乗法を用いる。
二段階最小二乗法は次の手順で実行される:

1.  それぞれの内生変数を外生変数と操作変数に回帰させて、その予測値を得る。
2.  被説明変数を外生変数と内生変数の予測値に回帰させて、その係数を得る。

この係数が一致推定量になるための条件は以下である。

-   母集団が線形モデル
-   標本が無作為抽出
-   誤差項が平均ゼロで操作変数と外生変数に対して独立
-   操作変数は内生変数と相関をもつ
-   外生変数と内生変数の予測値に多重共線性が存在しない

R では `ivreg()` 関数を用いて二段階最小二乗法を実行する。
複数の説明変数がある場合の書式は `ivreg(被説明変数 ~ 内生変数 + 外生変数 | 外生変数 + 操作変数, data=データフレーム)` である。
ここで被説明変数は `log(wage)`, 内生変数は `educ`, 外生変数は `exper`, `I(exper^2)`, 操作変数は `motheduc`, `fatheduc` である。
注意点として、パイプ記号 `|` の右側には外生変数も含める必要がある。

以下のコマンドで二段階最小二乗法を実行し、`summary()` 関数で推定結果の要約を表示する。

```{r}
fm  <- ivreg(log(wage)~educ+exper+I(exper^2)|
            exper+I(exper^2)+motheduc+fatheduc,
            data=df)
summary(fm)
```

二段階最小二乗法の手順を `lm()` 関数を用いて手動で実行し、同じ係数推定値が得られることを確認できる。
ただし標準誤差の値が異なっている。
なぜなら残差は内生変数および外生変数から算出する必要があるが、以下のやり方だと内生変数の予測値および外生変数から算出するためである。

以下では第一段階として `lm()` 関数で内生変数 `educ` を外生変数と操作変数に回帰し、`fitted()` 関数で予測値を取得する。
第二段階として被説明変数を外生変数と内生変数の予測値に回帰する。

```{r}
ols1 <- lm(educ~exper+I(exper^2)+motheduc+fatheduc,  data = df)
ols2 <- lm(log(wage)~fitted(ols1)+exper+I(exper^2),  data = df)
summary(ols2)
```

### 複数制約の検定

帰無仮説が複数の係数制約を課す場合のワルド検定を実施する。
例えば、2つの外生変数 `exper` と `I(exper^2)` の係数がともにゼロであるという仮説を検定する。

まず `ivreg()` 関数で制約モデル（外生変数を含まないモデル）を推定し、`waldtest()` 関数で制約なしモデルと比較する。
`waldtest()` 関数は2つのモデルを引数にとり、ワルド検定を実行する。

```{r}
fm0 <- ivreg(log(wage)~educ|motheduc+fatheduc,data=df)
waldtest(fm0,fm)
```

LM検定（ラグランジュ乗数検定）も実行可能である。
まず `resid()` 関数で制約モデルの残差を取得し、その残差を制約される説明変数に回帰する。
`nrow()` 関数で観測数を取得し、決定係数 `r.squared` を乗じてLM統計量を計算する。
最後に `pchisq()` 関数でカイ二乗分布のP値を計算する（自由度は制約の数3）。

```{r}
lmt <- lm(resid(fm0)~educ + exper + I(exper^2) ,data=df)
(lmt <- nrow(df)*summary(lmt)$r.squared)
1-pchisq(lmt,df=3)
```

## 特定化検定

操作変数法が妥当かどうかを検証するために、複数の特定化検定を実施する。
`summary()` 関数にオプション `diagnostics = TRUE` を追加すると、弱操作変数検定（Weak instruments）、Wu-Hausman検定、Sargan検定を一度に実行できる。
これらの検定結果から、操作変数の妥当性、内生性の有無、操作変数の外生性を確認できる。

```{r}
summary(fm, diagnostics = TRUE)
```

### Weak instruments

操作変数が内生変数と弱い相関関係しかない場合、**弱操作変数**という。
弱操作変数の場合、推定量の性質が悪化するため、操作変数が十分に強い相関を持つかを検定する必要がある。

検定手順は以下の通りである。
それぞれの内生変数に対して、帰無仮説を内生変数を外生変数のみに回帰させたモデルとし、対立仮説を内生変数を外生変数および操作変数に回帰させたモデルとし、F検定を実施する。

以下のコマンドで `lm()` 関数による制約モデルを推定し、`anova()` 関数で第一段階の回帰モデル `ols1` と比較してF検定を実行する。
この結果が先の `diagnostics = TRUE` で得られた弱操作変数検定と同じであることを確認されたい。

```{r}
ols0 <- lm(educ ~ exper + I(exper^2), data = df)
anova(ols0, ols1)
```

### Wu-Hausman 検定

Wu-Hausman 検定は帰無仮説が誤差項と説明変数が無相関、対立仮説が誤差項と説明変数が相関ありの検定を行う。
帰無仮説のもとでは、OLSも2SLSも一致推定量であるが、OLSの方が効率的である。
よって検定統計量のP値が十分小さいなら帰無仮説は棄却され、内生性があることになり操作変数法（2SLS）を選択する。
そうでなければより効率的な最小二乗法（OLS）を実施する。

具体的には以下のF検定を実施する。

1.  `lm()` 関数でそれぞれの内生変数を外生変数に回帰し、`resid()` 関数で残差を得る (`resid(ols1)`)
2.  `lm()` 関数で被説明変数を説明変数に回帰する (`ols3`)
3.  `update()` 関数で被説明変数を説明変数および先程の残差に回帰する (`ols4`)
4.  `anova()` 関数でこれらの残差の係数はゼロであるという帰無仮説のもとF検定を実施する

以下のコマンドが先の `diagnostics = TRUE` で得られたWu-Hausman検定と同じであることを確認されたい。

```{r}
ols3 <- lm(log(wage) ~ educ  + exper + I(exper^2), data = df)
ols4 <- update(ols3, . ~ . + resid(ols1))
anova(ols3,ols4)
```

### Sargan 検定

Sargan 検定は誤差項が操作変数（および外生変数）と相関しているかどうかを検定する。
帰無仮説は操作変数が外生的である（相関が無い）場合で、対立仮説は操作変数が内生的である（相関がある）場合である。
この検定は操作変数が過剰識別されている（操作変数の数が内生変数の数より多い）場合にのみ実施可能である。

LM検定（ラグランジュ乗数検定）を以下の手順で実施する。

1.  `resid()` 関数で二段階最小二乗法を実施したときの残差を得る (`resid(fm)`)
2.  `lm()` 関数で残差を外生変数および操作変数に回帰する
3.  `nrow()` 関数で観測数を取得し、回帰の決定係数 `r.squared` を乗じたLM統計量を得る
4.  `pchisq()` 関数で検定統計量のP値を計算する。検定統計量は帰無仮説のもと、操作変数の数から内生変数の数を差し引いた自由度（この例では1）のカイ二乗分布にしたがう

以下のコマンドが先の `diagnostics = TRUE` で得られたSargan検定と同じであることを確認されたい。

```{r}
jt <- lm(resid(fm)~exper+I(exper^2)+motheduc+fatheduc,data=df)
(jt <- nrow(df)*summary(jt)$r.squared)
1-pchisq(jt,df=1)
```

## ロバスト分散

以上の分析は、誤差項が操作変数と独立かつ均一分散の場合の分析である。
独立でない場合や分散不均一の場合、推定量の分散が変わりうる。
そうした場合に頑健な分散推定量を**ロバスト分散**という。

ロバスト分散にもとづく推定結果を得るには、`summary()` 関数にオプション `vcov = vcovHC` を追加する。
`vcovHC()` 関数は不均一分散に頑健な分散共分散行列を計算する関数である。
オプション `df = Inf` は自由度を無限大とし、t分布ではなく正規分布を用いて検定を行う。

```{r}
summary(fm, vcov = vcovHC, df = Inf)
```

係数の検定結果のみを表示したい場合は、`coeftest()` 関数を用いる。
この関数は推定されたモデルオブジェクトと分散共分散行列を引数にとり、係数のt検定結果を表示する。

```{r}
coeftest(fm, vcov=vcovHC)
```

ロバスト分散のもとでの複数制約のワルド検定を実施するには、`waldtest()` 関数にオプション `vcov=vcovHC` を追加する。

```{r}
waldtest(fm0,fm, vcov=vcovHC)
```

最近開発されたパッケージ `estimatr` の `iv_robust()` 関数を用いるとロバスト分散のもとの推定値が簡単に計算できる。
この関数はデフォルトでロバスト標準誤差（HC2型）を計算し、オプション `diagnostics = TRUE` で特定化検定も同時に実行できる。
書式は `ivreg()` 関数と同じである。

以下のコマンドで `iv_robust()` 関数による推定を実行し、`summary()` 関数で結果を表示する。

```{r}
fm2 <- iv_robust(log(wage)~educ+exper+I(exper^2)|
            exper+I(exper^2)+motheduc+fatheduc,
            data=df,diagnostics =TRUE)
summary(fm2)
```

オプション `se_type = "stata"` を用いればSTATAと同じ標準誤差の計算が可能である。
また、ロバスト分散のもとで特定化検定（弱操作変数検定、Wu-Hausman検定、Sargan検定）が実行される。

分散均一性を仮定した古典的な標準誤差を計算したい場合は、オプション `se_type = "classical"` を追加する。

```{r}
fm3 <- iv_robust(log(wage)~educ+exper+I(exper^2)|
            exper+I(exper^2)+motheduc+fatheduc,
            data=df,diagnostics =TRUE,se_type = "classical")
summary(fm3)
```

### 分散不均一の検定

誤差項が操作変数と独立なら条件付き分散は操作変数に無関係で均一である。
これを利用して分散均一を帰無仮説に、分散不均一を対立仮説にしたBP検定（Breusch-Pagan検定）が実行可能である。
ただし、通常の `bptest()` 関数では正しく実行できないので、手動で実行する必要がある。

以下の手順でBP検定を実行する。

1.  `I()` 関数と `resid()` 関数を用いて二段階最小二乗法の残差の二乗を計算する (`I(resid(fm)^2)`)
2.  `lm()` 関数で残差の二乗を外生変数および操作変数に回帰する
3.  `nrow()` 関数で観測数を取得し、決定係数 `r.squared` を乗じてLM統計量を得る
4.  `pchisq()` 関数で検定統計量のP値を計算する。検定統計量は帰無仮説のもと、説明変数の数（この例では4）の自由度のカイ二乗分布にしたがう

```{r}
bpt <- lm(I(resid(fm)^2)~exper + I(exper^2) + motheduc + fatheduc,data=df)
(bpt <- nrow(df)*summary(bpt)$r.squared)
1-pchisq(bpt,df=4)
```
